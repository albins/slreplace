%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\usepackage{amsmath, amssymb, latexsym}
\usepackage{graphicx}
\usepackage{epic,eepic}

\pagestyle{plain}
\usepackage{listings}
\usepackage{psfrag}
\usepackage{rotating}

\usepackage{url}
\usepackage{amssymb,epsfig,amstext}
\usepackage{txfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{graphicx}

\usepackage{todonotes}
\usepackage{multirow}
\usepackage{float,color}
\usepackage{picinpar,color,xcolor,wrapfig}
\setcounter{secnumdepth}{4}
\sloppy

%%%%%%%%%%%%%%%   MACROS  %%%%%%%%%%%%%%%%%%


\input{macros.tex}
\newcommand{\tl}[1]{\textcolor{blue} {TL: #1 :TL} }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% Title information
\title[String constraints with integers]{Decision procedure for string constraints  
	involving the integer data type}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{}                     %% \subtitle is optional
%\subtitlenote{}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
We consider straight-line string constraints involving string and integer data types, specifically, we consider string constraints including concat, replaceall, transducers, reverse, substring, indexof, and length. We design the decision procedure based on a variant of cost register automata.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{}
\ccsdesc[300]{}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{TBP}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%
%main text
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

As discussed, the whole point is to use INCRA in replace of FT 

\section{Preliminaries}
\label{prel}

Definition for NFA, NFT.

\section{The logic SL$_{int}$}

We consider two data types, the string data type and the integer data type. We will use $c, d,\dots$ to denote integer constants, $u, v, \dots$ to denote string constants,  $i, j, \dots$ to denote the  integer variables, and $x, y, \dots$ to denote the string variables.

\subsection{The concrete version}

SL$_{int}$ comprises all the formulae $S \wedge A$ defined by the following rules,
\[
\begin{array}{l c l}
t  &::=& i \mid c \mid \length(x) \mid \indexof_u(x, i) \mid t + t,   \\
S &::= & i:= t \mid x := \substring(y, i, j)  \mid x:= y \concat z \mid x:= \replaceall_{e,u}(y) \mid\\
&&  x:=\reverse(y) \mid x:=T(y) \mid S;S, \\
A & ::= &   x \in \Aut \mid t\ o\ t \mid A \wedge A,
\end{array}
\]
where $c$ is an integer constant, $e$ is a regular expression,  $u$ is a string constant, $T$ is an NFT, $\Aut$ is an NFA, and $o \in \{=, \neq, \le, \ge, <, >\}$.
Note that $\replaceall_{e,u}$ is the replaceAll function where $e$ and $u$ are the pattern and the replacement arguments.



We assume that $S$ is in single static assignment (SSA) form. Moreover, for technical convenience, we assume that all the assignments $i: = t$ in $S$ satisfy that $t= \length(x)$, $t=\indexof_u(x, j)$, or $t$ contains no occurrences of $\length$ or $\indexof$ functions. We also assume that all the variables in $A$ also occur in $S$. 



\subsection{The abstract version}

To be more abstract, we consider string formulae $S \wedge A$, where $A$ is as above and $S$ is defined by the following rules,
\[
\begin{array}{l c l}
t  &::=& i \mid c \mid g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k}) \mid t + t,   \\
S &::= & i:= t \mid x:=f(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k}) \mid S;S, \\
\end{array}
\]
where $\vec{i_j} = i_{j,1}, \cdots, i_{j, n_j}$ for each $j \in [k]$, $f$ is of the arity $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^{\Sigma^*}$ and $g$ is of the arity $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^\intnum$ (note that $f$ resp. $g$ can be  nondeterministic).

We assume that $S$ is in single static assignment (SSA) form. Moreover, for technical convenience, we assume that all the assignments $i: = t$ in $S$ satisfy that either $t= g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, or $t$ contains no occurrences of the functions $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$. We also assume that all the variables in $A$ also occur in $S$. 


\section{Incremental nondeterministic cost register automata (INCRA)}

%Let $X$ be a set of registers and $G_{inc}(X)$ denote the set of terms defined by the rules $t::=c \mid x \mid t+c$, where $c$ is an integer constant.  We interpret terms from $G_{inc}(X)$ over the set of integers.

%<<<<<<< .mine
%An incrementing nondeterministic cost register automaton (INCRA) $\Aut$ is a tuple $(\Sigma, Q, q_0, F, X, \delta)$, where $\Sigma$ is a finite alphabet, $Q$ is a finite set of states, $q_0$ is the initial state, $F$ is the set of final states, $X$ is a finite set of registers, $\delta$ comprises the tuples $(q, \sigma, q', \eta)$ such that $\eta$ is the update function satisfying that for each $x \in X$, $\eta(x) = x+c$ for some integer constant $c$. For readability, we write a transition $(q, \sigma, q', \eta)$ as $q \xrightarrow{\sigma, \eta} q'$.
%||||||| .r32
%An Incrementing nondeterministic cost register automaton (INCRA) $\Aut$ is a tuple $(\Sigma, Q, q_0, F, X, \delta)$, where $\Sigma$ is a finite alphabet, $Q$ is a finite set of states, $q_0$ is the initial state, $F$ is the set of final states, $X$ is a finite set of registers, $\delta$ comprises the tuples $(q, \sigma, q', \eta)$ such that $\eta$ is the update function satisfying that for each $x \in X$, $\eta(x) = x+c$ for some integer constant $c$. For readability, we write a transition $(q, \sigma, q', \eta)$ as $q \xrightarrow{\sigma, \eta} q'$.
%=======
\begin{definition}
	
	An Incremental nondeterministic cost register automaton (INCRA) $\Aut$ is a tuple $(\Sigma, Q, I, F, R, \delta)$, where $\Sigma$ is a finite alphabet, $Q$ is a finite set of states, $I\subseteq Q$ is a set of initial states, $F$ is a set of final states, $R=r_1\cdots r_m$ is a vector of registers, $\delta$ comprises the tuples $(q, \sigma, q', \eta)$ such that $\eta$ is the update function satisfying that for each $r \in R$, $\eta(r) = r+c$ for some integer constant $c$. For readability, we write a transition $(q, \sigma, q', \eta)$ as $q \xrightarrow{\sigma, \eta} q'$.
\end{definition}

Note that for the purpose of this note, INCRA are adapted from CRA in \cite{RLJ+13} by allowing the nondeterminism and discarding the partial final cost function $\mu$.

Let $\Aut=(\Sigma, Q, I, F, R, \delta)$ be an INCRA with $R=r_1\cdots r_m$. Over an input word $w=\sigma_1 \cdots \sigma_n \in \Sigma^+$, a run of $\Aut$ on $w$ is a sequence $q_0 \xrightarrow{\sigma_1, \eta_1} q_1 \cdots q_{n-1} \xrightarrow{\sigma_n, \eta_n} q_n$ such that $q_0 \in I$ and $(q_{i-1}, \sigma_i, \eta_i, q_i) \in \delta$ for each $i \in [n]$. A run is accepting if $q_n \in F$. The output of an accepting run of $\Aut$ on $w$ is a tuple $(i_1,\cdots, i_m)$, where $i_j = \eta_n(r_j) (\cdots \eta_1(r_j)(0)\cdots)$ for each $j \in [m]$. Note that the initial value of each register $r_j$ is zero. We define $\Aut(w)$ as the set of outputs of the accepting runs of $\Aut$ on $w$ (possibly it is an empty set). Note the in general, an output of an INCRA is a tuple, instead of a single integer. Moreover, we also use $\Lang(\Aut)$ to denote $\{w \in \Sigma^* \mid \Aut(w) \neq \emptyset\}$ and $\cR(w) = \{(w, \vec{n}) \mid \vec{n} \in \Aut(w)\}$.

Given two INCRAs $\Aut_1 = (\Sigma, Q_1, I_1, F_1, R_1, \delta_1)$ and $\Aut_2 = (\Sigma, Q_2, I_2, F_2, R_2, \delta_2)$ with $R_1 \cap R_2 = \emptyset$, we define the product of $\Aut_1$ and $\Aut_2$, denoted by $\Aut_1 \times \Aut_2$, as $(\Sigma, Q_1 \times Q_2, I_1 \times I_2, F_1 \times F_2, R_1 \cdot R_2, \delta)$ such that $\delta$ comprises the tuples $((q_1, q_2), \sigma, (q'_1, q'_2), \eta)$ such that there are $\eta_1, \eta_2$ satisfying that $(q_1, \sigma, q'_1, \eta_1) \in \delta_1$, $(q_2, \sigma, q'_2, \eta_2) \in \delta_2$, and $\eta = \eta_1\cup \eta_2$.

Given an INCRA $\Aut  = (\Sigma, Q, I, F, R, \delta)$, the inverse of $\Aut$, denoted by $\Aut^{(r)}$, is $(\Sigma, Q, F, I, R, \delta')$ where $\delta'$ comprises the set of tuples $(q', \sigma, q, \eta)$ such  $(q, \sigma, q', \eta) \in \delta$. Note that according to the definition, over each word $w$, $\Aut^{(r)}(w) = \Aut(w)$. 

\begin{definition}[INCRA-LA SAT]
	Let $\Aut_1=(\Sigma, Q_1, I_1, F_1, R_1, \delta_1), \cdots, \Aut_k=(\Sigma, Q_k, I_k, F_k, R_k, \delta_k)$ be INCRAs with $R_i \cap R_j = \emptyset$ for each $i \neq j \in [k]$ and $\phi$ be a (quantifier-free) linear arithmetic formula over $R_1 \cdot \cdots \cdot R_k$. Then $\phi$ is said to be satisfiable w.r.t. $\Aut_1, \cdots, \Aut_k$ if  there are words $w_1, \cdots, w_k$ and $\vec{c_1} \in \Aut_1(w_1),\dots, \vec{c_k} \in \Aut_k(w_k)$ such that $\phi(\vec{c_1}, \cdots, \vec{c_k})$ holds.
\end{definition}

\begin{theorem}\label{thm-incra-la-sat}
	The INCRA-LA SAT problem is decidable.
\end{theorem}

For the proof of Theorem~\ref{thm-incra-la-sat}, we state and prove the following lemma.

\begin{lemma}\label{lem-incra-la}
	Let $\Aut=(\Sigma, Q, I, F, R, \delta)$ be an INCRA with $R= r_1 \cdots  r_m$. Then there is an existential linear arithmetic formula $\varphi_\Aut(r_1, \cdots, r_m)$ such that $ \{(c_1, \cdots, c_m) \mid \varphi_\Aut(c_1, \cdots, c_m) \mbox{ holds}\} = \bigcup \limits_{w \in \Sigma^*} \Aut(w)$.
	%\tl{not quite sure about the formulation of the lemma.}
\end{lemma}

\begin{proof}
	Let $\delta = \{\tau_1, \cdots, \tau_l\}$ such that $\tau_j = (p_j, \sigma_j, p'_j, \eta_j)$ and $\eta_j(r_i) = r_i + c_{i,j}$ for each $j \in [l]$ and $i \in [m]$.
	For each pair of states $(q, q') \in I \times F$, it is not hard to compute a Presburger arithmetic formula $\varphi_{q,q'}(j_1, \cdots, j_l)$ such that $\{(c_1, \cdots, c_l) \mid \varphi_{q,q'}(c_1, \cdots, c_l) \mbox{ holds}\}$ defines the Parikh image of the sequence of transitions of $\Aut$ starting from $q$ and ending at $q'$. 
	
	Then 
	\[\varphi_\Aut ::= \bigvee \limits_{(q,q') \in I \times F} \exists j_1 \cdots \exists j_l.\ \varphi_{q,q'}(j_1, \cdots, j_l) \wedge \bigwedge \limits_{i \in [m]} r_i = \sum \limits_{j \in [l]} c_{i,j} j_j.\]
	\qed
\end{proof}

\begin{proof}[Theorem~\ref{thm-incra-la-sat}]
	Suppose for each $i \in [k]$, $R_i = r_{i, 1} \cdots r_{i, r_i}$. Then we reduce the INCRA-LA SAT problem to the satisfiability of the following existential linear arithmetic formula
	\[
	\phi \wedge \bigwedge \limits_{i \in [k]} \varphi_{\Aut_i}(r_{i,1}, \cdots, r_{i, r_i}).
	\]
	\qed
\end{proof}

%========================================================================================

\section{Decision procedure}

\begin{definition}[Pre-image of $f$]
	Let $f(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k}): \Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^{\Sigma^*}$ and $\Aut$ be an INCRA. Then the pre-image of $f$ under $\Aut$, denoted by $f^{-1}(\Aut)$, is defined as 
	\[f^{-1}(\Aut) = \{(w_1, \vec{c_1}, \cdots, w_k, \vec{c_k}) \mid \exists w \in \Sigma^*.\ w \in f(w_1, \vec{c_1}, \cdots, w_k, \vec{c_k}) \mbox{ and } \Aut(w) \neq \emptyset\}.\]
\end{definition}

\begin{definition}[Cost-preserving INCRA-representation of pre-image of $f$]
	Let $f(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k}): \Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^{\Sigma^*}$ and $\Aut=(\Sigma, Q, I, F, R, \delta)$ be an INCRA with $R=r_1 \cdots r_m$.
	Then a cost-preserving representation of $f^{-1}(\Aut)$ is a pair $((\cB_{j, 1}, \cdots, \cB_{j, k})_{j \in [\ell]}, \vec{t})$ (where $\ell \ge 1$) such that 
	\begin{itemize}
		\item for each $j \in [\ell]$ and $j' \in [k]$, $\cB_{j, j'} = (\Sigma, Q'_{j, j'}, I'_{j,j'}, F'_{j,j'}, R'_{j,j'}, \delta'_{j,j'})$ with $R'_{j,j'} = \vec{i_{j'}} \cdot\ \vec{r'_j}$, where $\vec{r'_1} = r'_{1,1}  \cdots  r'_{1, m}, \cdots, \vec{r'_k} = r'_{k, 1} \cdots r'_{k, m}$ are mutually distinct fresh registers,
		%
		\item $\vec{t}=(t_1,\cdots, t_m)$ such that for each $j'' \in [m]$, $t_{j''} $ is a linear combination of $r'_{1, j''}, \cdots, r'_{k, j''}$,  
		%
		%\item $f^{-1}(\Aut) = \bigcup \limits_{j \in [\ell]} \cR'(\cB_{j,1}) \times \cdots \times \cR'(\cB_{j,k})$, where $\cR'(\cB_{j, j'}) = \{(w, prj_{\vec{i_{j'}}}(\vec{c_{j,j'}})) \mid \vec{c_{j,j'}} \in \cB_{j,j'}(w)\}$, (where $prj_{\vec{i_{j'}}}(\vec{c_{j,j'}})$ means the projection of $\vec{c_{j,j'}}$ to the positions corresponding to $\vec{i_{j'}}$)
		%
		\item for each $(w_1,\vec{c_1}, \cdots, w_k, \vec{c_k}) \in f^{-1}(\Aut)$, we have 
		\[
		\begin{array}{l l}
		& \bigcup \limits_{w \in f(w_1,\vec{c_1}, \cdots, w_k, \vec{c_k}) }  \Aut(w) \\
		= & \left\{\vec{t}[\vec{d_1}/\vec{r'_1},\cdots, \vec{d_k}/\vec{r'_k}]\ \big\vert\ (w_1,\vec{c_1} \cdot \vec{d_1}, \cdots, w_k, \vec{c_k} \cdot \vec{d_k}) \in \bigcup \limits_{j \in [\ell]} \cR(\cB_{j,1}) \times \cdots \times \cR(\cB_{j,k})\right\}.
		\end{array}
		\]
	\end{itemize}
\end{definition}

\begin{definition}[INCRA-representation of $g$]
	Let $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k}): \Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^\intnum$ and $r$ be a register. Then a representation of $g$ w.r.t. $r$ is a pair $((\cB_{j, 1}, \cdots, \cB_{j, k})_{j \in [\ell]}, t)$ such that 
	\begin{itemize}
		\item for each $j \in [\ell]$ and $j' \in [k]$, $\cB_{j, j'} = (\Sigma, Q'_{j, j'}, I'_{j,j'}, F'_{j,j'}, R'_{j,j'}, \delta'_{j,j'})$ with $R'_{j,j'} = \vec{i_{j'}} \cdot\ r'_j$, where $r'_1, \cdots, r'_k$ are mutually distinct fresh registers,
		%
		\item $t$ is a linear combination of $r'_{1}, \cdots, r'_{k}$,  
		%
		%\item $f^{-1}(\Aut) = \bigcup \limits_{j \in [\ell]} \cR'(\cB_{j,1}) \times \cdots \times \cR'(\cB_{j,k})$, where $\cR'(\cB_{j, j'}) = \{(w, prj_{\vec{i_{j'}}}(\vec{c_{j,j'}})) \mid \vec{c_{j,j'}} \in \cB_{j,j'}(w)\}$, (where $prj_{\vec{i_{j'}}}(\vec{c_{j,j'}})$ means the projection of $\vec{c_{j,j'}}$ to the positions corresponding to $\vec{i_{j'}}$)
		%
		\item for each $(w_1,\vec{c_1}, \cdots, w_k, \vec{c_k}) \in \Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k}$, we have 
		\[
		\begin{array}{ l l }
		& g(w_1,\vec{c_1}, \cdots, w_k, \vec{c_k}) \\
		= &
		\left\{t[d_1/r'_1,\cdots, d_k/r'_k]\ \big\vert\ (w_1,\vec{c_1} \cdot d_1, \cdots, w_k, \vec{c_k} \cdot d_k) \in \bigcup \limits_{j \in [\ell]} \cR(\cB_{j,1}) \times \cdots \times \cR(\cB_{j,k})\right\}.
		\end{array}
		\]
	\end{itemize}
\end{definition}

\paragraph*{Semantic conditions of SL$_{int}$.} 
$S$ satisfies the following two conditions,
\begin{itemize}
	\item for each function $f$ occurring in $S$, there is an effective procedure to compute for a given INCRA $\Aut$, a cost-preserving INCRA-representation of $f^{-1}(\Aut)$, 
	%
	\item for each function $g$ occurring in $S$, there is an effective procedure to compute for a given register $r$, an INCRA-representation of $g$ w.r.t. $r$.
\end{itemize}

Note that $z = \replaceall_e(x,y)$ does not satisfy the semantic conditions, since the length of $z$ is nonlinear w.r.t. the lengths of $x$ and $y$ in general.

\begin{theorem}
	Satisfiability of abstract SL$_{int}$ satisfying the semantic conditions is decidable.
\end{theorem}

Proof idea: Backward computation. Record relationship between integer variables in $A$.

The decision procedure 

\begin{corollary}
	Satisfiability of concrete SL$_{int}$ is decidable.
\end{corollary}

Let $\Aut=(\Sigma, Q, I, F, X, \delta)$ be an INCRA. 
\begin{itemize}
	\item Then $\concat^{-1}(\Aut)$ is defined as $(\Aut_{I, q}, \Aut_{q, F})_{q \in Q}$ where $\Aut_{I, q}=(\Sigma, Q, I, \{q\}, X, \delta)$ and  $\Aut_{q, F}=(\Sigma, Q, \{q\}, F, X, \delta)$.
	
	\item $\reverse^{-1}(\Aut) = \Aut^{(r)}$.
	
	\item $\substring^{-1}(\Aut)$ is the INCRA $(\Sigma, Q \times \{p_0, p_1, p_2\}, I \times \{p_0\}, F \times \{p_2\}, X \cup \{y_1, y_2\}, \delta')$ such that $\delta'$ comprises 
	\begin{itemize}
		\item the tuples $((q, p_0), \sigma, (q', p_0), \eta')$ such that $(q, \sigma, q', \eta) \in \delta$, $\eta' = \eta \cup \{y_1 \rightarrow y_1+1, y_2 \rightarrow y_2+1\}$,
		%
		\item the tuples $((q, p_0), \sigma, (q', p_1), \eta')$ such that $(q, \sigma, q', \eta) \in \delta$, and $\eta' = \eta \cup \{y_1 \rightarrow y_1+1, y_2 \rightarrow y_2+1\}$,
		%
		\item the tuples $((q, p_1), \sigma, (q', p_1), \eta')$ such that $(q, \sigma, q', \eta) \in \delta$, $\eta' = \eta \cup \{y_1 \rightarrow y_1, y_2 \rightarrow y_2+1\}$,
		%
		\item the tuples $((q, p_1), \sigma, (q', p_2), \eta')$ such that $(q, \sigma, q', \eta) \in \delta$, and $\eta' = \eta \cup \{y_1 \rightarrow y_1, y_2 \rightarrow y_2+1\}$,
		%
		\item the tuples $((q, p_2), \sigma, (q', p_2), \eta')$ such that $(q, \sigma, q', \eta) \in \delta$, $\eta' = \eta \cup \{y_1 \rightarrow y_1, y_2 \rightarrow y_2\}$.
		%
	\end{itemize}
	%
	\item Let $T= (\Sigma, Q', I', F', \delta')$ such that $\delta' \subseteq Q' \times \Sigma \times Q' \times \Sigma^*$. Then $T^{-1}(\Aut) = (\Sigma, Q \times Q', I \times I', F \times F', \delta'')$ such that $\delta''$ comprises the tuples $((q_1, q'_1), \sigma, (q_2, q'_2), \eta')$ satisfying that $(q'_1, \sigma, q'_2, u) \in \delta'$ with $u = \sigma_1 \cdots \sigma_i$, $p_1 \xrightarrow{\sigma_1, \eta_1} p_2 \cdots \xrightarrow{\sigma_i, \eta_i} p_{i+1}$ with $p_1 = q_1$ and $p_{i+1}= q_2$, and $\eta' = \eta_1 \circ \cdots \circ \eta_i$.
	%
	\item  Let $T_{e,u}$ be the NFT corresponding to $\replaceall_{e,u}$. Then $\replaceall^{-1}_{e,u}(\Aut)=T^{-1}_{e,u}(\Aut)$.
	% 
\end{itemize}


Moreover, we know that $i := \length(x)$ and $i := \indexof_u(x, j)$ can be captured by INCRA.

Let $S$ be a program where all the assignments $i:= t$ are flattened in the sense that they are of the form $i: = j+c$, or $i:=j+j'$, or $i:=\length(x)$, or $i: = \indexof_u(x, j)$. The decision procedure for the path feasibility of $S$ goes backwards iteratively as follows:
\begin{itemize}
	\item if the last assignment of the current program of the form neither $i: = j+ c$ nor $i: = j+j'$ is   $x := \substring(y, i, j)$, $x:= y \concat z$, $x:= \replaceall_{e,u}(y)$, $x:=\reverse(y)$, or $x:=T(y)$,  then construct the product INCRA $\Aut$ of all the INCRA for $x$, and replace the last assignment with $y \in \substring^{-1}(\Aut)$, or $y \in \Aut_{I, q}; z \in \Aut_{q, F} $ for some $q \in Q$, or $y \in \replaceall_{e,u}^{-1}(\Aut)$, or $y \in \reverse^{-1}(\Aut)$, or $y \in T^{-1}(\Aut)$,
	%
	\item if the last assignment of the current program of the form neither $i: = j+ c$ nor $i: = j+j'$ is $i: = t$ such that $t = \length(x)$ or $t = \indexof_u(x, j)$, then replace $i: = t $ with $y \in \Aut_{\length, i}$, or $x \in \Aut_{\indexof_u, i, j}$.   
	%
\end{itemize}
Then after the above procedure, we get a program $S'$ where all the assignments are of the form $i: = j+ c$ or $i: = j+j'$ and all the other statements are of the form $x \in \Aut$ for some INCRA $\Aut$. Then the path feasibility of $S'$ is reduced to the INCRA LA-SAT problem. The decidability follows from Theorem~\ref{thm-incra-la-sat}.



%% Acknowledgments
%\begin{acks}                            %% acks environment is optional
%                                        %% contents suppressed with 'anonymous'
%  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%  %% acknowledge financial support and will be used by metadata
%  %% extraction tools.
%  This material is based upon work supported by the
%  \grantsponsor{GS100000001}{National Science
%    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%  conclusions or recommendations expressed in this material are those
%  of the author and do not necessarily reflect the views of the
%  National Science Foundation.
%\end{acks}


% Bibliography
\bibliography{string}


%% Appendix
\appendix
\section{Appendix}

 

\end{document}
