%% For double-blind review submission
\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[sigplan,10pt]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format should change 'sigplan,10pt' to
%% 'acmlarge'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
                        
\usepackage{latexsym}
\usepackage{setspace}
\usepackage{cancel}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{leftidx}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage{color}
\usepackage{mathrsfs}
\usepackage{tikz}
\usetikzlibrary{shapes}
           %\usepackage{times}
\usepackage[linesnumbered,ruled]{algorithm2e}
           
           
 \input{macros.tex}
           
           
\newcommand{\yan}[1]{\color{green} {YA: #1 :AY} \color{black}}
\newcommand{\zhilin}[1]{\color{cyan} {ZL: #1 :LZ} \color{black}}
\newcommand{\tl}[1]{\color{blue} {TL: #1 :LT} \color{black}}
                        
                        
                        
\newcommand{\concat} {\circ}
\newcommand{\replace} {{\sf replace}}
\newcommand{\str} {{\sf Str}}
\newcommand{\intnum} {{\sf Int}}
\newcommand{\regexp} {{\sf RegExp}}
\newcommand{\strarr} {{\sf StringArray}}
\newcommand{\dtypes} {{\sf DataTypes}}
\newcommand{\anarr} {{\mathbb{A}}}


\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].



\begin{document}

%% Title information
\title[]{Decision Procedures for String Constraints	with ReplaceAll function}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

\cite{LB16,TCJ16,YABI14}

\section{Killer examples}

%https://github.com/kimmobrunfeldt/progressbar.js/blob/master/src/utils.js

\begin{verbatim}

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
function render(template, vars) {
var rendered = template;

for (var key in vars) {
if (vars.hasOwnProperty(key)) {
var val = vars[key];
var regExpString = '\\{' + key + '\\}';
var regExp = new RegExp(regExpString, 'g');

rendered = rendered.replace(regExp, val);
}
}

return rendered;
}
\end{verbatim}

\section{Preliminaries}

For $k \in \Nat$, let $[k] = \{1,\dots, k\}$.

For a vector $\vec{x}=(x_1,\dots, x_n)$, let $|\vec{x}|$ denote $n$ and for each $i \in [n]$, let $\vec{x}(i)$ denote $x_i$. For a vector $\vec{x} = (x_1, \dots, x_n)$, let $\red(\vec{x})$ denote $(x_{i_1},\dots, x_{i_m})$ such that for each $j \in [m]$, $x_{i_j}$ is different from all $x_1, \dots, x_{i_j-1}$.

An alphabet $\Sigma$ is fixed.

We consider the following data types: String data type $\str$, Integer data type $\intnum$, and Array of strings $\str [\ ]$.


We assume a countably set of variables, of data types form $\dtypes$. We will use $x, y, z, \dots$ to denote the variables of data type $\str$, and $n, n', \dots$ to denote the variables of type $\intnum$. In addition, we use $X, Y, Z, \dots$ to denote the variables of data type $\str[\ ]$.
We use $u, v, w, \dots$ to denote the constant strings, and $c, c',\dots$ to denote the constant integers.


For a string $u \in \Sigma^+$, let $|u|$ denote the length of $u$, in addition, for $i \in [|u|]$, let $u[i]$ the $i$-th letter of $u$.

\begin{definition}[Regular expressions $\regexp$]
	\[e \eqdef a \mid e + e \mid e \concat e \mid e^\ast, \mbox{ where } a \in \Sigma. \]
	We also use the abbreviations $\Sigma \equiv \cup_{a \in \Sigma}\ a$ and $\Sigma^\ast \equiv (\cup_{a \in \Sigma}\ a)^\ast$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
	A regular expression $e$ is said to be \emph{bounded} if $e$ is defined by the rules, $e \eqdef a \mid u^\ast \mid e \concat e$, where $u$ is a constant string. For instance, $a (bc)^\ast$ is bounded, while $(ab^\ast)^\ast$ is not. A regular expression $e$ is a union of bounded regular expressions if $e = e_1 + \dots + e_k$ such that each $e_i$ is a bounded regular expression. We use UBR to abbreviate the set of regular expressions which are a union of bounded regular expressions.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A nondeterministic finite automata (NFA) $\cA$ on $\Sigma$ is a tuple $(Q, \delta, q_0, F)$, where $Q$ is a finite set of states, $q_0 \in Q$ is the initial state, $F \subseteq Q$ is the set of final states, and $\delta \subseteq Q \times \Sigma \times Q$ is the transition relation. An NFA $\cA$ is deterministic if for each $(q, \sigma) \in Q \times \Sigma$, there is at most one $q' \in Q$ such that $(q, a, q') \in \delta$. An NFA $\cA$ is complete if for each $(q, \sigma) \in Q \times \Sigma$, there is at least one $q' \in Q$ such that $(q, a, q') \in \delta$. We assume that all NFA considered in this paper are complete. For a string $w = \sigma_1 \dots \sigma_n$, a run of $\cA$ on $w$ is a sequence $q_0 \dots q_n$ such that for each $i \in [n]$, $(q_{i-1}, \sigma_i, q_i) \in \delta$. A run $q_0 \dots q_n$ is accepting if $q_n \in F$. A string $w$ is accepted by $\cA$ if there is an accepting run of $\cA$ on $w$. An NFA $\cA$ is \emph{unambiguous} if for each word $w$, there is \emph{at most one accepting} run of $\cA$ on $w$.
We also use the notation $q_1 \xrightarrow[\cA]{w} q_{n+1}$ to denote the fact that there are $q_2,\dots, q_n \in Q$ such that for each $i \in [n]$, $(q_i, \sigma_i, q_{i+1}) \in \delta$.  


\section{Semantics of the function $\replaceall$}

The semantics of $\replaceall(x, u, y)$ is defined inductively as follows: let $u = u_1 \dots u_k$ (where $k \ge 1$),
\begin{itemize}
	\item if $x \not \in \Sigma^\ast u \Sigma^\ast$, then $\replaceall(x, u, y) = x$, 
	%
	\item otherwise, let $x = x' u z$ such that $x' u_1 \dots u_{k-1} \not \in \Sigma^\ast u \Sigma^\ast$, then $\replaceall(x, u, y) = x' v \cdot \replaceall(z, u, y)$.
\end{itemize}
For instance, $\replaceall(aaaaa, aaa, y) = yaa$, and $\replaceall("Jeve", e, a) = Java$.

\tl{Anthony mentioned that there might be alternatives, for instance,  $\replaceall$ can be made nondeterministic ($\replaceall(aaaaa, aaa, y) = \{yaa, aya, aay\}$). This MIGHT be considered as well.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
	\smallskip
	
	\noindent The semantics of $split(x, u)$ is defined inductively as follows:
	\begin{itemize}
		\item if $x \not \in \Sigma^\ast u \Sigma^\ast$, then $split(x,u) = x$, 
		%
		\item otherwise, let $x = y u z$ such that $y \not \in \Sigma^\ast u \Sigma^\ast$, then $split(x, u) = concat([y], split(z, u))$, where $[y]$ is the array comprising one element $y$ and $concat$ operation concatenates two arrays into one.  
	\end{itemize} 
	
	For instance, $split("Java", a) = [``J", ``v", ``"]$.
	
	\smallskip
	
	\noindent The semantics of $join(X)$ is defined inductively as follows: 
	\begin{itemize}
		\item if $X$ is the empty array, then $join(X) = ``''$,  
		\item otherwise, let $X= concat([x], Y)$, then $join(X) = x\ \cdot\ ``," \ \cdot\ join(Y)$.
	\end{itemize}
	For instance, $join([``Tom", ``John", ``Henry"]) =``Tom,John,Henry"$.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Straight-line string constraint with $\replaceall$  function}


\begin{definition}[Relational and regular constraints with $\replaceall$ function]
	Relational constraints and regular constraints are defined by the following rules,
	\[
	\begin{array}{r c l cr}
	s &\eqdef & x \mid u & \ \ & \mbox{(string terms)}\\
	%t &\eqdef & s \mid e & \ \ & \mbox{(terms)}\\
	\varphi &\eqdef & y = s_1 \concat \dots \concat s_n (n \in \Nat) \mid  x = \replaceall(y, u, s) \mid \varphi \wedge \varphi & \ \ & \mbox{(relational constraints)}\\
	\psi & \eqdef & x \in e \mid \psi \wedge \psi \mid \psi \vee \psi \mid \neg \psi   & \ \ & \mbox{(regular constraints)} \\
	\end{array}
	\]
	where $u \in \Sigma^\ast$ and $e$ is a regular expression. 
	%A regular constraint $\psi$ is a UBR constraint if for each atom $x \in e$ occurring in $\psi$, $e$ is in UBR.
\end{definition}
For a formula $\varphi$, let $\vars(\varphi)$ denote the set of variables occurring in $\varphi$. Similarly for $\vars(\psi)$.

\tl{can the regular constraints be simplified to just a conjunction of $x\in e$?}

Given a relational constraint $\varphi$, a variable $x$ (of type $\str$) is called a \emph{source variable} of $\varphi$ if $\varphi$ \emph{does not} contain a conjunct of the form $x = s_1 \concat \dots \concat s_n$ or $x = \replaceall(\dots)$.

\tl{note that here the pattern $u$ is a constant, but we may also introduce a variable here, though its decidability is not clear.} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
	\begin{definition}[Dependency graph]
		Let $\varphi$ be a relational constraint with $\replaceall$ function. Then the dependency graph of $\varphi$, denoted by $\cG_\varphi = (\vars(\varphi), E_\varphi)$, where $E_\varphi$ comprises the following edges,
		\begin{itemize}
			\item for each atomic formula $y= s_1 \concat \dots \concat s_n$ and each $i \in [n]$ such that $s_i$ is a variable, $(s_i, y) \in E_\varphi$,
			\item for each atomic formula $x = \replaceall(y, u, s)$, $(y, x) \in E_\varphi$, in addition, if $s$ is a variable, then $(s, x) \in E_\varphi$, $(s, y) \in E_\varphi$, 
		\end{itemize}
	\end{definition}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Straight-line relational constraints with $\replaceall$ function]
	A relational constraint $ \varphi$ with $\replaceall$ function is straight-line, if $\varphi \eqdef \bigwedge \limits_{1 \le i \le m} x_i = P_i$ such that
	\begin{itemize}
		\item $x_1,\dots, x_m$ are mutually distinct,
		\item for each $i \in [m]$, all the variables in $P_i$ are either source variables, or variables from $\{x_1,\dots, x_{i-1}\}$,
	\end{itemize}
\end{definition}
Intuitively, in a straight-line relational constraint, the dependency graph of the string variables is acyclic.


\begin{definition}[Straight-line string constraints with $\replaceall$ function]
	A straight-line string constraint $C$ with $\replaceall$ function (denoted by $\strline[\replaceall]$)  is defined as $ \varphi \wedge \psi$,  where 
	\begin{itemize}
		\item $\varphi$ is a straight-line relational constraint,  and
		%
		\item $\psi$ is a regular constraint.
		%
	\end{itemize}
	%Let us use $\Cc$ to denote the set of straight-line string constraints with $\replaceall$ function.
	An $\strline[\replaceall]$ constraint $\varphi \wedge \psi$ is called \emph{pure} if the concatenation symbol $\concat$ does not occur in $\varphi$. Let us use $\pstrline[\replaceall]$ to denote the set of pure $\strline[\replaceall]$ constraints.
\end{definition}
%An SL[$replace$] constraint $\Cc=\varphi \wedge \psi$ is \emph{recursion-free} if $\varphi$ is.


\noindent {\bf Satisfiability problem}: Given an $\strline[\replaceall]$ constraint $C$, decide whether $C$ is satisfiable.

The questions we plan to consider is summarized in the following table. Note that for $x=\replaceall (y,u,z)$, $y$ is referred to as a \emph{pattern} and $z$ is referred to as a \emph{replacement}.

\[
\begin{tabular}{c|c|c|c}
pattern (y)  &   replacement (z)        &   pure (without concatenation) &  full (with concatenation) \\
\hline
constant  &   constant                       & \cite{LB16}    &  \cite{LB16}   \\
\hline
constant  &   variable                       &  Section \ref{sec:replaceallpure}       &    \\
\hline
variable  &   constant                       &         &    \\
\hline
variable  &   variable                       &        &    \\
\end{tabular}
\]


\section{A decision procedure for $\pstrline[\replaceall]$} \label{sec:replaceallpure}



\subsection{The single-letter case}

We start with the single-letter special case, that is, given an $\pstrline[\replaceall]$ formula $C$, it holds that every term of the form $\replaceall(z, u, z')$ in $C$ satisfies that $u$ is a single letter.

We first introduce a concept of dependency graphs.

\begin{definition}[Dependency graph]
	Let $C= \varphi \wedge \psi$ be an $\pstrline[\replaceall]$ formula such that $\vars(\varphi) = \{x_1,\dots, x_m, y_1, \dots, y_n\}$, where $y_1,\dots, y_n$ are the source variables. Define the \emph{dependency graph} of $C$ as $G_C= (\vars(\varphi), E_C)$, such that for each $i \in [m]$, if $x_i = \replaceall(z, a_i, z')$, then $(x_i, (\rpleft, a_i), z) \in E_C$ and $(x_i, (\rpright, a_i), z') \in E_C$. A final (resp. initial) vertex in $G_C$ is a vertex in $G_C$ without successors (resp. predecessors). The edges labeled by $(\rpleft,a_i)$ and $(\rpright, a_i)$ are called the $\rpleft$-edges and $\rpright$-edges respectively. 
	%The $\rpleft$-length of a path $\pi$, denoted by $\rpleftlen(\pi)$, is the number of $\rpleft$-edges on $\pi$. A path of $G_C$ is a sequence $z_1 \ell_1 z_2 \dots \ell_{k-1} z_k$ such that for each $i \in [k-1]$, $(z_i, \ell_i, z_{i+1}) \in E_C$. A path is initial (resp. final) if the path starts from an initial vertex (resp. stops at a final vertex).
	% e the $\src$-nesting-depth of $z$ in $G_C$, denoted by $\srcnd_{G_C}(z)$,  as the maximum number of $\src$-edges in paths from source variables to $z$.
\end{definition}
Note that $G_C$ is a DAG where the out-degree of each vertex is two or zero. 


For each tuple of strings $\vec{v}=(v_1,\dots, v_n)$, if for each $j \in [n]$, $y_j$ is assigned with the string $v_j$, then for each vertex $z$ in $G_C$, the value of $z$, denoted by $\val_{\vec{v}}(z)$, is determined by the values of those source variables $y_j$ that are reachable from $z$, and can be computed in a bottom-up way. 

\smallskip


We will use the following running example to illustrate the decision procedure.
%\begin{example}
Consider the $\pstrline[\replaceall]$ formula $C=\varphi \wedge \psi$, whose dependency graph of $\varphi$ is illustrated in Fig.~\ref{fig-one-letter} and the regular constraint $\psi = \bigwedge \limits_{i \in [4]} x_i \in e_i \wedge \bigwedge \limits_{j \in [5]} y_j \in e'_j$. For $i \in [4]$ and $j \in [5]$, let us use $\cA_{x_i}$ and $\cA_{y_j}$ to denote the DFA corresponding to $e_i$ and $e'_j$ respectively.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[scale=0.9]{single-letter-example.pdf}
	\end{center}
	\caption{The running example for the single-letter case}\label{fig-one-letter}
\end{figure}
%\end{example}
%



We will construct an NFA $\cA_C$ and reduce the satisfiability of $C=\varphi \wedge \psi$ to the nonemptiness of $\cA_C$. The inputs of $\cA_C$ are of the form $\triangleright \# v_1 \# \dots \# v_5\triangleleft$, where $v_1,\dots, v_5$ represent an assignment of the variables $y_1,\dots, y_5$. Intuitively, 
\begin{itemize}
	\item 
	$\cA_C$ checks whether for each $j \in [5]$, $v_j$ is accepted by $\cA_{y_j}$, 
	\item 
	in addition, let $\vec{v} = (v_1,\dots, v_5)$, then $\cA_C$ reads $\triangleright \# v_1 \# \dots \# v_5\triangleleft$, from left to right, and checks whether $\val_{\vec{v}}(x_i)$ is accepted by $\cA_{x_i}$, for each $i \in [4]$.
\end{itemize}

In the following, we will use the running example to give a more specific description of $\cA_C$. Let us introduce some additional notations.

\begin{definition}[$\cA$-context $\ctxt$ and $\red_\ctxt$]
	Suppose $\cA=(Q, \delta, q_0, F)$ is a DFA. Then an $\cA$-\emph{context} $\ctxt$  is a sequence $(a_1,f_1) \dots  (a_r, f_r)$ such that for each $i \in [r]$, $a_i \in \Sigma$ and $f_i$ is a function from $Q$ to $Q$. 
	For an $\cA$-context $\ctxt$, define the reduction of $\ctxt$, denoted by $\red_\ctxt$, as follows: $\red_\ctxt = (a_{i_1},f_{i_1})  \dots  (a_{i_s}, f_{i_s})$ such that for each $j \in [s]$, $a_{i_j} \not \in \{a_1,\dots, a_{i_j-1}\}$. 
\end{definition}
Intuitively, a reduction of $\ctxt$ is obtained by keeping the first occurrence of the letters and removing the other copies.

\begin{definition}[$\cB_{\cA, \ctxt}$]
	Suppose $\cA=(Q, \delta, q_0, F)$ is a DFA and $\ctxt$ is an $\cA$-context with $\red_\ctxt= (a_1,f_1) \dots  (a_r, f_r)$. We define a DFA $\cB_{\cA, \ctxt}$ as $(Q, \delta', q_0, F)$, where $\delta'$ comprises 1) all the tuples $(q, a', q') \in \delta$ with $a' \not \in \{a_1,\dots, a_r\}$, and 2) all the tuples $(q, a_i, f_i(q))$ such that $q \in Q$ and $i \in [r]$.
\end{definition}
Intuitively, over an input $w$, the DFA $\cB_{\cA, \ctxt}$ simulates the run of $\cA$ on $w$, with the following adaptation: let $\red_\ctxt= (a_1,f_1) \dots (a_r, f_r)$, then upon reading an occurrence of $a_i$, let $q$ be the current state, then after reading $a_i$, the state is changed to $f_i(q)$.

%\begin{definition}[Representatives of variables]
%For a variable $z \in \vars(\varphi)$,
%we define the representative of $z$, denoted by $\repr(z)$, as follows: If $z = y_j$ for some $j$, then $\repr(z) = y_j$, otherwise, let $\repr(z)$ be the unique source variable $y_j$ such that  there is a path from $x_i$ to $y_j$ where all edges are $\rpleft$-edges (The uniqueness of $y_j$ follows from the straight-line constraint). 
%\end{definition}

\begin{definition}[representative path]
	For a non-source variable $x_i \in \vars(\varphi)$, we define the representative path of $x_i$ as the unique path from $x_i$ to some source variable $y_j$ where all the edges are $\rpleft$-edges.  For a source variable $y_j$, define the representative path of $y_j$ be the empty path.
	%Note that for each non-source variable $x_i$, there is a unique source variable $y_j$ representing $x_i$. Let $\repr(x_i)$ denote this unique source variable $y_j$.
\end{definition}


We are ready to describe more details of the run of $\cA_C$ on $\triangleright \# v_1 \# \dots \# v_5\triangleleft$.

At first, for each path $\pi$ from a non-source variable $x_i$ to a source variable $y_j$,
%such that the label sequence of $\pi$ belongs to $\rpright^\ast \rpleft^\ast$, 
$\cA_C$ guesses a function $f_{\pi}$ on the state space of $\cA_{x_i}$, satisfying the following constraint: for each non-source variable $x_i$, let $\pi$ be the representative path of $x_i$, then $f_{\pi}(q_{0,x_i}) \in F_{x_i}$, where $q_{0, x_i}$ and $F_{x_i}$ are the initial state and the set of final states of $\cA_{x_i}$ respectively. 
% 
%Notice that for a given pair of variables $(x_i, y_j)$, let $N$ be the maximum length (number of edges) of the paths from $x_i$ to $y_j$, then there are at most $N+1$ distinct paths from $x_i$ to $y_j$ whose label sequences belong to $\rpright^\ast \rpleft^\ast$. Therefore, \emph{only polynomially many functions are guessed}.
%
%
Since $G_C$ is a tree, for simplicity, given a pair of distinct variables $z,z'$ such that $z'$ is reachable from $z$, we will use $\pi_{z,z'}$ to denote the unique path from $z$ to $z'$.  Let $\gfun$ denote the set of guessed functions.


Then $\cA_C$ verifies that the guessed functions satisfy some desired properties, when reading $\triangleright \# v_1 \# \dots \# v_5\triangleleft$.


For a path $\pi$, we define the context of $\pi$, denoted by $\ctxt_\pi$, inductively as follows: 
\begin{itemize}
	\item if $\pi$ is an empty path, then $\ctxt_\pi$ is the empty vector,
	% 
	\item otherwise, let the last edge of $\pi$ be from $z$ to $z'$ and $\pi'$ be the path obtained from $\pi$ by removing the last edge, then 
	\begin{itemize}
		\item if the last edge of $\pi$ is labeled by $(\rpright, a)$, then $\ctxt_\pi = \ctxt_{\pi'}$, 
		%
		\item if the last edge of $\pi$ is labeled by $(\rpleft, a)$,  let $z''$ be the destination vertex of the $\rpright$-edge out of $z$ and $\pi''$ denote the path obtained by concatenating $\pi'$, the $\rpright$-edge from $z$ to $z''$, and the representative path pf $z''$, then $\ctxt_\pi = (a, f_{\pi''}) \ctxt_{\pi'}$. 
		%
	\end{itemize}
\end{itemize}

For instance,  
$$
\begin{array}{l c l}
\ctxt_{\pi_{x_1, y_1}} &= & (a_3, f_{\pi_{x_1, y_2}}) \ctxt_{\pi_{x_1,x_3}} = (a_3, f_{\pi_{x_1, y_2}}) (a_2, f_{\pi_{x_1, y_3}}) \ctxt_{\pi_{x_1, x_2}}  \\
& = & (a_3, f_{\pi_{x_1, y_2}}) (a_2, f_{\pi_{x_1, y_3}}) (a_1, f_{\pi_{x_1, y_4}}).
\end{array}
$$

When reading $v_1$, $\cA_C$ does the following,
\begin{itemize}
	\item $\cA_C$ runs $\cA_{y_1}$ on $v_1$ to check that $v_1$ is accepted by $\cA_{y_1}$,
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_3}, \ctxt_{\pi_{x_3,y_1}}}$ on $v_1$ to compute a function $f'_{\pi_{x_3,y_1}}$ on the state space of $\cA_{x_3}$ and checks $f'_{\pi_{x_3, y_1}} = f_{\pi_{x_3, y_1}}$,
	%
	\item  $\cA_C$ runs $\cB_{\cA_{x_2}, \ctxt_{\pi_{x_2,y_1}}}$ on $v_1$ to compute a function $f'_{\pi_{x_2,y_1}}$ on the state space of $\cA_{x_2}$ and checks $f'_{\pi_{x_2, y_1}} = f_{\pi_{x_2, y_1}}$, 
	
	% if $a_2 = a_3$, then $\cA_C$ runs $\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}$ on $v_1$ to compute a function $f'_{x_2,y_1}$  on the state space of $\cA_{x_2}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$, otherwise, $\cA_C$ runs $\cB_{\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}, a_2, f_{x_2, y_3}}$ on $v_1$ to compute $f'_{x_2,y_1}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$,
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_1}}}$ on $v_1$ to compute a function $f'_{\pi_{x_1,y_1}}$  on the state space of $\cA_{x_1}$ and checks $f'_{\pi_{x_1, y_1}} = f_{\pi_{x_1, y_1}}$.
\end{itemize}
We can also think the run of $\cA_C$ on $v_1$ as the run of $\cB_{y_1, \gfun}$ on $v_1$, where  $\cB_{y_1, \gfun}$ is the product automaton of $\cA_{y_1}$, $\cB_{\cA_{x_3}, \ctxt_{\pi_{x_3,y_1}}}$, $\cB_{\cA_{x_2}, \ctxt_{\pi_{x_2,y_1}}}$, and $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_1}}}$. 

When reading $v_2$, $\cA_C$ does the following,
\begin{itemize}
	\item $\cA_C$ runs $\cA_{y_2}$ on $v_2$ to check that $v_2$ is accepted by $\cA_{y_2}$,
	%
	\item $\cA_C$ runs $ \cA_{x_3}$ on $v_2$ to compute a function $f'_{\pi_{x_3,y_2}}$ on the state space of $\cA_{x_3}$ and checks $f'_{\pi_{x_3,y_2}} = f_{\pi_{x_3, y_2}}$,
	%
	\item  $\cA_C$ runs $\cB_{\cA_{x_2}, \ctxt_{\pi_{x_2,y_2}}}$ on $v_2$ to compute a function $f'_{\pi_{x_2,y_2}}$ on the state space of $\cA_{x_2}$ and checks $f'_{\pi_{x_2,y_2}} = f_{\pi_{x_2, y_2}}$, 
	
	% if $a_2 = a_3$, then $\cA_C$ runs $\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}$ on $v_1$ to compute a function $f'_{x_2,y_1}$  on the state space of $\cA_{x_2}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$, otherwise, $\cA_C$ runs $\cB_{\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}, a_2, f_{x_2, y_3}}$ on $v_1$ to compute $f'_{x_2,y_1}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$,
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_2}}}$ on $v_2$ to compute a function $f'_{\pi_{x_1,y_2}}$  on the state space of $\cA_{x_1}$ and checks $f'_{\pi_{x_1, y_2}} = f_{\pi_{x_1, y_2}}$.
\end{itemize}
We can also think the run of $\cA_C$ on $v_2$ as the run of $\cB_{y_2, \gfun}$ on $v_2$, where  $\cB_{y_2, \gfun}$ is the product automaton of $\cA_{y_2}$, $ \cA_{x_3}$, $\cB_{\cA_{x_2}, \ctxt_{\pi_{x_2,y_2}}}$, and $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_2}}}$. 


When reading $v_3$, $\cA_C$ does the following,
\begin{itemize}
	\item $\cA_C$ runs $\cA_{y_3}$ on $v_3$ to check that $v_3$ is accepted by $\cA_{y_3}$,
	%
	\item  $\cA_C$ runs $\cA_{x_2}$ on $v_3$ to compute a function $f'_{\pi_{x_2,y_3}}$ on the state space of $\cA_{x_2}$ and checks $f'_{\pi_{x_2,y_3}} = f_{\pi_{x_2, y_3}}$, 
	
	% if $a_2 = a_3$, then $\cA_C$ runs $\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}$ on $v_1$ to compute a function $f'_{x_2,y_1}$  on the state space of $\cA_{x_2}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$, otherwise, $\cA_C$ runs $\cB_{\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}, a_2, f_{x_2, y_3}}$ on $v_1$ to compute $f'_{x_2,y_1}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$,
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_3}}}$ on $v_3$ to compute a function $f'_{\pi_{x_1,y_3}}$  on the state space of $\cA_{x_1}$ and checks $f'_{\pi_{x_1, y_3}} = f_{\pi_{x_1, y_3}}$.
\end{itemize}
We can also think the run of $\cA_C$ on $v_3$ as the run of $\cB_{y_3, \gfun}$ on $v_3$, where  $\cB_{y_3, \gfun}$ is the product automaton of $\cA_{y_3}$, $ \cA_{x_2}$, and $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_3}}}$. 


When reading $v_4$, $\cA_C$ does the following,
\begin{itemize}
	\item $\cA_C$ runs $\cA_{y_4}$ on $v_4$ to check that $v_4$ is accepted by $\cA_{y_4}$,
	%
	\item  $\cA_C$ runs $\cB_{\cA_{x_4}, \ctxt_{\pi_{x_4, y_4}}}$ on $v_4$ to compute a function $f'_{\pi_{x_4,y_4}}$ on the state space of $\cA_{x_4}$ and checks $f'_{\pi_{x_4,y_4}} = f_{\pi_{x_4, y_4}}$, 
	
	% if $a_2 = a_3$, then $\cA_C$ runs $\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}$ on $v_1$ to compute a function $f'_{x_2,y_1}$  on the state space of $\cA_{x_2}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$, otherwise, $\cA_C$ runs $\cB_{\cB_{\cA_{x_2}, a_3, f_{x_2, y_2}}, a_2, f_{x_2, y_3}}$ on $v_1$ to compute $f'_{x_2,y_1}$ and checks $f'_{x_2, y_1} = f_{x_2, y_1}$,
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_4}}}$ on $v_4$ to compute a function $f'_{\pi_{x_1,y_4}}$  on the state space of $\cA_{x_1}$ and checks $f'_{\pi_{x_1, y_4}} = f_{\pi_{x_1, y_4}}$.
\end{itemize}
We can also think the run of $\cA_C$ on $v_4$ as the run of $\cB_{y_4, \gfun}$ on $v_3$, where  $\cB_{y_4, \gfun}$ is the product automaton of $\cA_{y_4}$, $\cB_{\cA_{x_4}, \ctxt_{\pi_{x_4, y_4}}}$, and $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_4}}}$. 


When reading $v_5$, $\cA_C$ does the following,
\begin{itemize}
	\item $\cA_C$ runs $\cA_{y_5}$ on $v_5$ to check that $v_5$ is accepted by $\cA_{y_5}$,
	%
	\item  $\cA_C$ runs $\cA_{x_4}$ on $v_5$ to compute a function $f'_{\pi_{x_4,y_5}}$ on the state space of $\cA_{x_4}$ and checks $f'_{\pi_{x_4,y_5}} = f_{\pi_{x_4, y_5}}$, 
	%
	\item $\cA_C$ runs $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_5}}}$ on $v_5$ to compute a function $f'_{\pi_{x_1,y_5}}$  on the state space of $\cA_{x_1}$ and checks $f'_{\pi_{x_1, y_5}} = f_{\pi_{x_1, y_5}}$.
\end{itemize}
We can also think the run of $\cA_C$ on $v_5$ as the run of $\cB_{y_5, \gfun}$ on $v_3$, where  $\cB_{y_5, \gfun}$ is the product automaton of $\cA_{y_5}$, $\cA_{x_4}$, and $\cB_{\cA_{x_1}, \ctxt_{\pi_{x_1,y_5}}}$. 

The nonemptiness of $\cA_C$ can be solved in exponential space as follows: 
\begin{description}
	\item [Step I.] For each path $\pi$ from a non-source variable $x_i$ to a source variable $y_j$, $\cA_C$ guesses a function $f_{\pi}$ on the state space of $\cA_{x_i}$.
	%
	\item  [Step II.] For each source variable $y_j$, guess an accepting run of $\cB_{y_j,\gfun}$.
\end{description}
Since at most exponentially many functions should be guessed, and each guessed function occupies polynomial space, it follows that the above procedure occupies only exponential space. If $G_C$ is a tree, then only polynomially many functions should be guessed and the above procedure occupies only polynomial space.

%\begin{theorem}
%The satisfiability of $\pstrline[\replaceall]$ is in EXPSPACE and PSPACE-complete for formulae whose dependency graphs trees.
%\end{theorem}

\subsection{The general case}

For the general case, we utilise the parsing-automata $\cA_u$ defined below.

Let $u \in \Sigma^+$ and $k=|u| \ge 2$.
Our goal is to construct an NFA $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which parses a string $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
In order to check that a substring of $v$ is \emph{not} in $\Sigma^\ast u \Sigma^\ast$, we introduce a concept of $k$-window profiles w.r.t. $u$.


%If $u = \sigma$ for $\sigma \in \Sigma$, then $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$, where $Q_u = \{(q_0, \bot), (q_0, \top) \}$, $\delta_u = \{(q_0, \bot) \xrightarrow{\sigma} (q_0, \top), (q_0, \bot) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot), (q_0, \top) \xrightarrow{ \sigma} (q_0, \top), (q_0, \top) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot)\}$, $q_{0,u} = (q_0, \bot)$, and $F_u = Q_u$.

%In the following, we assume that $|u| = k \ge 2$. Let $u = u_1 \dots u_k$, where each $u_i \in \Sigma$.

%We construct an NFA $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which over a string $v$, parses $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u_1 \dots u_{k-1} \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, and $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
%Let $u = u_1\dots u_k$ such that $u_i \in \Sigma$ for each $i \in [k]$.  

A $k$-\emph{window profile $\vec{W}$ w.r.t. $u$} is an element of $\{\bot,\top\}^{k-1}$. Intuitively, in the position $i$ of a string $v$, $\vec{W}$ is an abstraction of the substring $v[i-k+2] \dots v[i]$ such that for each $j \in [k-1]$, $\vec{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Let $\wprof_{u, k}$ denote the set of $k$-window profiles w.r.t. $u$. In particular, if $k = 1$, then $\wprof_{u, k} = \emptyset$. 

\zhilin{the following fact is noticed by Yan Chen.} 
Note that the number of $k$-window profiles w.r.t. $u$ is polynomial in the length of $u$. The arguments for this fact proceed as follows: For each profile $\vec{W}$, let $v$ be a string and $i$ be a position of $v$ such that for each $j \in [k-1]$, $\vec{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Define ${\sf idx}_{\vec{W}}$ as the maximum index $j \in [k-1]$ such that $\vec{W}(j)=\top$. Then 
\begin{itemize}
	\item for each $j': j < j' < k$, $\vec{W}(j')=\bot$, 
	\item in addition, since $v[i-{\sf idx}_{\vec{W}}+1] \dots v[i] = u[1] \dots u[{\sf idx}_{\vec{W}}]$, the values of $\vec{W}(1),\dots, \vec{W}({\sf idx}_{\vec{W}})$ are completely determined by $u[1] \dots u[{\sf idx}_{\vec{W}}]$.
\end{itemize}
From the above arguments, we can  conclude that the number of $k$-window profile $\vec{W}$ w.r.t. $u$ is actually at most $k$.

\smallskip

The NFA $\cA_u$ is constructed as follows.
\begin{itemize}
	\item  $Q_u =\{q_0\} \cup \{(\search, \vec{W}) \mid \vec{W} \in \wprof_{u, k}\} \cup \{(\verify, j, \vec{W}) \mid j \in [k-1], \vec{W} \in \wprof_{u,k}\}$, where $q_0$ is a distinguished state whose purpose will become clear later on,  $\search$ and $\verify$ are used to denote whether $\cA_u$ is in the ``search''-mode to search the next occurrence of $u$, or in the ``verify'' mode to verify that the current position is a part of an occurrence of $u$.
	%
	\item $q_{0,u}=q_0$.
	
	\item $\delta_{u}$ comprises the following transitions,
	%guesses over each position, one of the following holds, the substring comprising the next $k$-symbols (including the current one) is $u$ or not.
	\begin{itemize}
		\item $q_0 \xrightarrow{\sigma} (\search, \vec{W})$, where $\vec{W}(1)=\top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\vec{W}(i) = \bot$,
		%
		\item for each state $(\search, \vec{W})$ and $\sigma \in \Sigma$ such that $\vec{W}(k-1) = \bot$ or $\sigma \neq u[k]$,
		\begin{itemize}
			\item $(\search, \vec{W}) \xrightarrow{\sigma} (\search, \vec{W}')$, where $\vec{W}'(1) = \top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\vec{W}'(i) =\top$ iff $\vec{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
			\item if $\sigma = u[1]$, then $(\search, \vec{W}) \xrightarrow{\sigma} (\verify, 1, \vec{W}')$,  where $\vec{W}'(1)=\top$,  and for each $i: 2 \le i \le k-1$, $\vec{W}'(i) =\top$ iff $\vec{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
		\end{itemize}
		%
		\item for each state $(\verify, i-1, \vec{W})$ such that
		\begin{itemize}
			\item $2 \le i \le k-1$,
			\item $\vec{W}(i-1)=\top$, $\sigma = u[i]$, and
			\item either $\vec{W}(k-1)=\bot$ or $\sigma \neq u[k]$, 
		\end{itemize}
		we have $(\verify, i-1, \vec{W}) \xrightarrow{\sigma} (\verify, i, \vec{W}')$, where for each $j: 2 \le j \le k-1$, $\vec{W}'(j) = \top$ iff $\vec{W}(j-1)=\top$ and $\sigma = u[j]$, 
		%
		\item for each state $(\verify, k-1, \vec{W})$ such that $\vec{W}(k-1)=\top$, we have $(\verify, k-1, \vec{W}) \xrightarrow{u[k]} q_0$.
		%where $\bot^k$ in $(\search, \bot^k)$ is used to \emph{reinitialise} the $k$-window profile w.r.t. $u$.
		%
	\end{itemize}
	Note that the constraint $\vec{W}(k-1) = \bot$ or $\sigma \neq u[k]$ is used to guarantee that when parsing a string $v$ into $v_1 u v_2 u \dots v_{l} u v_{l+1}$, $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $j \in [l]$, in addition, $v_{l+1} \not \in  \Sigma^\ast u \Sigma^\ast$.
	%
	\item $F_u=\{q_0\} \cup \{(\search, \vec{W}) \mid \vec{W} \in \wprof_{u, k} \} $. Note that the states $(\verify, j, \vec{W})$ are not final states, since when in these states, the verification of the next occurrence of $u$ has not yet been complete.
\end{itemize}
In an accepting run $r$ of $\cA_u$ on a string $v = v_1 u v_2 u \dots v_l u v_{l+1}$, the state sequence in the run is of the form 
$$q_0\ r_1\ q_0\ r_2\ q_0\ \dots\ r_l\ q_0\ r_{l+1}$$ 
such that  for each $j \in [l]$, $r_j \in (Q_{\search})^+ Q_{\verify, 1}  \dots  Q_{\verify, k-1}$, and $r_{l+1} \in (Q_{\search})^+$, where $Q_{\search}  = \{(\search, \vec{W}) \in \mid \vec{W} \in \wprof_{u,k}\}$, $Q_{\verify, 1} = \{(\verify, 1, \vec{W}) \mid \vec{W} \in \wprof_{u,k}\}, \dots, Q_{\verify, k-1}=\{(\verify, k-1, \vec{W}) \mid \vec{W} \in \wprof_{u, k}\}$. Intuitively, each occurence of $q_0$, except the first one, witnesses the \emph{first} occurrence of $u$ after its previous occurrence or starting from the beginning.

The NFA $\cA_u$ constructed above is \emph{unambiguous} in the sense that for each string $v \in \Sigma^+$, there is \emph{exactly one accepting run} of $\cA_u$ on $v$.

\begin{example}
	An example for $\cA_u$.
\end{example}

%Similarly to the single-letter case, we can define the dependency graph $G_C$. In addition, we can adapt $\dfs(z, z', a, f)$ into a procedure $\dfs(z, z', u, f)$, which integrates the automata $\cA_{u'}$ into the computation of the functions $f_{z', \cA_z}$, where $u,u'$ are constant strings occurring in the edge-labels in $G_C$.

\subsection{Extension to the case of regular expressions}

Let us consider the case that the second parameter of the $\replaceall$ function may be a regular expression. 
We will utilise the parsing-automaton $\cB_e$ for regular expressions $e$. 

We will use the leftmost and longest semantics for regular expression matching.

Let $e$ be a regular expression over $\Sigma$ and $\cA_e = (Q_e, \delta_e, q_{0,e}, F_e)$ be the DFA corresponding to $e$. Without loss of generality, we assume that $q_{0, e} \not \in F_e$ and there are no transitions going into $q_{0,e}$.
Our goal is to construct an NFA $\cB_e=(Q'_e, \delta'_e, q'_{0,e}, F'_e)$ which parses a string $v \in \Sigma^\ast e \Sigma^\ast$ into $v_1 u_1 v_2 u_2 \dots v_l u_l v_{l+1}$ such that 
\begin{itemize}
	\item for each $j \in [l]$, $u_j$ is the leftmost and longest matching of $e$ in $(v_1 u_1 \dots v_{j-1} u_{j-1})^{-1} v$,
	%
	%\item $v_j u_j[1] \dots u_j[|u_j|-1] \not \in \Sigma^\ast e \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$,
	\item $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$.
\end{itemize}
%
Intuitively, in order to search for the leftmost and longest matching of $e$, 
\begin{itemize}
	\item $\cB_e$ starts a new thread which runs $\cA_e$ in each position and keeps a vector of states of these threads, 
	%
	\item when a thread enters a final state, a matching of $e$ is found, $\cB_e$ nondeterministically guesses whether this matching is the longest matching, 
	%
	\item if $\cB_e$ makes the ``longest'' guessing, then $\cB_e$ forgets all the other threads, and continues running this thread to make sure that final states are not reached and the guessing is correct,
	%
	\item moreover, in order to keep the length of the vectors of states of threads \emph{bounded}, the following trick is applied: for two threads starting at the position $i$ and $j$ respectively such that $i < j$, if the current states of the two threads are the same, then the thread $j$ is removed.
\end{itemize}
%
Formally, 
\begin{itemize}
	\item the state set $Q'_e$ of $\cB_e$ comprises 
	\begin{itemize}
		\item the tuples $((q_{0,e}), \leftmost, S)$ such that $S \subseteq Q_e$,
		%
		\item $(\rho, \leftmost, S)$ such that  $\rho$ is a vector of \emph{pairwise distinct} states of $\cA_e$, $\rho \neq (q_{i,e})$, and $S \subseteq Q_e \setminus F_e$, 
		%
		% \item the tuples $(q_{0,e}, \longest, S)$ such that  $S \subseteq Q_e$,
		%
		\item the tuples $(q, \longest, S)$ such that $q \in Q_e$ and $S \subseteq Q_e \setminus F_e$;
	\end{itemize}
	%
	\item $q'_{0,e}= ((q_{0,e}), \leftmost, \emptyset)$,
	%
	\item $F'_{e}$ comprises the states of the form $(\rho, \leftmost, S) \in Q'_e$,
	%
	\item $\delta'_e$ comprises the following tuples: 
	\begin{itemize}
		%\item $((q_{0,e}, \leftmost, S), a, ((\delta_e(q_{0,e},a), q_{0,e}), \leftmost, \delta_e(S,a)))$, where $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$,
		%
		\item suppose $\rho = q_1 \dots q_m$,  $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains \emph{no} states from $F_e$, $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, (\red(\delta_e(\rho,a) q_{0,e}), \leftmost, \delta_e(S,a))) \in \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$,   and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, (\delta_e(q_i, a), \longest, \delta_e(S,a))) \in  \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$, $\delta_e(\rho,a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, ((q_{0,e}), \leftmost, \delta_e(S,a) \cup \{\delta_e(q_i, a)\})) \in  \delta'_e,$$ 
		%
		\item suppose $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \longest, S), a, (\delta_e(q,a), \longest, \delta_e(S,a)) \in \delta'_e,$$
		%
		\item suppose $\delta_e(q,a) \in F_e$ and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \longest, S), a, ((q_{0,e}), \leftmost, \delta_e(S,a) \cup \{\delta_e(q,a)\}) \in \delta'_e.$$
	\end{itemize}
\end{itemize}



\section{A decision procedure for $\strline[\replaceall]$}


\bibliographystyle{alpha}
\bibliography{string} 
 
 
 
 
 
 
 
 

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
