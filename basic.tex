%!TEX root = popl2018.tex


\section{Decision procedure for $\strline[\replaceall]$: The single-letter case} \label{sec:replaceallsl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
\subsection{Encode concatenation by replaceall}

We will transform a given constraint $\varphi$ into a constraint $\varphi'$ which is concatenation free. As the first step, we extend the original alphabet with two fresh letters $a,b$. 

For each $x=yz$, we introduce a new variable $x'$ and replace $x=yz$ by two new constraints 
$x'=\replaceall(ab, a, x)$ and $x=\replaceall(x', b, z)$. 

\begin{proposition}
	$\varphi$ and $\varphi'$ are equisatisfiable. 	
\end{proposition}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\subsection{The single-letter case}

In this section, we consider the single-letter special case, that is, given an $\strline[\replaceall]$ formula $C = \varphi \wedge \psi$, it holds that every term of the form $\replaceall(z, e, z')$ in $\varphi$ satisfies that $e=a$ for $a \in \Sigma$.

%We first assume that the regular constraint $\psi = \bigwedge \limits_{x \in \vars(\varphi)} x \in e_x$, that is, there is exactly one atomic regular constraint for each variable.

In the following, we will explain the basic idea of the decision procedure.
  
Let us start with the simple case that $C \equiv x = \replaceall(y, a, z) \wedge \bigwedge \limits_{i \in [k]} x \in e_{i}$.  In addition, for $i \in [k]$, suppose $\cA_i = (Q_i, \delta_i, q_{0, i}, F_i)$ 
%\cA_y = (Q_y, \delta_y, q_{0, y}, F_y), \cA_z = (Q_z, \delta_z, q_{0, z}, F_z)$ 
is the NFA corresponding to $e_i$. 
\begin{enumerate}
\item For each $i \in [k]$, we will guess a set $T_{i, z} \subseteq Q_i \times Q_i$, which intuitively means that in $\cA_i$, for each state pair $(q, q') \in T_z$, starting from $q$, after reading $z$, the state $q' $ can be reached. The functions $(T_{i, z})_{i \in [k]}$ induce regular constraints $\Ll(\cA_i(q,q'))$ on $z$, where $i \in [k]$ and $(q,q') \in T_{i, z}$.

\item For each $i \in [k]$, we construct an NFA $\cB_{\cA_i, a,  T_{i, z}}$, which specifies some additional regular constraint on $y$. Intuitively, a string $v$ is accepted by $\cB_{\cA_i, a,  T_{i, z}}$ iff there is an accepting run of $\cA_i$ on $v$, with the following adaptation: upon reading an occurrence of the letter $a$, let $q$ be the current state, then some state $q' \in T_{i, z}(q)$, instead of some $q'' \in \delta_i(q,a)$, is reached, after reading $a$. The NFA $\cB_{\cA_i, a,  T_{i, z}}$ is constructed from $\cA_i$ with the following two-step procedure: 
\begin{enumerate}
\item Remove all the transitions $(q, a, q')$ in $\cA_i$.
%
\item For each $(q, q') \in T_{i, z}$, add a transition $(q, a, q')$.
\end{enumerate}
\end{enumerate}

\begin{proposition}\label{prop-sat-sl-case}
Let $C \equiv x = \replaceall(y, a, z) \wedge \bigwedge \limits_{i \in [k]} x \in e_{i}$. Then $C$ is satisfiable iff there are sets $T_{i, z} \subseteq Q_i \times Q_i$ such that $\bigcap \limits_{i \in [k]} \bigcap \limits_{(q,q') \in T_{i, z}} \Ll(\cA_{i}(q, q'))$ and $\bigcap \limits_{i \in [k]} \Ll(\cB_{\cA_i, a,  T_{i, z}})$ are nonempty.
\end{proposition}

From Proposition~\ref{prop-sat-sl-case}, we can decide the satisfiability of $C$ in polynomial space as follows: 
\begin{description}
\item[Step I.] Guess $T_{i,z} \subseteq Q_i \times Q_i$. 
%
\item[Step II.] Guess an accepting run of the product automaton of $\cA_{i}(q, q')$ for $i \in [k]$ and $(q,q') \in T_{i, z}$. 
%
\item[Step III.] Guess an accepting run of the product automaton of $\cB_{\cA_i, a,  T_{i, z}}$ for $i \in [k]$.
\end{description}

Let us now consider the general case that $C$ contains multiple occurrences of $\replaceall(\cdots)$ terms.  We will utilise the dependency graph $C$ and do the following in a top-down manner: Let $\cA_1, \dots, \cA_m$ be the collection of regular constraints for $x$ and $x = \replaceall(y, a, z)$ be a conjunct of $\varphi$. Then guess $T_{i, z} \subseteq Q_i \times Q_i$ for $i \in [m]$ and add additional regular constraints to $y$ and $z$ as specified above. 

%For doing this, we need deal with the typical situation that $x = \replaceall(y, a, z)$  and the regular constraints for $x$ are specified by 

%We first introduce a concept of dependency graphs.


\begin{example}
\end{example}


%\begin{theorem}
%The satisfiability of $\pstrline[\replaceall]$ is in EXPSPACE and PSPACE-complete for formulae whose dependency graphs trees.
%\end{theorem}

\section{Decision procedure for $\strline[\replaceall]$: The constant string case}

For the general case, we utilise the parsing-automata $\cA_u$ defined below.

Let $u \in \Sigma^+$ and $k=|u| \ge 2$.
Our goal is to construct an NFA $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which parses a string $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
In order to check that a substring of $v$ is \emph{not} in $\Sigma^\ast u \Sigma^\ast$, we introduce a concept of $k$-window profiles w.r.t. $u$.


%If $u = \sigma$ for $\sigma \in \Sigma$, then $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$, where $Q_u = \{(q_0, \bot), (q_0, \top) \}$, $\delta_u = \{(q_0, \bot) \xrightarrow{\sigma} (q_0, \top), (q_0, \bot) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot), (q_0, \top) \xrightarrow{ \sigma} (q_0, \top), (q_0, \top) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot)\}$, $q_{0,u} = (q_0, \bot)$, and $F_u = Q_u$.

%In the following, we assume that $|u| = k \ge 2$. Let $u = u_1 \dots u_k$, where each $u_i \in \Sigma$.

%We construct an NFA $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which over a string $v$, parses $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u_1 \dots u_{k-1} \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, and $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
%Let $u = u_1\dots u_k$ such that $u_i \in \Sigma$ for each $i \in [k]$.  

A $k$-\emph{window profile $\vec{W}$ w.r.t. $u$} is an element of $\{\bot,\top\}^{k-1}$. Intuitively, in the position $i$ of a string $v$, $\vec{W}$ is an abstraction of the substring $v[i-k+2] \dots v[i]$ such that for each $j \in [k-1]$, $\vec{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Let $\wprof_{u, k}$ denote the set of $k$-window profiles w.r.t. $u$. In particular, if $k = 1$, then $\wprof_{u, k} = \emptyset$. 

\zhilin{the following fact is noticed by Yan Chen.} 
Note that the number of $k$-window profiles w.r.t. $u$ is polynomial in the length of $u$. The arguments for this fact proceed as follows: For each profile $\vec{W}$, let $v$ be a string and $i$ be a position of $v$ such that for each $j \in [k-1]$, $\vec{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Define ${\sf idx}_{\vec{W}}$ as the maximum index $j \in [k-1]$ such that $\vec{W}(j)=\top$. Then 
\begin{itemize}
	\item for each $j': j < j' < k$, $\vec{W}(j')=\bot$, 
	\item in addition, since $v[i-{\sf idx}_{\vec{W}}+1] \dots v[i] = u[1] \dots u[{\sf idx}_{\vec{W}}]$, the values of $\vec{W}(1),\dots, \vec{W}({\sf idx}_{\vec{W}})$ are completely determined by $u[1] \dots u[{\sf idx}_{\vec{W}}]$.
\end{itemize}
From the above arguments, we can  conclude that the number of $k$-window profile $\vec{W}$ w.r.t. $u$ is actually at most $k$.

\smallskip

The NFA $\cA_u$ is constructed as follows.
\begin{itemize}
	\item  $Q_u =\{q_0\} \cup \{(\search, \vec{W}) \mid \vec{W} \in \wprof_{u, k}\} \cup \{(\verify, j, \vec{W}) \mid j \in [k-1], \vec{W} \in \wprof_{u,k}\}$, where $q_0$ is a distinguished state whose purpose will become clear later on,  $\search$ and $\verify$ are used to denote whether $\cA_u$ is in the ``search''-mode to search the next occurrence of $u$, or in the ``verify'' mode to verify that the current position is a part of an occurrence of $u$.
	%
	\item $q_{0,u}=q_0$.
	
	\item $\delta_{u}$ comprises the following transitions,
	%guesses over each position, one of the following holds, the substring comprising the next $k$-symbols (including the current one) is $u$ or not.
	\begin{itemize}
		\item $q_0 \xrightarrow{\sigma} (\search, \vec{W})$, where $\vec{W}(1)=\top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\vec{W}(i) = \bot$,
		%
		\item for each state $(\search, \vec{W})$ and $\sigma \in \Sigma$ such that $\vec{W}(k-1) = \bot$ or $\sigma \neq u[k]$,
		\begin{itemize}
			\item $(\search, \vec{W}) \xrightarrow{\sigma} (\search, \vec{W}')$, where $\vec{W}'(1) = \top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\vec{W}'(i) =\top$ iff $\vec{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
			\item if $\sigma = u[1]$, then $(\search, \vec{W}) \xrightarrow{\sigma} (\verify, 1, \vec{W}')$,  where $\vec{W}'(1)=\top$,  and for each $i: 2 \le i \le k-1$, $\vec{W}'(i) =\top$ iff $\vec{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
		\end{itemize}
		%
		\item for each state $(\verify, i-1, \vec{W})$ such that
		\begin{itemize}
			\item $2 \le i \le k-1$,
			\item $\vec{W}(i-1)=\top$, $\sigma = u[i]$, and
			\item either $\vec{W}(k-1)=\bot$ or $\sigma \neq u[k]$, 
		\end{itemize}
		we have $(\verify, i-1, \vec{W}) \xrightarrow{\sigma} (\verify, i, \vec{W}')$, where for each $j: 2 \le j \le k-1$, $\vec{W}'(j) = \top$ iff $\vec{W}(j-1)=\top$ and $\sigma = u[j]$, 
		%
		\item for each state $(\verify, k-1, \vec{W})$ such that $\vec{W}(k-1)=\top$, we have $(\verify, k-1, \vec{W}) \xrightarrow{u[k]} q_0$.
		%where $\bot^k$ in $(\search, \bot^k)$ is used to \emph{reinitialise} the $k$-window profile w.r.t. $u$.
		%
	\end{itemize}
	Note that the constraint $\vec{W}(k-1) = \bot$ or $\sigma \neq u[k]$ is used to guarantee that when parsing a string $v$ into $v_1 u v_2 u \dots v_{l} u v_{l+1}$, $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $j \in [l]$, in addition, $v_{l+1} \not \in  \Sigma^\ast u \Sigma^\ast$.
	%
	\item $F_u=\{q_0\} \cup \{(\search, \vec{W}) \mid \vec{W} \in \wprof_{u, k} \} $. Note that the states $(\verify, j, \vec{W})$ are not final states, since when in these states, the verification of the next occurrence of $u$ has not yet been complete.
\end{itemize}
In an accepting run $r$ of $\cA_u$ on a string $v = v_1 u v_2 u \dots v_l u v_{l+1}$, the state sequence in the run is of the form 
$$q_0\ r_1\ q_0\ r_2\ q_0\ \dots\ r_l\ q_0\ r_{l+1}$$ 
such that  for each $j \in [l]$, $r_j \in (Q_{\search})^+ Q_{\verify, 1}  \dots  Q_{\verify, k-1}$, and $r_{l+1} \in (Q_{\search})^+$, where $Q_{\search}  = \{(\search, \vec{W}) \in \mid \vec{W} \in \wprof_{u,k}\}$, $Q_{\verify, 1} = \{(\verify, 1, \vec{W}) \mid \vec{W} \in \wprof_{u,k}\}, \dots, Q_{\verify, k-1}=\{(\verify, k-1, \vec{W}) \mid \vec{W} \in \wprof_{u, k}\}$. Intuitively, each occurence of $q_0$, except the first one, witnesses the \emph{first} occurrence of $u$ after its previous occurrence or starting from the beginning.

The NFA $\cA_u$ constructed above is \emph{unambiguous} in the sense that for each string $v \in \Sigma^+$, there is \emph{exactly one accepting run} of $\cA_u$ on $v$.

\begin{example}
	An example for $\cA_u$.
\end{example}

%Similarly to the single-letter case, we can define the dependency graph $G_C$. In addition, we can adapt $\dfs(z, z', a, f)$ into a procedure $\dfs(z, z', u, f)$, which integrates the automata $\cA_{u'}$ into the computation of the functions $f_{z', \cA_z}$, where $u,u'$ are constant strings occurring in the edge-labels in $G_C$.

\section{Decision procedure for $\strline[\replaceall]$: The regular expression case}

Let us consider the case that the second parameter of the $\replaceall$ function may be a regular expression. 
We will utilise the parsing-automaton $\cB_e$ for regular expressions $e$. 

We will use the leftmost and longest semantics for regular expression matching.

Let $e$ be a regular expression over $\Sigma$ and $\cA_e = (Q_e, \delta_e, q_{0,e}, F_e)$ be the DFA corresponding to $e$. Without loss of generality, we assume that $q_{0, e} \not \in F_e$ and there are no transitions going into $q_{0,e}$.
Our goal is to construct an NFA $\cB_e=(Q'_e, \delta'_e, q'_{0,e}, F'_e)$ which parses a string $v \in \Sigma^\ast e \Sigma^\ast$ into $v_1 u_1 v_2 u_2 \dots v_l u_l v_{l+1}$ such that 
\begin{itemize}
	\item for each $j \in [l]$, $u_j$ is the leftmost and longest matching of $e$ in $(v_1 u_1 \dots v_{j-1} u_{j-1})^{-1} v$,
	%
	%\item $v_j u_j[1] \dots u_j[|u_j|-1] \not \in \Sigma^\ast e \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$,
	\item $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$.
\end{itemize}
%
Intuitively, in order to search for the leftmost and longest matching of $e$, 
\begin{itemize}
	\item $\cB_e$ starts a new thread which runs $\cA_e$ in each position and keeps a vector of states of these threads, 
	%
	\item when a thread enters a final state, a matching of $e$ is found, $\cB_e$ nondeterministically guesses whether this matching is the longest matching, 
	%
	\item if $\cB_e$ makes the ``longest'' guessing, then $\cB_e$ forgets all the other threads, and continues running this thread to make sure that final states are not reached and the guessing is correct,
	%
	\item moreover, in order to keep the length of the vectors of states of threads \emph{bounded}, the following trick is applied: for two threads starting at the position $i$ and $j$ respectively such that $i < j$, if the current states of the two threads are the same, then the thread $j$ is removed.
\end{itemize}
%
Formally, 
\begin{itemize}
	\item the state set $Q'_e$ of $\cB_e$ comprises 
	\begin{itemize}
		\item the tuples $((q_{0,e}), \leftmost, S)$ such that $S \subseteq Q_e$,
		%
		\item $(\rho, \leftmost, S)$ such that  $\rho$ is a vector of \emph{pairwise distinct} states of $\cA_e$, $\rho \neq (q_{i,e})$, and $S \subseteq Q_e \setminus F_e$, 
		%
		% \item the tuples $(q_{0,e}, \longest, S)$ such that  $S \subseteq Q_e$,
		%
		\item the tuples $(q, \longest, S)$ such that $q \in Q_e$ and $S \subseteq Q_e \setminus F_e$;
	\end{itemize}
	%
	\item $q'_{0,e}= ((q_{0,e}), \leftmost, \emptyset)$,
	%
	\item $F'_{e}$ comprises the states of the form $(\rho, \leftmost, S) \in Q'_e$,
	%
	\item $\delta'_e$ comprises the following tuples: 
	\begin{itemize}
		%\item $((q_{0,e}, \leftmost, S), a, ((\delta_e(q_{0,e},a), q_{0,e}), \leftmost, \delta_e(S,a)))$, where $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$,
		%
		\item suppose $\rho = q_1 \dots q_m$,  $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains \emph{no} states from $F_e$, $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, (\red(\delta_e(\rho,a) q_{0,e}), \leftmost, \delta_e(S,a))) \in \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$,   and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, (\delta_e(q_i, a), \longest, \delta_e(S,a))) \in  \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$, $\delta_e(\rho,a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \leftmost, S), a, ((q_{0,e}), \leftmost, \delta_e(S,a) \cup \{\delta_e(q_i, a)\})) \in  \delta'_e,$$ 
		%
		\item suppose $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \longest, S), a, (\delta_e(q,a), \longest, \delta_e(S,a)) \in \delta'_e,$$
		%
		\item suppose $\delta_e(q,a) \in F_e$ and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \longest, S), a, ((q_{0,e}), \leftmost, \delta_e(S,a) \cup \{\delta_e(q,a)\}) \in \delta'_e.$$
	\end{itemize}
\end{itemize}



\section{Undecidable extensions: Character and length constraints, Disequalities, IndexOf}



%\subsection{A decision procedure for $\strline[\replaceall]$}


