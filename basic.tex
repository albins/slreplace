%!TEX root = popl2018.tex


\section{Decision procedure for $\strline[\replaceall]$: The single-letter case} \label{sec:replaceallsl}


In the decision procedure, we will utilise a concept of dependency graph defined below.

\begin{definition}[Dependency graph]
	Let $C= \varphi \wedge \psi$ be an $\strline[\replaceall]$ formula such that $\vars(\varphi) = \{x_1,\dots, x_m, y_1, \dots, y_n\}$, where $y_1,\dots, y_n$ are  source variables. Define the \emph{dependency graph} of $C$ as $G_C= (\vars(\varphi), E_C)$, such that for each $i \in [m]$, if $x_i = \replaceall(z, p_i, z')$, then $(x_i, (\rpleft, p_i), z) \in E_C$ and $(x_i, (\rpright, p_i), z') \in E_C$. A final (resp. initial) vertex in $G_C$ is a vertex in $G_C$ without successors (resp. predecessors). The edges labeled by $(\rpleft, e_i)$ and $(\rpright, e_i)$ are called the $\rpleft$-edges and $\rpright$-edges respectively. 
	%The $\rpleft$-length of a path $\pi$, denoted by $\rpleftlen(\pi)$, is the number of $\rpleft$-edges on $\pi$. A path of $G_C$ is a sequence $z_1 \ell_1 z_2 \dots \ell_{k-1} z_k$ such that for each $i \in [k-1]$, $(z_i, \ell_i, z_{i+1}) \in E_C$. A path is initial (resp. final) if the path starts from an initial vertex (resp. stops at a final vertex).
	% e the $\src$-nesting-depth of $z$ in $G_C$, denoted by $\srcnd_{G_C}(z)$,  as the maximum number of $\src$-edges in paths from source variables to $z$.
\end{definition}
Note that $G_C$ is a DAG (directed acyclic graph) where the out-degree of each vertex is two or zero. 


\begin{remark}\label{rem-concat}
The concatenation modality $x = s \concat s$ is redundant in the sense that $x = s_1 \concat s_2$ can be rewritten as $x' = \replaceall(ab, a, s_1), x = \replaceall(x', b, s_2)$, where $a,b$ are two fresh letters.
\end{remark}
\tl{I suggest not put this remark here.}

By Remark~\ref{rem-concat}, without loss of generality, we assume that 
in each $\strline[\replaceall]$ constraint $\varphi \wedge \psi$, the concatenation symbol $\concat$ does not occur in $\varphi$. 
\tl{as mentioned, here I suggest that here we just provide a clean def of language}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
\subsection{Encode concatenation by replaceall}

We will transform a given constraint $\varphi$ into a constraint $\varphi'$ which is concatenation free. As the first step, we extend the original alphabet with two fresh letters $a,b$. 

For each $x=yz$, we introduce a new variable $x'$ and replace $x=yz$ by two new constraints 
$x'=\replaceall(ab, a, x)$ and $x=\replaceall(x', b, z)$. 

\begin{proposition}
	$\varphi$ and $\varphi'$ are equisatisfiable. 	
\end{proposition}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\subsection{The single-letter case}

In this section, we consider the single-letter special case, that is, for the $\strline[\replaceall]$ formula $C = \varphi \wedge \psi$, every term of the form $\replaceall(z, e, z')$ in $\varphi$ satisfies that $e=a$ for $a \in \Sigma$.

%We first assume that the regular constraint $\psi = \bigwedge \limits_{x \in \vars(\varphi)} x \in e_x$, that is, there is exactly one atomic regular constraint for each variable.

We first explain the basic idea of the decision procedure.
  
Let us start with the simple case that $C \equiv x = \replaceall(y, a, z) \wedge \bigwedge \limits_{i \in [k]} x \in e_{i}$.  In addition, for $i \in [k]$, suppose $\cA_i = (Q_i, \delta_i, q_{0, i}, F_i)$ 
%\cA_y = (Q_y, \delta_y, q_{0, y}, F_y), \cA_z = (Q_z, \delta_z, q_{0, z}, F_z)$ 
is the NFA corresponding to $e_i$. 
\begin{enumerate}
\item For each $i \in [k]$, we will guess a set $T_{i, z} \subseteq Q_i \times Q_i$, which intuitively means that in $\cA_i$, for each state pair $(q, q') \in T_{i, z}$, starting from $q$, after reading $z$, the state $q' $ can be reached. The functions \tl{relations?} $(T_{i, z})_{i \in [k]}$ induce regular constraints $\Ll(\cA_i(q,q'))$ on $z$, where $i \in [k]$ and $(q,q') \in T_{i, z}$.

\item For each $i \in [k]$, we construct an NFA $\cB_{\cA_i, a,  T_{i, z}}$, which specifies some additional regular constraint on $y$. Intuitively, a string $v$ is accepted by $\cB_{\cA_i, a,  T_{i, z}}$ iff there is an accepting run of $\cA_i$ on $v$, with the following adaptation: upon reading an occurrence of the letter $a$, let $q$ be the current state, then some state $q' \in T_{i, z}(q)$, instead of some $q'' \in \delta_i(q,a)$, is reached, after reading $a$. The NFA $\cB_{\cA_i, a,  T_{i, z}}$ is constructed from $\cA_i$ with the following two-step procedure: 
\begin{enumerate}
\item Remove all the transitions $(q, a, q')$ in $\cA_i$.
%
\item For each $(q, q') \in T_{i, z}$, add a transition $(q, a, q')$.
\end{enumerate}
\end{enumerate}

\begin{proposition}\label{prop-sat-sl-case}
Let $C \equiv x = \replaceall(y, a, z) \wedge \bigwedge \limits_{i \in [k]} x \in e_{i}$. Then $C$ is satisfiable iff there are sets $T_{i, z} \subseteq Q_i \times Q_i$ such that $\bigcap \limits_{i \in [k]} \bigcap \limits_{(q,q') \in T_{i, z}} \Ll(\cA_{i}(q, q'))$ and $\bigcap \limits_{i \in [k]} \Ll(\cB_{\cA_i, a,  T_{i, z}})$ are nonempty.
\end{proposition}

From Proposition~\ref{prop-sat-sl-case}, we can decide the satisfiability of $C$ in polynomial space as follows: 
\begin{description}
\item[Step I.] Guess $T_{i,z} \subseteq Q_i \times Q_i$. 
%
\item[Step II.] Guess an accepting run of the product automaton of $\cA_{i}(q, q')$ for $i \in [k]$ and $(q,q') \in T_{i, z}$. 
%
\item[Step III.] Guess an accepting run of the product automaton of $\cB_{\cA_i, a,  T_{i, z}}$ for $i \in [k]$.
\end{description}

Let us now consider the general case that $C$ contains multiple occurrences of $\replaceall(\cdots)$ terms.  We will utilise the dependency graph $C$ and remove the edges (the $\rpleft$-edge and $\rpright$ edge) in a top-down manner as follows: 
\begin{quote}
\it Let $x$ be a node in the graph without predecessors and $x = \replaceall(y, a, z)$ be a conjunct of $\varphi$ and $\cA_1, \dots, \cA_m$ be a collection of regular constraints for $x$. Then remove the two edges out of $x$, guess $T_{i, z} \subseteq Q_i \times Q_i$ for $i \in [m]$, and add additional regular constraints to $y$ and $z$ as specified above. 
\end{quote}

%For doing this, we need deal with the typical situation that $x = \replaceall(y, a, z)$  and the regular constraints for $x$ are specified by 

%We first introduce a concept of dependency graphs.


\begin{example}
\end{example}


%\begin{theorem}
%The satisfiability of $\pstrline[\replaceall]$ is in EXPSPACE and PSPACE-complete for formulae whose dependency graphs trees.
%\end{theorem}

\section{Decision procedure for $\strline[\replaceall]$: The constant-string case}

In this section, we consider the constant-string special case, that is, given an $\strline[\replaceall]$ formula $C = \varphi \wedge \psi$, it holds that every term of the form $\replaceall(z, e, z')$ in $\varphi$ satisfies that $e=u$ for $u \in \Sigma^+$.

Let us start with the simple case that $C \equiv x = \replaceall(y, u, z) \wedge \bigwedge \limits_{i \in [k]} x \in e_{i}$ such that $|u| \ge 2$.  In addition, for $i \in [k]$, suppose $\cA_i = (Q_i, \delta_i, q_{0, i}, F_i)$ 
%\cA_y = (Q_y, \delta_y, q_{0, y}, F_y), \cA_z = (Q_z, \delta_z, q_{0, z}, F_z)$ 
is the NFA corresponding to $e_i$. 
\begin{enumerate}
\item For each $i \in [k]$, we will guess a set $T_{i, z} \subseteq Q_i \times Q_i$, which intuitively means that in $\cA_i$, for each state pair $(q, q') \in T_{i, z}$, starting from $q$, after reading $z$, the state $q' $ can be reached. The functions $(T_{i, z})_{i \in [k]}$ induce regular constraints $\Ll(\cA_i(q,q'))$ on $z$, where $i \in [k]$ and $(q,q') \in T_{i, z}$.

\item For each $i \in [k]$, we construct an NFA $\cB_{\cA_i, u,  T_{i, z}}$, which specifies some additional regular constraint on $y$. Intuitively, a string $v$ is accepted by $\cB_{\cA_i, u,  T_{i, z}}$ iff either $v \not \in \Sigma^\ast u \Sigma^\ast$ and $v$ is accepted by $\cA_i$, or otherwise, let $v = v'_1 u v'_2 u \dots v'_{k-1} u v'_{k}$ such that $v'_i u' \not \in \Sigma^\ast u \Sigma^\ast$ for each $i \in [k-1]$ and each strict prefix $u'$ of $u$ and $v'_k \not \in \Sigma^\ast u \Sigma^\ast$, then $q_{i,0} \xrightarrow{v'_1} q_1 \xrightarrow{T_{i,z}} q'_1 \xrightarrow{v'_2} q_2 \xrightarrow{T_{i,z}} q'_2 \dots \xrightarrow{v'_{k-1}} q_{k-1} \xrightarrow{T_{i,z}} q'_{k-1} \xrightarrow{v'_k} q_k$ for states $q_1, q'_1, \dots, q_{k-1}, q'_{k-1}, q_k \in Q_i$ with $q_k \in F_{i,z}$. 
\end{enumerate}

In order to construct the NFA $\cB_{\cA_i, u,  T_{i, z}}$, we introduce concepts of window profiles and parsing automata defined below.

Let $u \in \Sigma^+$ and $k=|u| \ge 2$.


%If $u = \sigma$ for $\sigma \in \Sigma$, then $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$, where $Q_u = \{(q_0, \bot), (q_0, \top) \}$, $\delta_u = \{(q_0, \bot) \xrightarrow{\sigma} (q_0, \top), (q_0, \bot) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot), (q_0, \top) \xrightarrow{ \sigma} (q_0, \top), (q_0, \top) \xrightarrow{\Sigma \setminus \sigma} (q_0, \bot)\}$, $q_{0,u} = (q_0, \bot)$, and $F_u = Q_u$.

%In the following, we assume that $|u| = k \ge 2$. Let $u = u_1 \dots u_k$, where each $u_i \in \Sigma$.

%We construct an NFA $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which over a string $v$, parses $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u_1 \dots u_{k-1} \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, and $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
%Let $u = u_1\dots u_k$ such that $u_i \in \Sigma$ for each $i \in [k]$.  

\begin{definition}[$k$-window profiles w.r.t. $u$]
A $k$-\emph{window profile $\overrightarrow{W}$ w.r.t. $u$} is an element of $\{\bot,\top\}^{k-1}$. Intuitively, in the position $i$ of a string $v$, $\overrightarrow{W}$ is an abstraction of the substring $v[i-k+2] \dots v[i]$ such that for each $j \in [k-1]$, $\overrightarrow{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Let $\wprof_{u, k}$ denote the set of $k$-window profiles w.r.t. $u$. 
%In particular, if $k = 1$, then $\wprof_{u, k} = \emptyset$. 
\end{definition}

%\zhilin{the following fact is noticed by Yan Chen.} 
\begin{proposition}
The number of $k$-window profiles w.r.t. $u$ is polynomial in the length of $u$. 
\end{proposition}
\begin{proof}
The arguments for this fact proceed as follows: For each profile $\overrightarrow{W}$, let $v$ be a string and $i$ be a position of $v$ such that for each $j \in [k-1]$, $\overrightarrow{W}(j) = \top$ iff $v[i-j+1] \dots v[i] = u[1] \dots u[j]$. Define ${\sf idx}_{\overrightarrow{W}}$ as the maximum index $j \in [k-1]$ such that $\overrightarrow{W}(j)=\top$. Then 
\begin{itemize}
	\item for each $j': j < j' < k$, $\overrightarrow{W}(j')=\bot$, 
	\item in addition, since $v[i-{\sf idx}_{\overrightarrow{W}}+1] \dots v[i] = u[1] \dots u[{\sf idx}_{\overrightarrow{W}}]$, the values of $\overrightarrow{W}(1),\dots, \overrightarrow{W}({\sf idx}_{\overrightarrow{W}})$ are completely determined by $u[1] \dots u[{\sf idx}_{\overrightarrow{W}}]$.
\end{itemize}
From the above arguments, we can  conclude that the number of $k$-window profile $\vec{W}$ w.r.t. $u$ is actually at most $k$.
\end{proof}

From $u$, we will construct a parsing automaton $\cA_u=(Q_u, \delta_u, q_{0,u}, F_u)$ which parses a string $v \in \Sigma^\ast u \Sigma^\ast$ into $v_1 u v_2 u \dots v_l u v_{l+1}$ such that $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast u \Sigma^\ast$. 
The concept of $k$-window profiles w.r.t. $u$ are used to check that a substring of $v$ is \emph{not} in $\Sigma^\ast u \Sigma^\ast$.
Specifically, the NFA $\cA_u$ is constructed as follows.
\begin{itemize}
	\item  $Q_u =\{q_0\} \cup \{(\search, \overrightarrow{W}) \mid \overrightarrow{W} \in \wprof_{u, k}\} \cup \{(\verify, j, \overrightarrow{W}) \mid j \in [k-1], \overrightarrow{W} \in \wprof_{u,k}\}$, where $q_0$ is a distinguished state whose purpose will become clear later on,  $\search$ and $\verify$ are used to denote whether $\cA_u$ is in the ``search''-mode to search the next occurrence of $u$, or in the ``verify'' mode to verify that the current position is a part of an occurrence of $u$.
	%
	\item $q_{0,u}=q_0$.
	
	\item $\delta_{u}$ comprises the following transitions,
	%guesses over each position, one of the following holds, the substring comprising the next $k$-symbols (including the current one) is $u$ or not.
	\begin{itemize}
		\item $q_0 \xrightarrow{\sigma} (\search, \overrightarrow{W})$, where $\overrightarrow{W}(1)=\top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\overrightarrow{W}(i) = \bot$,
		%
		\item for each state $(\search, \overrightarrow{W})$ and $\sigma \in \Sigma$ such that $\overrightarrow{W}(k-1) = \bot$ or $\sigma \neq u[k]$,
		\begin{itemize}
			\item $(\search, \overrightarrow{W}) \xrightarrow{\sigma} (\search, \overrightarrow{W}')$, where $\vec{W}'(1) = \top$ iff $\sigma = u[1]$, and for each $i: 2 \le i \le k-1$, $\vec{W}'(i) =\top$ iff $\overrightarrow{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
			\item if $\sigma = u[1]$, then $(\search, \overrightarrow{W}) \xrightarrow{\sigma} (\verify, 1, \overrightarrow{W}')$,  where $\overrightarrow{W}'(1)=\top$,  and for each $i: 2 \le i \le k-1$, $\overrightarrow{W}'(i) =\top$ iff $\overrightarrow{W}({i-1}) = \top$ and $\sigma = u[i]$,
			%
		\end{itemize}
		%
		\item for each state $(\verify, i-1, \overrightarrow{W})$ such that
		\begin{itemize}
			\item $2 \le i \le k-1$,
			\item $\overrightarrow{W}(i-1)=\top$, $\sigma = u[i]$, and
			\item either $\overrightarrow{W}(k-1)=\bot$ or $\sigma \neq u[k]$, 
		\end{itemize}
		we have $(\verify, i-1, \overrightarrow{W}) \xrightarrow{\sigma} (\verify, i, \overrightarrow{W}')$, where for each $j: 2 \le j \le k-1$, $\overrightarrow{W}'(j) = \top$ iff $\overrightarrow{W}(j-1)=\top$ and $\sigma = u[j]$, 
		%
		\item for each state $(\verify, k-1, \overrightarrow{W})$ such that $\overrightarrow{W}(k-1)=\top$, we have $(\verify, k-1, \overrightarrow{W}) \xrightarrow{u[k]} q_0$.
		%where $\bot^k$ in $(\search, \bot^k)$ is used to \emph{reinitialise} the $k$-window profile w.r.t. $u$.
		%
	\end{itemize}
	Note that the constraint $\vec{W}(k-1) = \bot$ or $\sigma \neq u[k]$ is used to guarantee that when parsing a string $v$ into $v_1 u v_2 u \dots v_{l} u v_{l+1}$, $v_j u[1] \dots u[k-1] \not \in \Sigma^\ast u \Sigma^\ast$ for each $j \in [l]$, in addition, $v_{l+1} \not \in  \Sigma^\ast u \Sigma^\ast$.
	%
	\item $F_u=\{q_0\} \cup \{(\search, \overrightarrow{W}) \mid \overrightarrow{W} \in \wprof_{u, k} \} $. Note that the states $(\verify, j, \overrightarrow{W})$ are not final states, since when in these states, the verification of the next occurrence of $u$ has not yet been complete.
\end{itemize}
In an accepting run $r$ of $\cA_u$ on a string $v = v_1 u v_2 u \dots v_l u v_{l+1}$, the state sequence in the run is of the form 
$$q_0\ r_1\ q_0\ r_2\ q_0\ \dots\ r_l\ q_0\ r_{l+1}$$ 
such that  for each $j \in [l]$, $r_j \in (Q_{\search})^+ Q_{\verify, 1}  \dots  Q_{\verify, k-1}$, and $r_{l+1} \in (Q_{\search})^+$, where $Q_{\search}  = \{(\search, \overrightarrow{W}) \in \mid \overrightarrow{W} \in \wprof_{u,k}\}$ and $Q_{\verify, i} = \{(\verify, i, \overrightarrow{W}) \mid \overrightarrow{W} \in \wprof_{u,k}\}$ for $i \in [k-1]$. Intuitively, each occurence of $q_0$, except the first one, witnesses the \emph{first} occurrence of $u$ after its previous occurrence or starting from the beginning.

%The parsing automaton $\cA_u$ constructed above is \emph{unambiguous} in the sense that for each string $v \in \Sigma^+$, there is \emph{exactly one accepting run} of $\cA_u$ on $v$.

\begin{example}
	An example for $\cA_u$.
\end{example}

We are ready to present the construction of $\cB_{\cA_i, u,  T_{i, z}}$. $\cB_{\cA_i, u,  T_{i, z}}$ is constructed by the following two-step procedure.
\begin{enumerate}
\item Construct the product of $\cA_i$ and $\cA_u$. Then remove all the states $(q, (\verify, j, \overrightarrow{W}))$ as well as the transitions associated with them.

\item For each pair $(q,q') \in T_{i,z}$ and each sequence of transitions in $\cA_u$ of the form  
$$
\begin{array}{l}
((\search, \overrightarrow{W}), u[1], (\verify, 1, \overrightarrow{W'_1})), ((\verify, 1, \overrightarrow{W'_1}), u[2], 
 (\verify, 2, \overrightarrow{W'_2})), \\
 \hspace{3cm} \dots, ((\verify, k-1, \overrightarrow{W'_{k-1}}), u[k], q_0),
\end{array}
$$ 
add the transitions 
$$
\begin{array}{l}
((q, (\search, \overrightarrow{W})), u[1], (q, (\verify, 1, \overrightarrow{W'_1}))), ((q, (\verify, 1, \overrightarrow{W'_1})), u[2], (q, (\verify, 2, \overrightarrow{W'_2}))), \dots,  \\
((q, (\verify, k-2, \overrightarrow{W'_{k-2}})), u[k-1], (q, (\verify, k-1, \overrightarrow{W'_{k-1}}))), ((q, (\verify, k-1, \overrightarrow{W'_{k-1}})), u[k], (q', q_0)).
\end{array}
$$
\end{enumerate}

%Similarly to the single-letter case, we can define the dependency graph $G_C$. In addition, we can adapt $\dfs(z, z', a, f)$ into a procedure $\dfs(z, z', u, f)$, which integrates the automata $\cA_{u'}$ into the computation of the functions $f_{z', \cA_z}$, where $u,u'$ are constant strings occurring in the edge-labels in $G_C$.

\section{Decision procedure for $\strline[\replaceall]$: The regular-expression case}

Let us consider the case that the second parameter of the $\replaceall$ function may be a regular expression. 
We will utilise the parsing-automaton $\cB_e$ for regular expressions $e$. 

We will use the leftmost and longest semantics for regular expression matching.

Let $e$ be a regular expression over $\Sigma$ and $\cA_e = (Q_e, \delta_e, q_{0,e}, F_e)$ be the DFA corresponding to $e$ \zhilin{it remains to consider NFA}. Without loss of generality, we assume that $q_{0, e} \not \in F_e$ and there are no transitions going into $q_{0,e}$.
Our goal is to construct an NFA $\cB_e=(Q'_e, \delta'_e, q'_{0,e}, F'_e)$ which parses a string $v \in \Sigma^\ast e \Sigma^\ast$ into $v_1 u_1 v_2 u_2 \dots v_l u_l v_{l+1}$ such that 
\begin{itemize}
	\item for each $j \in [l]$, $u_j$ is the leftmost and longest matching of $e$ in $(v_1 u_1 \dots v_{j-1} u_{j-1})^{-1} v$,
	%
	%\item $v_j u_j[1] \dots u_j[|u_j|-1] \not \in \Sigma^\ast e \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$,
	\item $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$.
\end{itemize}
%
Intuitively, in order to search for the leftmost and longest matching of $e$, 
\begin{itemize}
\item $\cB_e$ has two modes, ``$\searchleft$'' and ``$\searchlong$'', which intuitively means search for the leftmost and longest matching respectively,
 %
	\item when in the ``$\searchleft$'' mode, $\cB_e$ starts a new thread of $\cA_e$ in each position and keeps a vector of states of these threads, in addition, it nondeterministically makes a ``leftmost'' guessing, that is, guesses that the current position is the first position of the leftmost matching, if it makes such a guessing, then it enters the ``$\searchlong$'' mode, it runs the thread started in the current position and search for the longest matching, moreover, it continues running all the threads that were started before to make sure that the final states will not be reached (thus, the guessing is valid),
	%
	\item when in the ``$\searchlong$'' mode, $\cB_e$ runs a thread to search for the longest matching, if the thread enters a final state, then $\cB_e$ nondeterministically makes a ``longest'' guessing, that is, guesses that the current position is the last position of the leftmost and longest matching, if it makes such a guessing, then it resets the states and starts a new round of leftmost and longest matching,
	%
%	\item when a thread $i$ enters a final state, a matching of $e$ is found, $\cB_e$ nondeterministically guesses whether this matching is the leftmost matching or the longest matching, 
	%
%	\item if $\cB_e$ makes a ``leftmost and longest'' guessing, then $\cB_e$ forgets all the other threads that were started later than the thread $i$, and continues running the thread $i$ and all the threads that were started earlier than the thread $i$ to make sure that final states will not be reached and the ``leftmost and longest'' guessing is correct,
%
%	\item if $\cB_e$ makes a ``leftmost and non-longest'' guessing, then $\cB_e$ forgets all the other threads that were started later than the thread $i$, and continues running all the threads that were started earlier than the thread $i$ to make sure that final states will not be reached and the ``leftmost'' guessing is correct, in addition, it continues running the thread $i$ and searching for the longest matching,
%
%	\item if $\cB_e$ makes a ``non-leftmost'' guessing, then $\cB_e$ forgets the thread $i$ and all the other threads that were started later than the thread $i$, and continues running all the threads that were started earlier than the thread $i$ and searching for the leftmost matching,
	%
	\item moreover, in order to keep the length of the vectors of states of threads \emph{bounded}, the following trick is applied: for two threads starting at the position $i$ and $j$ respectively such that $i < j$, if the current states of the two threads are the same, then the thread $j$ is removed.
\end{itemize}
%
Formally, 
\begin{itemize}
	\item the state set $Q'_e$ of $\cB_e$ comprises 
	\begin{itemize}
		\item the tuples $((q_{0,e}), \searchleft, S)$ such that $S \subseteq Q_e$,
		%
		\item $(\rho, \searchleft, S)$ such that  $\rho$ is a nonempty vector of \emph{pairwise distinct} states of $\cA_e$, $\rho \neq (q_{0,e})$, and $S \subseteq Q_e \setminus F_e$, 
		%
		% \item the tuples $(q_{0,e}, \longest, S)$ such that  $S \subseteq Q_e$,
		%
		\item the tuples $(q, \searchlong, S)$ such that $q \in Q_e$ and $S \subseteq Q_e \setminus F_e$;
	\end{itemize}
	%
	\item $q'_{0,e}= ((q_{0,e}), \searchleft, \emptyset)$,
	%
	\item $F'_{e}$ comprises the states of the form $(-, \searchleft, -) \in Q'_e$,
	%
	\item $\delta'_e$ comprises the following tuples: 
	\begin{itemize}
		%\item $((q_{0,e}, \leftmost, S), a, ((\delta_e(q_{0,e},a), q_{0,e}), \leftmost, \delta_e(S,a)))$, where $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$,
		%
		\item suppose $\rho = q_1 \dots q_m$ (where $q_m = q_{0,e}$),  $a \in \Sigma$ and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\red(\delta_e(\rho,a))q_{0,e}, \searchleft, \delta_e(S,a))) \in \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$ (where $q_m = q_{0,e}$),  $a \in \Sigma$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\delta_e(q_m, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m-1]\})) \in \delta'_e,$$ 
		%
		\item suppose $\rho = q_1 \dots q_m$ (where $q_m = q_{0,e}$),  $a \in \Sigma$, $\delta_e(q_m, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\})) \in \delta'_e,$$ 
		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
		\item suppose $\rho = q_1 \dots q_m$,  $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains \emph{no} states from $F_e$, $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\red(\delta_e(\rho,a))q_{0,e}, \searchleft, \delta_e(S,a))) \in \delta'_e,$$ 
		%
		\item {\bf ``leftmost and longest'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$, $\delta_e(\rho,a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid 1\le j \le i\})) \in  \delta'_e,$$ 
		%
%		intuitively, $\cB_e$ makes a ``leftmost and longest'' guessing and continues running all the threads of indices no greater than $i$,
		\item {\bf ``leftmost and non-longest'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$,   and $\delta_e(S,a) \cap F_e = \emptyset$, then 		
		$$((\rho, \searchleft, S), a, (\delta_e(q_i, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid 1 \le j \le i-1\})) \in  \delta'_e,$$ 
		%
		\item {\bf ``non-leftmost'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, $i > 1$,  and $\delta_e(S,a) \cap F_e = \emptyset$, then 		
		$$((\rho, \searchleft, S), a, (\red(\delta_e(q_1,a) \dots \delta_e(q_{i-1},a)), \searchleft, \delta_e(S,a)) \in  \delta'_e,$$ 
%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\item suppose $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \searchlong, S), a, (\delta_e(q,a), \searchlong, \delta_e(S,a)) \in \delta'_e,$$
		%
		\item suppose $\delta_e(q,a) \in F_e$ and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \searchlong, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q,a)\}) \in \delta'_e.$$
	\end{itemize}
\end{itemize}


Similarly to the constant-string case, the main technical difficulty is to construct $\cB_{\cA_i, e,  T_{i, z}}$. The NFA $\cB_{\cA_i, u,  T_{i, z}}$ is constructed by the following two-step procedure.
\begin{enumerate}
\item Construct the product of $\cA_i$ and $\cB_e$. Then remove all the states $(q, (-, \searchlong, -))$ as well as the transitions associated with them, in addition, remove all the transitions entering the states $(q, ((q_{0,e}), \searchleft,-))$.

\item For each pair $(q,q') \in T_{i,z}$, do the following,
\begin{itemize}
\item for each transition
$$((\rho, \searchleft, S), a, (\delta_e(q_m, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m-1]\})) \in \delta'_e,$$
add a transition
$$((q, (\rho, \searchleft, S)), a, (q, (\delta_e(q_m, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m-1]\}))),$$
%
\item for each transition 
$$((q'', \searchlong, S), a, (\delta_e(q'', a), \searchlong, \delta_e(S,a))) \in \delta'_e,$$  
add a transition 
$$((q, (q'', \searchlong, S)), a, (q, (\delta_e(q'', a), \searchlong, \delta_e(S,a)))),$$
%
\item for each transition
$$((q'', \searchlong, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q'',a)\}) \in \delta'_e,$$
add a transition
$$((q, (q'', \searchlong, S)), a, (q', ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q,a)\}))),$$
%
\item for each transition
$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\})) \in \delta'_e,$$
add a transition
$$((q, (\rho, \searchleft, S)), a, ((q', (q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\}))).$$
\end{itemize}
\end{enumerate}


%\subsection{A decision procedure for $\strline[\replaceall]$}


