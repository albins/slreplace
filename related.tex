%!TEX root = popl2018.tex

\section{Related work}\label{sec-rel}

 
In this section, we discuss some related work. We will classify our discussions into two categories: (1) theoretical results; (2) practical approaches used in string solvers.  We shall emphasise work regarding $\replaceall$ functions as these are our main focus. 

\subsection*{Theoretical results}
Our work is closely related to solving word equations, which are a conjunction of equations of $v=w$, where $v, w$ are concatenation of string constants and variables. The computational complexity of this problem remains unknown, with the best lower and upper bounds being NP and PSPACE. Makanin %refuted a conjecture 
showed, perhaps surprisingly, that the problem is decidable \cite{Makanin}, and %Plandowski's  on the decidability and complexity of satisfiability for word equations, i.e., 
Plandowski explored an approach of compression and proposed a PSPACE algorithm \cite{P04}.  This is the best bound up to date, though a simpler PSPACE solution with smaller space consumption based on compression was proposed by Jez \cite{J16}  gives a (nondeterministic) $O(n \log n)$ space complexity. Very recently, in \cite{J17}, Jez shows that word equations are in nondeterministic linear space. 
%The connection between compression and word equations was first observed by Plandowski and Rytter \cite{PR98}. %, who showed that a length-minimal solution of size N has a compressed representation
%of size poly(n, log N). 
Essentially, the constraint language  $\strline[\replaceall]$ studied in this paper is word equations where the $\replaceall$ function, which subsumes the concatenation operation, is used, and the additional straight-line restriction is put.  

It is still a long-standing open problem whether word equations with length constraints is decidable, though it is known that letter-counting (e.g. counting the number of occurrences of 0s and 1s separately) yields undeciability. In contrast, for  $\strline[\replaceall]$ with length (integer) constraints, we show undecidability outright. 



%Solving word equation was an intriguing problem since the beginning of computer science, investigated
%initially due to its ties to Hilbert’s 10th problem. Initially it was conjectured that this
%problem is undecidable, which was disproved by Makanin [10]. At the beginning little attention
%was given to computational complexity of Makanin’s algorithm and the problem itself; these questions
%were reinvestigated in the ’90 [6, 18, 9], culminating in the EXPSPACE implementation of
%Makanin’s algorithm by Gutiérrez [5].


%\cite{J17}
%Word equations in linear space
%
%Word equations are an important problem on the intersection of formal languages and algebra. Given two sequences consisting of letters and variables we are to decide whether there is a substitution for the variables that turns this equation into true equality of strings. The computational complexity of this problem remains unknown, with the best lower and upper bounds being NP and PSPACE. Recently, a novel technique of recompression was applied to this problem, simplifying the known proofs and lowering the space complexity to (nondeterministic) O(n log n). In this paper we show that word equations are in nondeterministic linear space, thus the language of satisfiable word equations is context-sensitive. We use the known recompression-based algorithm and additionally employ Huffman coding for letters. The proof, however, uses analysis of how the fragments of the equation depend on each other as well as a new strategy for nondeterministic choices of the algorithm, which uses several new ideas to limit the space occupied by the letters.


%A Decision Procedure for String Logic with Equations, Regular Membership and Length Constraints 
In \cite{L16}, the author considered the satisfiability problem for string logic with word equations, regular membership and Presburger constraints over length functions. %The difficulty comes from multiple occurrences of string variables making state-of-the-art algorithms non-terminating. Our main contribution is to 
He showed that the satisfiability problem in a fragment where no string variable occurs more than twice in an equation is decidable. 
%In particular, he proposed a semi-decision procedure for arbitrary string formulae with word equations, regular membership and length functions, and showed that the algorithm always terminates for the aforementioned decidable fragment, with a complexity analysis. 
This fragment is largely incomparable to ours, as the $\replaceall$ function was not addressed therein, but it allowed Presburger constraints over length functions.
%The essence of our procedure is an algorithm to enumerate an equivalent set of solvable disjuncts for the formula. We further show that the algorithm always terminates for the aforementioned decidable fragment. Finally, we provide a complexity analysis of our decision procedure to prove that it runs, in the worst case, in factorial time.

%In \cite{BTV09} the authors discussed the problem of path feasibility for programs manipulating strings using a collection of standard string library functions. They prove results on the complexity of this problem, including its undecidability in the general case and decidability of some special cases. \tl{how would it connect to ours?}



The $\replaceall$ function can be seen as a special yet expressive string transformation function, aka string transducer. With this viewpoint, 
the $\replaceall$ function is also related to two recently introduced transducer models: streaming string transducers \cite{AC10} and symbolic transducers \cite{symbolic-transducer}. 

A streaming string transducer is a finite state machine where  a finite set of string variables are used to store the intermediate results for output. The $\replaceall(x, e, y)$ term can be modelled by an extension of streaming string transducers with parameters, that is, a streaming string transducer which reads an input string (interpreted as the value of $x$), uses $y$ as a free string variable which is presumed to be read-only, and updates a string variable $z$, which stores the computation result, by a string term which may involve $y$. Nevertheless, to the best of our knowledge, this extension of streaming string transducers has not been investigated so far. 

Symbolic transducers is an extension of Mealy machine to infinite alphabets by using a variable $cur$ to represent the symbol in the current position, and replacing the input and output letters in transitions with unary predicates $\varphi(cur)$ and terms involving $cur$ respectively. It is an interesting future work to consider an extension of the $\replaceall$ function to sequences of numerical values, by following the idea of symbolic transducers. For instance, one may consider the term $\replaceall(x, cur \equiv 0 \bmod 2, y)$ which replaces every even number in $x$ with $y$.

Finally, the $\replaceall$ function is related to array folds logic introduced in \cite{DHK16} as well. In \cite{DHK16}, Daca et al. considered an extension of the quantifier-free theory of integer arrays, called array folds logic, to express counting. The main feature of the logic is the \emph{fold} terms, borrowed from the folding concept in functional languages. Intuitively, a fold term applies a function to every element of the array to compute an output. If strings are taken as arrays where the elements are from a finite domain (the alphabet), the $\replaceall$ function can be seen as a fold term on arrays. Nevertheless, the $\replaceall$ function goes beyond the fold terms in \cite{DHK16}, since it outputs a string (an array), instead of an integer. Therefore, the results in \cite{DHK16} cannot be applied to our setting.

\subsection*{Practical approaches}

There is a large amount of work in the past years on developing practical string solvers, Kaluza~\cite{Berkeley-JavaScript}, Hampi~\cite{HAMPI}, Z3-str~\cite{z3-str}, CVC4~\cite{cvc4}, Stranger~\cite{YABI14}, Norn~\cite{Abdulla14}, S3 and S3P~\cite{S3,TCJ16}, and FAT~\cite{Abdulla17}.
Among them, only Stranger, S3, and S2P support the $\replaceall$ function.  

%String solvers that support concatenations and the replace-all operator are available. \cite{BTV09,TCJ14,YABI14,S3}

%\cite{BTV09} considered an efficient finite model finding method for string constraints. They develop a two-tier finite model finding procedure. First, an integer abstraction of string constraints are passed to an SMT (Satisfiability Modulo Theories) solver. The abstraction is either unsatisfiable, or the solver produces a model that fixes lengths of enough strings to reduce the entire problem to be finite domain. The resulting fixed-length string constraints are then solved in a second phase. 

%We implemented the procedure in a symbolic execution framework, report on the encouraging results and discuss directions for improving the method further.


In the Stranger tool, %Verifying string manipulating programs is a crucial problem in computer security. String operations are used extensively within web applications to manipulate user input, and their erroneous use is the most common cause of security vulnerabilities in web applications. We 
an automata-based approach was provided for symbolic analysis of PHP programs, where two different semantics of the $\replaceall$ function were both considered, namely, the leftmost and longest matching as well as the leftmost and shortest matching. Nevertheless, they focused on the abstraction-interpretation based analysis of PHP programs and provided an \emph{over-approximation} of all the possible values of the string variables at each program point. Therefore, their string constraint solving algorithm is just a heuristics, but \emph{not} a decision procedure. In contrast, we provided a decision procedure for the straight-line fragment that involves the rather general $\replaceall$ function, where the pattern parameters can be arbitrary regular expressions and the replacement parameters can be variables, under the leftmost and longest semantics (albeit our decision procedure can be adapted to the leftmost and shortest semantics easily).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
 For the string operations, the authors focus on two common ones: concatenation and replacement. The latter is close to---but not the same as---the $\replaceall$ function considered in this paper. However, in this paper, Yu et al provided   an \emph{over-approximation} of more %restricted replace 
commonly used semantics, i.e., the longest match and first match semantics. 
%
%\cite{SMV12} translating regular expression matching into transducer. 
%
They use deterministic finite automata (DFAs) to represent possible values of string variables. Using forward reachability analysis we compute an over-approximation of all possible values that string variables can take at each program point. They also implemented Stranger, an automata-based string analysis tool, with experiments. In general, this is essentially an abstract interpretation based approach.  In comparison, our algorithm is also automata-based, but we work on a semantics of $\replaceall$, but not its approximation. \tl{more need to be said here}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Intersecting these with a given attack pattern yields the potential attack strings if the program is vulnerable. Based on the presented techniques, we have implemented Stranger, an automata-based string analysis tool for detecting string-related security vulnerabilities in PHP applications. We evaluated Stranger on several open-source Web applications including one with 350,000+ lines of code. Stranger is able to detect known/unknown vulnerabilities, and, after inserting proper sanitization routines, prove the absence of vulnerabilities with respect to given attack patterns.

 
The S3 and S3P tool also support the $\replaceall$ function, where some progressive searching strategies were provided to deal with the non-termination problem brought out by the recursively defined string operations e.g. the $\replaceall$ function. 
Nevertheless, their algorithms are doomed to be incomplete as reasoning about unbounded strings defined recursively is in general an undecidable problem.


%, the authors present S3 (which stands for Symbolic String Solver), a new symbolic string solver.
%The constraint language covers all the main string operations including the replace-all function. The authors 
%provided algorithms which make use of a symbolic representation so that membership in a set defined by a regular expression can be encoded as string equations. 

%To amplify this point, let us now state some statistics from a comprehensive
%study of practical JavaScript applications [28]. Constraints
%arising from the applications have an average (per benchmark
%query) of 63 JavaScript string operations, while the remaining
%are boolean, logical and arithmetic constraints. The largest fraction
%are for operations like indexOf, length (78%). A significant
%fraction of the operations, including substring (5%), replace
%(8%), and split, match (1%). Of the match, split and
%replace operations, 31% are based on regular expressions. Operations
%such as replace and split give rise to new strings
%from the original ones, thereby giving rise to constraints involving
%multiple string variables.



%. The algorithm first makes use of a symbolic representation
%so that membership in a set defined by a regular expression
%can be encoded as string equations. Secondly, there is a constraint based
%generation of instances from these symbolic expressions so
%that the total number of instances can be limited. 
%
%We evaluate S3 on a well-known set of practical benchmarks, demonstrating both
%its robustness (more definitive answers) and its efficiency (about 20
%times faster) against the state-of-the-art.



\hide{
%Progressive Reasoning over Recursively-Defined Strings
\cite{TCJ16} 
Trinh et al considered %the problem of reasoning over an expressive constraint language for unbounded strings. 
%In particular, they considered 
recursively defined string functions, a very expressive way to define functions manipulating strings. This includes a recursive definition of the replace-all function considered in this paper\footnote{\cite{TCJ16} used the notation \textbf{replace}}. The authors argue that ``the difficulty comes from ``recursively defined" functions such as replace, making state-of-the-art algorithms non-terminating." They proposed a progressive search algorithm, %to not only mitigate the problem of non-terminating reasoning but also guide the search towards a “minimal solution” when the input formula is in fact satisfiable. We have 
implemented within the state-of-the-art Z3 framework, with experimental evaluations. The algorithm is genetic and  applicable to all recursively defined string functions, but it is doomed to be incomplete as reasoning about unbounded strings defined recursively is in general an undecidable problem.   

The focus of our work is on the fundamental issue of decidability, and this is complementary to the work. Our result may be considered a completeness guarantee for existing string solver. 
}

%Importantly, we have enabled conflict clause learning for string theory so that our solver can be used effectively in the setting of program verification. Finally, our experimental evaluation shows leadership in a large benchmark suite, and a first deployment for another benchmark suite which requires reasoning about string formulas of a class that has not been solved before.



%===========================================================
%
%\subsection*{Other related work}
 



%Symbolic Finite State Transducers:
%Algorithms and Applications

%
%Finite automata and finite transducers are used in a wide
%range of applications in software engineering, from regular
%expressions to specification languages. We extend these
%classic objects with symbolic alphabets represented as parametric
%theories. Admitting potentially infinite alphabets
%makes this representation strictly more general and succinct
%than classical finite transducers and automata over strings.
%Despite this, the main operations, including composition,
%checking that a transducer is single-valued, and equivalence
%checking for single-valued symbolic finite transducers are
%effective given a decision procedure for the background theory.
%We provide novel algorithms for these operations and
%extend composition to symbolic transducers augmented with
%registers. Our base algorithms are unusual in that they are
%nonconstructive, therefore, we also supply a separate model
%generation algorithm that can quickly find counterexamples
%in the case two symbolic finite transducers are not
%equivalent. The algorithms give rise to a complete decidable
%algebra of symbolic transducers. Unlike previous work, we
%do not need any syntactic restriction of the formulas on the
%transitions, only a decision procedure. In practice we leverage
%recent advances in satisfiability modulo theory (SMT)
%solvers. We demonstrate our techniques on four case studies,
%covering a wide range of applications. Our techniques
%can synthesize string pre-images in excess of 8, 000 bytes
%in roughly a minute, and we find that our new encodings
%significantly outperform previous techniques in succinctness
%and speed of analysis
% 