%!TEX root = popl2018.tex

\section{Related work}

 
In this section, we discuss some related work. 

\paragraph{Word equations} Makanin's and Plandowski's  on the decidability
and complexity of satisfiability for word equations, i.e., a conjunction of equations of $v=w$, where $v, w$ are concatenation of string constants and variable. 

In addition, it is still a long-standing open problem whether word equations with length constraints is decidable, though it is known that letter-counting (i.e., counting the number of occurrences of 0s and 1s separately) yields undeciability.  

\subsection*{Heuristics and string solver implementation}

There is a large amount of work in the past years on developing practical string solvers
\tl{plz help to put reference here}. String solvers that support concatenations and the replace-all operator are available. \cite{BTV09, TCJ14, YABI14,TCJ16}


\cite{BTV09} We discuss the problem of path feasibility for programs manipulating strings using a collection of standard string library functions. We prove results on the complexity of this problem, including its undecidability in the general case and decidability of some special cases. In the context of test-case generation, we are interested in an efficient finite model finding method for string constraints. To this end we develop a two-tier finite model finding procedure. First, an integer abstraction of string constraints are passed to an SMT (Satisfiability Modulo Theories) solver. The abstraction is either unsatisfiable, or the solver produces a model that fixes lengths of enough strings to reduce the entire problem to be finite domain. The resulting fixed-length string constraints are then solved in a second phase. We implemented the procedure in a symbolic execution framework, report on the encouraging results and discuss directions for improving the method further.


\cite{YABI14} %Verifying string manipulating programs is a crucial problem in computer security. String operations are used extensively within web applications to manipulate user input, and their erroneous use is the most common cause of security vulnerabilities in web applications. We 
The authors present an automata-based approach for symbolic analysis of string manipulating programs. 

For the string operations, the authors focus on two common ones: concatenation and replacement. For the latter, two semantics are considered, i.e., longest match and first match. The replacement operation provides an over-approximation of such more restricted replace semantics. 

\cite{SMV12} translating regular expression matching into transducer. 

They use deterministic finite automata (DFAs) to represent possible values of string variables. Using forward reachability analysis we compute an over-approximation of all possible values that string variables can take at each program point. They also implemented Stranger, an automata-based string analysis tool, with experiments. 

%Intersecting these with a given attack pattern yields the potential attack strings if the program is vulnerable. Based on the presented techniques, we have implemented Stranger, an automata-based string analysis tool for detecting string-related security vulnerabilities in PHP applications. We evaluated Stranger on several open-source Web applications including one with 350,000+ lines of code. Stranger is able to detect known/unknown vulnerabilities, and, after inserting proper sanitization routines, prove the absence of vulnerabilities with respect to given attack patterns.

%Motivated by the vulnerability analysis of web programs which
work on string inputs, we 
\cite{TCJ14}, the authors present S3 (which stands for Symbolic String Solver), a new symbolic string solver.
%Our solver employs a new algorithm for a constraint language that
%is expressive enough for widespread applicability. Specifically, our
The constraint language covers all the main string operations including the replace-all function. The authors 
provided algorithms which make use of a symbolic representation so that membership in a set defined by a regular expression can be encoded as string equations. 

%To amplify this point, let us now state some statistics from a comprehensive
%study of practical JavaScript applications [28]. Constraints
%arising from the applications have an average (per benchmark
%query) of 63 JavaScript string operations, while the remaining
%are boolean, logical and arithmetic constraints. The largest fraction
%are for operations like indexOf, length (78%). A significant
%fraction of the operations, including substring (5%), replace
%(8%), and split, match (1%). Of the match, split and
%replace operations, 31% are based on regular expressions. Operations
%such as replace and split give rise to new strings
%from the original ones, thereby giving rise to constraints involving
%multiple string variables.



%. The algorithm first makes use of a symbolic representation
%so that membership in a set defined by a regular expression
%can be encoded as string equations. Secondly, there is a constraint based
%generation of instances from these symbolic expressions so
%that the total number of instances can be limited. 
%
%We evaluate S3 on a well-known set of practical benchmarks, demonstrating both
%its robustness (more definitive answers) and its efficiency (about 20
%times faster) against the state-of-the-art.



%Progressive Reasoning over Recursively-Defined Strings
\cite{TCJ16} 
Trinh et al considered %the problem of reasoning over an expressive constraint language for unbounded strings. 
%In particular, they considered 
recursively defined string functions, a very expressive way to define functions manipulating strings. This includes a recursive definition of the replace-all function considered in this paper\footnote{\cite{TCJ16} used the notation \textbf{replace}}. The authors argue that ``the difficulty comes from ``recursively defined" functions such as replace, making state-of-the-art algorithms non-terminating." They proposed a progressive search algorithm, %to not only mitigate the problem of non-terminating reasoning but also guide the search towards a “minimal solution” when the input formula is in fact satisfiable. We have 
implemented within the state-of-the-art Z3 framework, with experimental evaluations. The algorithm is genetic and  applicable to all recursively defined string functions, but it is doomed to be incomplete as reasoning about unbounded strings defined recursively is in general an undecidable problem.   

%Importantly, we have enabled conflict clause learning for string theory so that our solver can be used effectively in the setting of program verification. Finally, our experimental evaluation shows leadership in a large benchmark suite, and a first deployment for another benchmark suite which requires reasoning about string formulas of a class that has not been solved before.

%A Decision Procedure for String Logic with Equations, Regular Membership and Length Constraints 
\cite{L16}, the author considered the satisfiability problem for string logic with equations, regular membership and Presburger constraints over length functions. %The difficulty comes from multiple occurrences of string variables making state-of-the-art algorithms non-terminating. Our main contribution is to 
He show that the satisfiability problem in a fragment where no string variable occurs more than twice in an equation is decidable. In particular, he proposed a semi-decision procedure for arbitrary string formulae with word equations, regular membership and length functions, and showed that the algorithm always terminates for the aforementioned decidable fragment, with a complexity analysis. 
This fragment is largely incomparable to ours, as no replace-all functions are addressed therein. (However, it allows more expressive Presburger constraints over length functions.)
%The essence of our procedure is an algorithm to enumerate an equivalent set of solvable disjuncts for the formula. We further show that the algorithm always terminates for the aforementioned decidable fragment. Finally, we provide a complexity analysis of our decision procedure to prove that it runs, in the worst case, in factorial time.

The focus of our work is on the fundamental issue of decidability, and this is complementary to the work. Our result may be considered a completeness guarantee for existing string solver. 

The $\replaceall$ function is a special yet expressive string transformation function, aka. string transducer. With this viewpoint, 
the $\replaceall$ function is also related to two recently introduced transducer models: streaming string transducers \cite{AC10} and symbolic transducers \cite{symbolic-transducer}. 

A streaming string transducer is a finite state machine where  a finite set of string variables are used to store the intermediate results for output. The $\replaceall(x, e, y)$ term can be modelled by an extension of streaming string transducers with parameters, that is, a streaming string transducer which reads an input string (interpreted as the value of $x$), uses $y$ as a free string variable which is presumed to be read-only, and updates a string variable $z$, which stores the computation result, by a string term which may involve $y$. Nevertheless, to the best of our knowledge, this extension of streaming string transducers has not been investigated so far. 

Symbolic transducers is an extension of Mealy machine to infinite alphabets by using a variable $cur$ to represent the symbol in the current position, and replacing the input and output letters in transitions with unary predicates $\varphi(cur)$ and terms involving $cur$ respectively. It is an interesting future work to consider an extension of the $\replaceall$ function to sequences of numerical values, by following the idea of symbolic transducers. For instance, one may consider the term $\replaceall(x, cur \equiv 0 \bmod 2, y)$ which replaces every even number in $x$ with $y$.

In \cite{DHK16}, Daca et al. considered an extension of the quantifier-free theory of integer arrays, called array folds logic, to express counting. The main feature of the logic is the \emph{fold} terms, borrowed from the folding concept in functional languages. Intuitively, a fold term applies a function to every element of the array to compute an output. If strings are taken as arrays where the elements are from a finite domain (the alphabet), the $\replaceall$ function can be seen as a fold term on arrays. Nevertheless, the $\replaceall$ function goes beyond the fold terms in \cite{DHK16}, since it outputs a string (an array), instead of an integer. Therefore, the results in \cite{DHK16} cannot be applied here.
