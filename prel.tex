%!TEX root = popl2018.tex

\section{Preliminaries}

\subsection*{General notations} 
Let $\Nat$ denote the set of natural numbers. For $k \in \Nat$, let $[k] = \{1,\cdots, k\}$. For a vector $\vec{x}=(x_1,\cdots, x_n)$, let $|\vec{x}|$ denote the length of $\vec{x}$ (i.e., $n$), and for each $i \in [n]$, let $\vec{x}[i]$ denote $x_i$. For a vector $\vec{x} = (x_1, \cdots, x_n)$, let $\red(\vec{x})$ denote the \emph{reduction} of $\vec{x}$, more specifically, the vector $(x_{i_1},\cdots, x_{i_m})$ such that for each $j \in [m]$, $x_{i_j}$ is different from all $x_1, \cdots, x_{i_j-1}$.
\tl{red is for reduced?}

The term DAG stands for \emph{directed acylic graphs}. They are finite directed graphs with no directed cycles. That is, each DAG consists of finitely many vertices and edges, with each edge directed from one vertex to another, such that there is no way to start at any vertex $v$ and follow a consistently-directed sequence of edges that eventually loops back to $v$ again. Equivalently, a DAG is a directed graph that has a topological ordering, a sequence of the vertices such that every edge is directed from earlier to later in the sequence. \zhilin{maybe extended by including more graph-theoretical notations.}

\subsection*{Regular languages}
Fix a finite \emph{alphabet} $\Sigma$. Elements in $\Sigma^*$ are called \emph{strings}. Let $\varepsilon$ denote the empty string and  $\Sigma^+ = \Sigma^* \setminus \{\varepsilon\}$. We will use $a,b,\cdots$ to denote letters from $\Sigma$ and $u, v, w, \cdots$ to denote strings from $\Sigma^*$. For a string $u \in \Sigma^*$, let $|u|$ denote the \emph{length} of $u$ (in particular, $|\varepsilon|=0$), in addition, for $i \in [|u|]$, let $u[i]$ denote the $i$-th letter of $u$. 
For two strings $u_1, u_2$, we use $u_1 \cdot u_2$ to denote the \emph{concatenation} of $u_1$ and $u_2$, that is, the string $v$ such that $|v|= |u_1| + |u_2|$ and for each $i \in |u_1|$, $v[i]= u_1[i]$ and for each $i \in |u_2|$, $v[|u_1|+i]=u_2[i]$. Let $u, v$ be two strings. If $v = u \cdot v'$ for some string $v'$, then $u$ is said to be a \emph{prefix} of $v$. In addition, if $u \neq v$, then $u$ is said to be a \emph{strict} prefix of $v$. If $u$ is a prefix of $v$, that is, $v = u \cdot v'$ for some string $v'$, then we use $u^{-1} v$ to denote $v'$. 

A \emph{language} over $\Sigma$ is a subset of $\Sigma^*$. We will use $L_1, L_2, \dots$ to denote the languages. For two languages $L_1, L_2$, we use $L_1 \cup L_2$ to denote the union of $L_1$ and $L_2$, moreover, we use $L_1 \cdot L_2$ to denote the concatenation of $L_1$ and $L_2$, that is, the language $\{u_1 \cdot u_2 \mid u_1 \in L_1, u_2 \in L_2\}$. For a language $L$ and $n \in \Nat$, we define $L^n$, the \emph{iteration} of $L$ for $n$ times, inductively as follows: $L^0=\{\varepsilon\}$ and $L^{n} =L \cdot L^{n-1}$ for $n > 0$. We also use $L^*$ to denote the iteration of $L$ for arbitrarily many times, that is, $L^* = \bigcup \limits_{n \in \Nat} L^n$. Moreover, let $L^+ = \bigcup \limits_{n \in \Nat \setminus \{0\}} L^n$.

\begin{definition}[Regular expressions $\regexp$]
	\[e \eqdef \varepsilon \mid a \mid e + e \mid e \concat e \mid e^*, \mbox{ where } a \in \Sigma. \]
	Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. We use the abbreviation $e^+ \equiv e \concat e^*$. Moreover, for $\Sigma = \{a_1, \cdots, a_n\}$, we use the abbreviations $\Sigma \equiv a_1 + \cdots + a_n$ and $\Sigma^\ast \equiv (a_1 + \cdots + a_n)^\ast$. 
\end{definition}
We define $\Ll(e)$, the language defined by $e$, that is, the set of strings that match $e$, inductively as follows: 
%\begin{itemize}
%\item 
$\Ll(\varepsilon) =\{\varepsilon\}$,
%
%\item 
$\Ll(a)= \{a\}$,
%
%\item 
$\Ll(e_1 + e_2) = \Ll(e_1) \cup \Ll(e_2)$,
%
%\item 
$\Ll(e_1 \concat e_2) = \Ll(e_1) \cdot \Ll(e_2)$,
%
%\item 
$\Ll(e_1^*)=(\Ll(e_1))^*$.
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
	A regular expression $e$ is said to be \emph{bounded} if $e$ is defined by the rules, $e \eqdef a \mid u^\ast \mid e \concat e$, where $u$ is a constant string. For instance, $a (bc)^\ast$ is bounded, while $(ab^\ast)^\ast$ is not. A regular expression $e$ is a union of bounded regular expressions if $e = e_1 + \dots + e_k$ such that each $e_i$ is a bounded regular expression. We use UBR to abbreviate the set of regular expressions which are a union of bounded regular expressions.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It is well-known that regular expressions are expressively equivalent to nondeterministic finite automata \cite{}. 
A \emph{nondeterministic finite automaton} (NFA) $\cA$ on $\Sigma$ is a tuple $(Q, \delta, q_0, F)$, where $Q$ is a finite set of \emph{states}, $q_0 \in Q$ is the \emph{initial} state, $F \subseteq Q$ is the set of \emph{final} states, and $\delta \subseteq Q \times \Sigma \times Q$ is the \emph{transition relation}. For a string $w = a_1 \dots a_n$, a \emph{run} of $\cA$ on $w$ is a state sequence $q_0 \dots q_n$ such that for each $i \in [n]$, $(q_{i-1}, a_i, q_i) \in \delta$. A run $q_0 \dots q_n$ is \emph{accepting} if $q_n \in F$. A string $w$ is \emph{accepted} by $\cA$ if there is an accepting run of $\cA$ on $w$. We use $\Ll(\cA)$ to denote the language defined by $\cA$, that is, the set of strings accepted by $\cA$. We will use $\cA, \cB, \cdots$ to denote NFA. An NFA $\cA$ is \emph{deterministic} if for each $(q, \sigma) \in Q \times \Sigma$, there is at most one $q' \in Q$ such that $(q, a, q') \in \delta$. An NFA $\cA$ is \emph{complete} if for each $(q, \sigma) \in Q \times \Sigma$, there is at least one $q' \in Q$ such that $(q, a, q') \in \delta$. We assume that all NFA considered in this paper are complete.  An NFA $\cA$ is \emph{unambiguous} if for each word $w$, there is \emph{at most one accepting} run of $\cA$ on $w$.
For a string $w= a_1 \dots a_n$, we also use the notation $q_1 \xrightarrow[\cA]{w} q_{n+1}$ to denote the fact that there are $q_2,\dots, q_n \in Q$ such that for each $i \in [n]$, $(q_i, a_i, q_{i+1}) \in \delta$.  For an NFA $\cA=(Q, \delta, q_0, F)$ and $q, q' \in Q$, we use $\cA(q,q')$ to denote the NFA which is obtained from $\cA$ by changing the initial state to $q$ and the set of final states to $\{q'\}$.

% copy from Lin's paper. 

\subsection*{Computational complexity}
In this paper, we study not only decidability but also the complexity of string logics. Pinpointing the
precise complexity of verification problems is not only of fundamental
importance, but also it often suggests algorithmic techniques
that are most suitable for attacking the problem in practice.
In this paper, we deal with the following computational complexity
classes (see \cite{} for more details): P (problems solvable
in polynomial-time), PSPACE (problems solvable in polynomial
space and exponential time), and EXPSPACE (problems solvable
in exponential space and double exponential time). Verification
problems that have complexity PSPACE or beyond see [40, 60]
for a few examples have substantially benefited from techniques
like symbolic model checking \cite{}. As we shall see later, our complexity
upper bound also suggests the maximum lengths of words
that need to be explored to guarantee completeness.

%=====================================================================================================

\section{The core constraint language}

In this section, we define a general string constraint language that supports word equations, concatenations, the $\replaceall$ function, and regular constraints.  Throughout this section, we fix an alphabet $\Sigma$.



\subsection{Semantics of the $\replaceall$ function}
To define the semantics of the $\replaceall$ function, we note that the function has three parameters: the first parameter is the \emph{subject} string, the second parameter is a \emph{pattern} that is a string or a regular expression, the third parameter is the \emph{replacement} string.  
%The most interesting case is when the second parameter is  a regular expression. 
When the second parameter is a regular expression, there is no consensus on the semantics of the $\replaceall$ function even for the mainstream programming languages such as Python and Javascript.
 %where replaceall functions are extensively used. 
 This is particularly the case when interpreting the union operator in regular expressions. In this paper we follow the POSIX standard, and mainly focus on the following semantics. Intuitively we consider the leftmost and longest match. 


\begin{definition}
Given two strings $u,v$, a regular expression $e$ such that $\varepsilon \not \in \Ll(e)$, we say that $u$ is the \emph{leftmost and longest} match of $e$ in $v$ if $v=v_1\cdot u \cdot v_2$ and the following two conditions hold
\begin{enumerate}
	\item leftmost: $u \in \Ll(e)$,  and $(v'_1)^{-1} v \not \in  \Ll(e \concat \Sigma^\ast)$ for every strict prefix $v'_1$ of $v_1$, 
	\item longest: for every nonempty prefix $v'_2$ of $v_2$, $u \cdot v'_2 \not \in \Ll(e)$.
\end{enumerate} 
\end{definition}


\begin{definition} \label{def:replaceall}
The semantics of $\replaceall(u, e, v)$, where $u, v$ are strings and $e$ is a regular expression, is defined inductively as follows:
\begin{itemize}
	\item if $\varepsilon \in \Ll(e)$, then
	\begin{itemize}
	\item if $u = \varepsilon$, then $\replaceall(u,e, v) = v$,
	
	\item otherwise, let $u = a \cdot u'$ for $a \in \Sigma$, then $\replaceall(u, e, v) =v \cdot a \cdot \replaceall(u', e, v)$,
	\end{itemize}
%
	\item otherwise,
	\begin{itemize}
	\item if $u \not \in \Ll(\Sigma^\ast e \Sigma^\ast)$, i.e., $u$ does \emph{not} contain any substring from $\Ll(e)$, then $\replaceall(u, e, v) = u$, 
	%
	\item otherwise, let $u = u' \cdot u \cdot u''$ such that $u$ is the \emph{leftmost and longest} match of $e$ in $v$, then $\replaceall(u, e, v) = u' \cdot v \cdot \replaceall(u'', e, v)$.
	\end{itemize}
\end{itemize}
\end{definition}

\begin{example}
When the second parameter is a string (or more specially a single letter), most programming languages take the same semantics which is consistent to Definition~\ref{def:replaceall}. For instance,  $\replaceall(abab, ab, d) =dd$. It is worth mentioning the case that the second parameter is an empty string, where, for instance,  $\replaceall(aaaa, ``", d) =dadadadad$.

When the second parameter is a regular expression, some examples are $\replaceall(abac, a^*, d) =d a d b d a d c d$ and $\replaceall(abac, a^+, d)=dbdc$. However, when the regular expression contains $+$, programming languages diverge... 
\tl{do we need to say more here?}
\end{example}

\subsection{Straight-line string constraints with the $\replaceall$ function}

\tl{Int will not be used until very late. Some picky reviewers will complain. Shall we introduce them later?} 

We consider the following data types: String data type $\str$ and Integer data type $\intnum$.
%, and Array of strings $\str [\ ]$. \tl{I do not think we need $\str[]$, right?}
%
%
We assume a countably set of variables, of the data type $\str$ and  $\intnum$ respectively. We will use $x, y, z, \cdots$ to denote the variables of data type $\str$, and $\mathfrak{l}, \mathfrak{m}, \mathfrak{n}, \cdots$ to denote the variables of data type $\intnum$. 

%In addition, we use $X, Y, Z, \dots$ to denote the variables of data type $\str[\ ]$.

%We use $u, v, w, \dots$ to denote the constant strings, and $c, c',\dots$ to denote the constant integers.



\begin{definition}[Relational and regular constraints with the $\replaceall$ function]
	Relational constraints and regular constraints are defined by the following rules,
	\[
	\begin{array}{r c l cr}
	s &\eqdef & x \mid u & \ \ & \mbox{(string terms)}\\
	p &\eqdef & X \mid e & \ \ & \mbox{(pattern terms)}\\
	%t &\eqdef & s \mid e & \ \ & \mbox{(terms)}\\
	\varphi &\eqdef & x = s \concat s  \mid  x = \replaceall(s, p, s) \mid \varphi \wedge \varphi & \ \ & \mbox{(relational constraints)}\\
	\psi & \eqdef & x \in e \mid \psi \wedge \psi %\mid \psi \vee \psi \mid \neg \psi   
	& \ \ & \mbox{(regular constraints)} \\
	\end{array}
	\]
	where $u \in \Sigma^\ast$ and $e$ is a regular expression over $\Sigma$. 
	
	
	\tl{can the regular constraints be simplified to just a conjunction of $x\in e$?}\zhilin{since the pspace upper bound holds for the general case, I do not see the necessity of the restriction here.}
	%A regular constraint $\psi$ is a UBR constraint if for each atom $x \in e$ occurring in $\psi$, $e$ is in UBR.
	\tl{zhilin, it is not a restriction, it is a simplification. Look at what we have now, I guess this is sufficient. feel free to change back if you do not like it.}
\end{definition}


For a formula $\varphi$, let $\vars(\varphi)$ denote the set of variables occurring in $\varphi$. Similarly for $\vars(\psi)$.



Given a relational constraint $\varphi$, a variable $x$ is called a \emph{source variable} of $\varphi$ if $\varphi$ \emph{does not} contain a conjunct of the form $x = s_1 \concat s_2$ or $x = \replaceall(\dots)$.

 
The generality of the constraint language makes it undecidable,
even in very simple cases. To retain decidability, we follow \cite{LB16} and focus on the ``straight-line fragment" of the language. This straight-line fragment captures the structure of straight-line string-manipulating
programs with concatenations and $\replaceall$ as atomic string operations.  

\begin{definition}[Straight-line relational constraints with the $\replaceall$ function]
	A relational constraint $ \varphi$ with $\replaceall$ function is straight-line, if $\varphi \eqdef \bigwedge \limits_{1 \le i \le m} x_i = P_i$ such that
	\begin{itemize}
		\item $x_1,\dots, x_m$ are mutually distinct,
		\item for each $i \in [m]$, all the variables in $P_i$ are either source variables, or variables from $\{x_1,\dots, x_{i-1}\}$,
	\end{itemize}
\end{definition}
Intuitively, in a straight-line relational constraint, the dependency graph of the string variables is acyclic.


\begin{definition}[Straight-line string constraints with the $\replaceall$ function]
	A straight-line string constraint $C$ with the $\replaceall$ function (denoted by $\strline[\replaceall]$)  is defined as $ \varphi \wedge \psi$,  where 
	\begin{itemize}
		\item $\varphi$ is a straight-line relational constraint,  and
		%
		\item $\psi$ is a regular constraint.
		%
	\end{itemize}
	%Let us use $\Cc$ to denote the set of straight-line string constraints with $\replaceall$ function.
\end{definition}

\begin{remark}
Checking whether a relational constraint $\varphi$ is straight-line can be done in linear time. 
\end{remark}

\begin{example}
\end{example}


%Let us use $\pstrline[\replaceall]$ to denote the set of pure $\strline[\replaceall]$ constraints.

%\medskip

\section{The satisfiability problem} 
In this paper, we focus on the satisfiability problem of $\strline[\replaceall]$.

\smallskip

\begin{quote}
\framebox{Given an $\strline[\replaceall]$ constraint $C$, decide whether $C$ is satisfiable.}
\end{quote}
\smallskip

We plan to investigate extensively the satisfiability problem of the fragments of $\strline[\replaceall]$ (see Table~\ref{tab-sum}). Note that for $x=\replaceall (y, p, z)$, $p$ is referred to as a \emph{pattern} and $z$ is referred to as a \emph{replacement}.

\begin{table}[htbp]
\begin{tabular}{|c|c|c|c}
\hline
pattern ($p$)  &   replacement ($z$)        & decidability/complexity \\
\hline
constant string  &   constant   string                    & PSPACE-c (\cite{LB16})     \\
\hline
string variable &   constant   string                    &  undecidable (Proposition ~\ref{prop-und-pat-var})    \\
\hline
regular expression  &   constant string                      &    PSPACE-c (\cite{LB16}) ?     \\

\hline
constant string  &   string variable                       & PSPACE-c (Theorem~\ref{thm-main})       \\

\hline
string variable  &   string variable                       & undecidable   (Proposition ~\ref{prop-und-pat-var})   \\

\hline
regular expression  &   string variable                       &      PSPACE-c (Theorem~\ref{thm-main})      \\
\hline
\end{tabular}
\caption{Fragments of $\strline[\replaceall]$}\label{tab-sum}
\end{table}

It turns out that if the second parameters of the $\replaceall$ terms are allowed to be variables, then the satisfiability problem of $\strline[\replaceall]$ is undecidable.

\begin{proposition}\label{prop-und-pat-var}
The satisfiability problem of $\strline[\replaceall]$ is undecidable, if the second parameters of the $\replaceall$ terms are allowed to be variables.
\end{proposition}

\begin{proof}
	We reduce from the Post Correspondence Problem (PCP). The input of the problem consists of two finite lists $\alpha_{1},\ldots ,\alpha_{N}$ and $\beta_1,\ldots ,\beta_N$ of words over $\Sigma$ having at least two symbols. A solution to this problem is a sequence of indices $(i_{k})_{1\leq k\leq K}$ with $ K\geq 1$ and $ 1\leq i_{k}\leq N$ for all$k$, such that
	\[
	\alpha _{{i_{1}}}\ldots \alpha _{{i_{K}}}=\beta _{{i_{1}}}\ldots \beta _{{i_{K}}}.
	\]
	The decision problem then is to decide whether such a solution exists or not.
	
	We then introduce, for $i=1,\cdots, N$, 
	$x_{i+1}=\replaceall(x_0, \alpha_i, i)$ and $y_{i+1}=\replaceall(y_0, \beta_i, i)$, 
	$x_0'=\replaceall(x_0, \sharp, \epsilon)$ and $y_0'=\replaceall(y_0, \sharp, \epsilon)$
	
	$x_{N+1}=y_{N+1}$, $x_0'=y'_0$
	
	
	with regular constraints $x_0\in \sharp((\sum_{i=1}^N\alpha_i)\sharp)^*$ and $y_0\in \sharp((\sum_{i=1}^N\beta_i)\sharp)^*$,
	
	where $z=z'$ can be encoded by 
		$z''=\replaceall(z, z', \$)$ and $z''\in \$$. 
\end{proof}

\tl{I trust you guys can simplify this a lot; i am not a fan of PCP :-)}

On the other hand, if the second parameters of the $\replaceall$ terms are regular expressions, then the satisfiability problem is decidable and PSPACE-complete. 

\begin{theorem}\label{thm-main}
The satisfiability problem of $\strline[\replaceall]$ is decidable in PSPACE, if the second parameters of the $\replaceall$ terms are regular expressions.
\end{theorem}

The following three sections are devoted to the proof of Theorem~\ref{thm-main}. We start with the special case that the single-letter case that the second parameters of the $\replaceall$ terms are letters, then consider the constant-string case that the second parameters of the $\replaceall$ terms are constant strings, and finally the regular-expression case that the second parameters of the $\replaceall$ terms are regular expressions.

The proof of Theorem~\ref{thm-main} utilises a concept of dependency graphs defined below.

\begin{definition}[Dependency graph]
	Let $C= \varphi \wedge \psi$ be an $\strline[\replaceall]$ formula where the second parameters of the $\replaceall$ terms are regular expressions. Suppose $\vars(\varphi) = \{x_1,\dots, x_m, y_1, \dots, y_n\}$, where $y_1,\dots, y_n$ are  source variables. Define the \emph{dependency graph} of $C$ as $G_C= (\vars(\varphi), E_C)$, such that for each $i \in [m]$, if $x_i = \replaceall(z, e_i, z')$, then $(x_i, (\rpleft, e_i), z) \in E_C$ and $(x_i, (\rpright, e_i), z') \in E_C$. A final (resp. initial) vertex in $G_C$ is a vertex in $G_C$ without successors (resp. predecessors). The edges labeled by $(\rpleft, e_i)$ and $(\rpright, e_i)$ are called the $\rpleft$-edges and $\rpright$-edges respectively. 
	%The $\rpleft$-length of a path $\pi$, denoted by $\rpleftlen(\pi)$, is the number of $\rpleft$-edges on $\pi$. A path of $G_C$ is a sequence $z_1 \ell_1 z_2 \dots \ell_{k-1} z_k$ such that for each $i \in [k-1]$, $(z_i, \ell_i, z_{i+1}) \in E_C$. A path is initial (resp. final) if the path starts from an initial vertex (resp. stops at a final vertex).
	% e the $\src$-nesting-depth of $z$ in $G_C$, denoted by $\srcnd_{G_C}(z)$,  as the maximum number of $\src$-edges in paths from source variables to $z$.
\end{definition}
Note that $G_C$ is a DAG where the out-degree of each vertex is two or zero. 

Moreover, we observe that in the definition of $\strline[\replaceall]$,
%
%\begin{remark}\label{rem-concat}
the concatenation operator $s_1 \concat s_2$ is redundant in the sense that $x = s_1 \concat s_2$ can be rewritten as $x' = \replaceall(ab, a, s_1), x = \replaceall(x', b, s_2)$, where $a,b$ are two fresh letters.
%\end{remark}
%\tl{I suggest not put this remark here.}
%
Therefore,  in the following, without loss of generality, we assume that 
in each $\strline[\replaceall]$ constraint $C=\varphi \wedge \psi$, the concatenation symbol $\concat$ does not occur in $\varphi$. 
\tl{as mentioned, here I suggest that here we just provide a clean def of language}\zhilin{Is it OK to put the remark and the assumption here ?}

