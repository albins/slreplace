%!TEX root = popl2018.tex

\section{Introduction}

The problem of %satisfiability of logical theories over strings
solving string constraints (a.k.a. satisfiability of logical theories over
strings)
is an important automated reasoning problem that has in recent years witnessed
renewed interests %in the programming language and verification community
\cite{Berkeley-JavaScript,TCJ16,LB16,YABI14,S3,Abdulla14,Abdulla17,,DV13,symbolic-transducer,BEK,...} 
because of important applications in the analysis of 
string-manipulating programs. For example,
program analysis techniques like symbolic execution \cite{king76,DART,EXE} 
would
%. For example, program analysis techniques like
%symbolic execution \cite{king76} (or variants like dynamic symbolic execution
%\cite{DART,EXE}) will 
systematically explore executions in a program and collect symbolic path 
constraints, which could then be solved using a constraint solver and
used to determine which location in the program to continue exploring.
To successfully apply a constraint solver in this instance, it is
crucial that the constraint language precisely model the data types in the
program, along with the used string operations. In the context of
string-manipulating programs, the string constraints should be expressive enough
to capture the operations that are used in the programs. This could include 
concatenation, regular constraints (i.e. pattern matching against a regular
expression), string-length functions, and the string-replace functions, among 
many others.

%For scripting
%languages (e.g. Python, PHP, and JavaScript), which have grown in popularity
%in recent years, numerous string 
%There are several well-established research threads on this satisfiability 
%problem depending on 
%which string operations are permitted in the theory. 
Perhaps the most well-known theory of strings for applications to analysing
string-manipulating programs is the theory of strings with concatenation 
(a.k.a. \emph{word equations}),
whose decidability status was settled positively by Makanin \cite{Makanin}
in 1977 after it was open for many years. More importantly, 
the theory of strings with concatenation remains 
decidable even when regular constraints are incorporated into the 
language \cite{Schulz}. However, whether adding the string-length function
results preserves the decidability remains a long-standing open problem
\cite{Vijay-length,buchi}.

%\OMIT{
%which is crucial for 
Another important string operation (especially, in popular scripting
languages like Python, JavaScript, and PHP) is the string-replace function, 
which may be used either to replace either the first occurrence or
all occurrences of a string (a string constant/variable, or a pattern) by 
another string (a string constant/variable). The replace function (especially 
the replace-all functionality) is omnipresent in HTML5 applications, as has
been convincingly argued in \cite{LB16,TCJ16,YABI14}. For
example, a standard industry defense against cross-site scripting 
(XSS) vulnerabilities includes sanitising untrusted strings before adding them
into the DOM (Document Object Model) or the HTML document. 
This is typically done by %replacing every occurrence of
various metacharacter-escaping mechanisms (e.g. see 
\cite{Kern14,BEK,OWASP-XSS}), e.g., backslash-escape, which replaces \emph{every
occurrence} of quotes and double-quotes (i.e. \verb+'+ and \verb+"+) in the
string by \verb+\'+ and \verb+\"+. 
In addition
to sanitisers, common JavaScript functionalities like \texttt{document.write()} 
and \texttt{innerHTML} apply an \emph{implicit browser transduction} --- which
decodes HTML codes (e.g. \verb+&#39;+ is replaced by \verb+'+) in the input 
string --- before inserting the input string into the DOM.
Both of these examples can be expressed by (perhaps multiple) 
applications of the string-replace function.


Concatenation: 8\%
Replace-all: 8\%

The string-replace function is yet another string operation that lies beyond 
the expressive power of the theory of concatenation. In fact, it was shown in
\cite{LB16} that incorporating the string-replace function into the theory of 
concatenation results in an undecidable theory of strings. A partial answer ..

\OMIT{
Such string functions, however, cannot
be modelled by 
%}


Such a function is frequently used in 

%especially the way it is used to replace \emph{all} occurrences


One important application %of string solving 
for the analysis of string-manipulating programs is an automatic detection
%for JavaScript applications 
of cross-site scripting (XSS) vulnerabilities
\cite{Berkeley-JavaScript}, which are typically caused by improper handling
of untrusted strings leading to an execution of malicious script in the
clients' browsers. A standard industry defense against XSS is to sanitise these
untrusted strings before adding them into the DOM (Document Object Model) or 
the HTML document. This is typically done by %replacing every occurrence of
certain metacharacter-escaping mechanisms (e.g. see 
\cite{Kern14,BEK,OWASP-XSS}), e.g., backslash-escape, which replaces every 
occurrence of quotes and double-quotes (i.e. \verb+'+ and \verb+"+) in the
string by \verb+\'+ and \verb+\"+. Such string functions, however, cannot
be modelled by 
}
%}

\OMIT{
One main driving force behind this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 
}

\OMIT{
The second thread
is the study of the theory of strings with \emph{rational relations} \cite{??},
i.e., relations that are generated by finite-state input/output transducers
(i.e. relations between the input and the output strings). Rational relations
form a natural class of string operations including the replace-all function
(i.e. replace every occurrence of a substring $v$ in the input string by a
string $w$). 
}

\OMIT{
One main driving force behind 
this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 
}

We have seen  a lot of work on solvers for constraint languages over strings (a.k.a. string solvers). 


$\replaceall$ function is widely used in Javascript programs. In general, the $\replaceall$ function has three parameters, and in the current mainstream language such as Python and JavaScript, all of the three (? or just the first and the third?) parameters can be inserted as variables (with proper types such as strings). As result, when we perform program analysis for, for instance, detecting security vulnerabilities as described as above, one often end up with string constraints with, for instance $z=\replaceall(x,"aa", y)$, meaning that $z$ is obtained by replacing all occurrences of $aa$ in $x$ by $y$. Solving string constraints involving this type of constraints is crucial, but unfortunately, is not supported by the current technique. There are two reasons:
\begin{itemize}
	\item the state of the art approach which is based on transducers \cite{LB16}, when applied to tackle the replaceall function, requires the second and the third parameters to be constant. 
	
	\item for constraint such as $z=repalce(x,a,y)$, one may resort to solving word equations. However, this turns out to be difficult for the $\replaceall$ function.   
\end{itemize}

 

\input{motivation.tex}

\cite{LB16,TCJ16,YABI14}

unrestricted $\replaceall$ function: undecidable, even the third parameter is a constant string

to regain decidability: straight-line constraint

an extensive investigation on straight-line string constraints with $\replaceall$ function. 


The logic chain would be:
\begin{itemize}
	\item string constraints are important;
	\item the replaceall function is extensively used, so solving string constraints with replaceall function is important
	\item the current technique \cite{LB16} can only address replaceall with one variable in parameters, but this is not enough
	\item we carry out a systematic investigation of replaceall when other parameters can be set as variables 
\end{itemize}

\paragraph{Contribution.} We study the decidability of satisfiability over string logics with concatenations and the $\replaceall$ functions. Naively combining these two easily leads to an undecidability logic, hence, our strategy is explore the ``strainght-line" fragment, introduced in \cite{LB16}. 

The fragment can express the program logics of straight-line string manipulating programs with concatenation and $\replaceall$ as atomic operations. Indeed, straight-line programs naturally arise when performing bounded model checking or dynamic symbolic executions. 

We give an algorithm to check the satisfiability of the constraints. The advantages are 
\begin{itemize}
	\item it is an automata-theoretic algorithm, and when the constraints are satisfiable, one can synthesise the solution. 
	
	\item the algorithm admits a modular construction, and easy to implement, even symbolic implementation(???). 
	
	
	\item The algorithm in general requires exponential space, but under a certain reasonable assumption it is actually running in polynomial space. 
\end{itemize}



EXPSPACE algorithm

a table to summarise the results.


\paragraph{Organisation.} 

