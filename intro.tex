%!TEX root = popl2018.tex

\section{Introduction}

The problem of %satisfiability of logical theories over strings
solving string constraints (a.k.a. satisfiability of logical theories over
strings)
is an important automated reasoning problem that has in recent years witnessed
renewed interests %in the programming language and verification community
\cite{Berkeley-JavaScript,TCJ16,LB16,YABI14,S3,Abdulla14,Abdulla17,,DV13,symbolic-transducer,BEK,...} 
because of important applications in the analysis of 
string-manipulating programs. For example,
program analysis techniques like symbolic execution \cite{king76,DART,EXE} 
would
%. For example, program analysis techniques like
%symbolic execution \cite{king76} (or variants like dynamic symbolic execution
%\cite{DART,EXE}) will 
systematically explore executions in a program and collect symbolic path 
constraints, which could then be solved using a constraint solver and
used to determine which location in the program to continue exploring.
To successfully apply a constraint solver in this instance, it is
crucial that the constraint language precisely model the data types in the
program, along with the used string operations. In the context of
string-manipulating programs, the string constraints should be expressive enough
to capture the operations that are used in the programs. This could include 
concatenation, regular expression matching, string-length functions, and
the replace-all functions, among many others.

%For scripting
%languages (e.g. Python, PHP, and JavaScript), which have grown in popularity
%in recent years, numerous string 
%There are several well-established research threads on this satisfiability 
%problem depending on 
%which string operations are permitted in the theory. 
Perhaps the most well-known theory of strings for applications to analysing
string-manipulating programs is the theory of strings with concatenation 
(a.k.a. \emph{word equations}),
whose decidability status was settled positively by Makanin \cite{Makanin}
in 1977 after it was open for many years. More importantly, 
The theory of strings with concatenation remains 
decidable even when regular expression matching is incorporated into the 
language \cite{Schulz}. However, whether adding the string-length function
results preserves the decidability remains a long-standing open problem
\cite{Vijay-length,buchi}.

\OMIT{
which is crucial for such applications as string analysis
for JavaScript applications against cross-site scripting (XSS) vulnerabilities
\cite{Berkeley-JavaScript}, which are typically caused by improper handling
of untrusted strings leading to an execution of malicious script in the
clients' browsers.
}

One main driving force behind this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 

The second thread
is the study of the theory of strings with \emph{rational relations} \cite{??},
i.e., relations that are generated by finite-state input/output transducers
(i.e. relations between the input and the output strings). Rational relations
form a natural class of string operations including the replace-all function
(i.e. replace every occurrence of a substring $v$ in the input string by a
string $w$). 



One main driving force behind 
this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 

We have seen  a lot of work on solvers for constraint languages over strings (a.k.a. string solvers). 


$\replaceall$ function is widely used in Javascript programs. In general, the $\replaceall$ function has three parameters, and in the current mainstream language such as Python and JavaScript, all of the three (? or just the first and the third?) parameters can be inserted as variables (with proper types such as strings). As result, when we perform program analysis for, for instance, detecting security vulnerabilities as described as above, one often end up with string constraints with, for instance $z=\replaceall(x,"aa", y)$, meaning that $z$ is obtained by replacing all occurrences of $aa$ in $x$ by $y$. Solving string constraints involving this type of constraints is crucial, but unfortunately, is not supported by the current technique. There are two reasons:
\begin{itemize}
	\item the state of the art approach which is based on transducers \cite{LB16}, when applied to tackle the replaceall function, requires the second and the third parameters to be constant. 
	
	\item for constraint such as $z=repalce(x,a,y)$, one may resort to solving word equations. However, this turns out to be difficult for the $\replaceall$ function.   
\end{itemize}

 

\input{motivation.tex}

\cite{LB16,TCJ16,YABI14}

unrestricted $\replaceall$ function: undecidable, even the third parameter is a constant string

to regain decidability: straight-line constraint

an extensive investigation on straight-line string constraints with $\replaceall$ function. 


The logic chain would be:
\begin{itemize}
	\item string constraints are important;
	\item the replaceall function is extensively used, so solving string constraints with replaceall function is important
	\item the current technique \cite{LB16} can only address replaceall with one variable in parameters, but this is not enough
	\item we carry out a systematic investigation of replaceall when other parameters can be set as variables 
\end{itemize}

\paragraph{Contribution.} We study the decidability of satisfiability over string logics with concatenations and the $\replaceall$ functions. Naively combining these two easily leads to an undecidability logic, hence, our strategy is explore the ``strainght-line" fragment, introduced in \cite{LB16}. 

The fragment can express the program logics of straight-line string manipulating programs with concatenation and $\replaceall$ as atomic operations. Indeed, straight-line programs naturally arise when performing bounded model checking or dynamic symbolic executions. 

We give an algorithm to check the satisfiability of the constraints. The advantages are 
\begin{itemize}
	\item it is an automata-theoretic algorithm, and when the constraints are satisfiable, one can synthesise the solution. 
	
	\item the algorithm admits a modular construction, and easy to implement, even symbolic implementation(???). 
	
	
	\item The algorithm in general requires exponential space, but under a certain reasonable assumption it is actually running in polynomial space. 
\end{itemize}



EXPSPACE algorithm

a table to summarise the results.


\paragraph{Organisation.} 

