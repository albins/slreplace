%!TEX root = popl2018.tex

\section{Introduction}

The problem of %satisfiability of logical theories over strings
solving string constraints (aka satisfiability of logical theories over
strings)
is an important automated reasoning problem that has in recent years witnessed
renewed interests %in the programming language and verification community
\cite{Berkeley-JavaScript,TCJ16,LB16,YABI14,S3,Abdulla14,Abdulla17,DV13,symbolic-transducer,BEK} 
because of important applications in the analysis of 
string-manipulating programs. For example,
program analysis techniques like symbolic execution \cite{king76,DART,EXE} 
would
%. For example, program analysis techniques like
%symbolic execution \cite{king76} (or variants like dynamic symbolic execution
%\cite{DART,EXE}) will 
systematically explore executions in a program and collect symbolic path 
constraints, which could then be solved using a constraint solver and
used to determine which location in the program to continue exploring.
To successfully apply a constraint solver in this instance, it is
crucial that the constraint language precisely model the data types in the
program, along with the used data-type operations. In the context of
string-manipulating programs, the string constraints should be expressive enough
to capture the operations that are used in the programs. This could include 
concatenation, regular constraints (i.e. pattern matching against a regular
expression), string-length functions, and the string-replace functions, among 
many others.

%For scripting
%languages (e.g. Python, PHP, and JavaScript), which have grown in popularity
%in recent years, numerous string 
%There are several well-established research threads on this satisfiability 
%problem depending on 
%which string operations are permitted in the theory. 
Perhaps the most well-known theory of strings for applications to analysing
string-manipulating programs is the theory of strings with concatenation 
(aka \emph{word equations}),
whose decidability status was settled positively by Makanin \cite{Makanin}
in 1977 after it was open for many years. More importantly, 
the theory of strings with concatenation remains 
decidable even when regular constraints are incorporated into the 
language \cite{Schulz}. However, whether adding the string-length function
results preserves the decidability remains a long-standing open problem
\cite{Vijay-length,buchi}.

%\OMIT{
%which is crucial for 
Another important string operation (especially, in popular scripting
languages like Python, JavaScript, and PHP) is the string-replace function, 
which may be used to replace either the first occurrence or
all occurrences of a string (a string constant/variable, or a regular expression) by 
another string (a string constant/variable). The replace function (especially 
the replace-all functionality) is omnipresent in HTML5 applications, as has
been convincingly argued in \cite{LB16,TCJ16,YABI14}. For
example, a standard industry defense against cross-site scripting 
(XSS) vulnerabilities includes sanitising untrusted strings before adding them
into the DOM (Document Object Model) or the HTML document. 
This is typically done by %replacing every occurrence of
various metacharacter-escaping mechanisms (e.g. see 
\cite{Kern14,BEK,OWASP-XSS}), e.g., backslash-escape, which replaces \emph{every
occurrence} of quotes and double-quotes (i.e. \verb+'+ and \verb+"+) in the
string by \verb+\'+ and \verb+\"+. 
In addition
to sanitisers, common JavaScript functionalities like \texttt{document.write()} 
and \texttt{innerHTML} apply an \emph{implicit browser transduction} --- which
decodes HTML codes (e.g. \verb+&#39;+ is replaced by \verb+'+) in the input 
string --- before inserting the input string into the DOM.
Both of these examples can be expressed by (perhaps multiple) 
applications of the string-replace function.


%Concatenation: 8\%
%Replace-all: 8\%

In general, the string-replace function has three parameters, and in the current mainstream language such as Python and JavaScript, all of the three parameters can be inserted as string variables. As result, when we perform program analysis for, for instance, detecting security vulnerabilities as described as above, one often end up with the string constraints of the form $z= \replaceall(x, p, y)$, where $x,y$ are string constants/variables, and $p$ is either a string constant/variable, or a regular expression, meaning that $z$ is obtained by replacing all occurrences of $p$ in $x$ by $y$. For convenience, we call $x, p, y$ as the subject, the pattern, and the replacement parameters respectively. 

%for instance $z=\replaceall(x,"aa", y)$, meaning that $z$ is obtained by replacing all occurrences of $aa$ in $x$ by $y$. Solving string constraints involving this type of constraints is crucial, but unfortunately, is not supported by the current technique. There are two reasons:

%The string-replace function is formalised as $\replaceall(x, p, y)$, where $x,y$ are string constants/variables, and $p$ is either a string constant/variable, or a regular expression. The semantics of $\replaceall(x, p, y)$ is to replace all occurrences of $p$ in $x$ with $y$. For convenience, we call $x, p, y$ as the subject, the pattern, and the replacement parameters respectively. 

%The string-replace function is a quite powerful string operation. To see this, let us consider the constraint $C \equiv z = \replaceall(x, 0, y) \wedge x \in (01)^* \wedge y \in 0^*$. Then the set of values of $z$ that make $C$ satisfied is $\{(0^n 1)^* \mid n \in \Nat \}$.


The $\replaceall$ function is a powerful string operation that goes beyond the expressiveness of concatenation. As a matter of fact, it was shown in~\cite{LB16} that incorporating the simple form of the $\replaceall$ function, where the pattern and the replacement are both string constants, into the theory of concatenations already results in an undecidable theory of strings.  
%that lies beyond 
%the expressiveness of the theory of concatenation, 
Therefore, it is challenging to reason about the string-replace function in its general form. 
%In~\cite{LB16}, a theory of strings involving concatenation and finite state transducers was considered. The $\replaceall$ function where the pattern is a string constant or regular expression, the third parameter is a constant can be seen as a special case of finite state transducers. It was shown therein that incorporating the simple form of the $\replaceall$ function into the theory of concatenations already results in an undecidable theory of strings. 
A partial result can be deduced from the results in~\cite{LB16}: For the theory of strings involving the concatenation, the regular constraints, and the $\replaceall$ function where the pattern and the replacement are both string constants, if a straight-line restriction is put on the formulas, then the decidability can be regained. The decision procedure therein was obtained for finite-state transducers, which subsume the aforementioned special form of the $\replaceall$ function.  The straight-line restriction is natural in the sense that it reflects the shape of formulas typically generated by symbolic execution.
Nevertheless, it is still an open question about the decidability boundary of the straight-line fragment of the string constraints involving the $\replaceall$ function in this general form, e.g. when the replacement parameter is a variable.

The general forms of the $\replaceall$ function, in particular, the forms of the $\replaceall$ function where the replacement parameter is a variable, are widely used in the programs from the practice.  


Example here XXXX



\OMIT{
Such string functions, however, cannot
be modelled by 
%}


Such a function is frequently used in 

%especially the way it is used to replace \emph{all} occurrences


One important application %of string solving 
for the analysis of string-manipulating programs is an automatic detection
%for JavaScript applications 
of cross-site scripting (XSS) vulnerabilities
\cite{Berkeley-JavaScript}, which are typically caused by improper handling
of untrusted strings leading to an execution of malicious script in the
clients' browsers. A standard industry defense against XSS is to sanitise these
untrusted strings before adding them into the DOM (Document Object Model) or 
the HTML document. This is typically done by %replacing every occurrence of
certain metacharacter-escaping mechanisms (e.g. see 
\cite{Kern14,BEK,OWASP-XSS}), e.g., backslash-escape, which replaces every 
occurrence of quotes and double-quotes (i.e. \verb+'+ and \verb+"+) in the
string by \verb+\'+ and \verb+\"+. Such string functions, however, cannot
be modelled by 
}
%}

\OMIT{
One main driving force behind this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 
}

\OMIT{
The second thread
is the study of the theory of strings with \emph{rational relations} \cite{??},
i.e., relations that are generated by finite-state input/output transducers
(i.e. relations between the input and the output strings). Rational relations
form a natural class of string operations including the replace-all function
(i.e. replace every occurrence of a substring $v$ in the input string by a
string $w$). 
}

\OMIT{
One main driving force behind 
this research direction is the application to analysis of security vulnerability
in web applications against cross-site scripting (XSS) and code injections 
\cite{??}, which 
are typically caused by improper handling of untrusted strings by the web 
applications, e.g., leading to an execution of malicious JavaScript in the 
clients' browsers. 
}



\hide{
We have seen  a lot of work on solvers for constraint languages over strings (a.k.a. string solvers). 

$\replaceall$ function is widely used in Javascript programs. In general, the $\replaceall$ function has three parameters, and in the current mainstream language such as Python and JavaScript, all of the three (? or just the first and the third?) parameters can be inserted as variables (with proper types such as strings). As result, when we perform program analysis for, for instance, detecting security vulnerabilities as described as above, one often end up with string constraints with, for instance $z=\replaceall(x,"aa", y)$, meaning that $z$ is obtained by replacing all occurrences of $aa$ in $x$ by $y$. Solving string constraints involving this type of constraints is crucial, but unfortunately, is not supported by the current technique. There are two reasons:
\begin{itemize}
	\item the state of the art approach which is based on transducers \cite{LB16}, when applied to tackle the replaceall function, requires the second and the third parameters to be constant. 
	
	\item for constraint such as $z=repalce(x,a,y)$, one may resort to solving word equations. However, this turns out to be difficult for the $\replaceall$ function.   
\end{itemize}
}


%\input{motivation.tex}

%\cite{LB16,TCJ16,YABI14}

%unrestricted $\replaceall$ function: undecidable, even the third parameter is a constant string
%
%to regain decidability: straight-line constraint
%
%an extensive investigation on straight-line string constraints with $\replaceall$ function. 


%The logic chain would be:
%\begin{itemize}
%	\item string constraints are important;
%	\item the replaceall function is extensively used, so solving string constraints with replaceall function is important
%	\item the current technique \cite{LB16} can only address replaceall with one variable in parameters, but this is not enough
%	\item we carry out a systematic investigation of replaceall when other parameters can be set as variables 
%\end{itemize}

\paragraph{Contribution.} We investigate the decidability boundary of the theory of strings involving the concatenation, regular constraints, and the $\replaceall$ function, with the straight-line constraint introduced in \cite{LB16}. 

We first show that with the $\replaceall$ function in its general form, the concatenation operation is in fact \emph{redundant}, in the sense that they can be simulated by the $\replaceall$ function. This motivates to consider a theory of strings where the $\replaceall$ function, instead of the concatenation operation, and the regular constraints, are the basic modalities. We focus on the straight-line fragment of this theory of strings, denoted by $\strline[\replaceall]$.

We obtain the following results for the satisfiability problem of $\strline[\replaceall]$.
\begin{itemize}
\item If the pattern parameters of the $\replaceall$ function are allowed to be variables, then the satisfiability of $\strline[\replaceall]$ is undecidable (cf. Proposition~\ref{prop-und-pat-var}).
%
\item If the pattern parameters of the $\replaceall$ function are regular expressions, then the satisfiability of $\strline[\replaceall]$ is decidable and in EXPSPACE (cf. Theorem~\ref{thm-main}). In addition, we show that the satisfiability problem is PSPACE-complete for several cases that are meaningful in practice (cf. Corollary~\ref{cor-pspace}).
%
\item If $\strline[\replaceall]$, where the pattern parameters of the $\replaceall$ function are regular expressions, is extended with any of integer constraints, character constraints, or constraints involving the $\indexof$ function, then the satisfiability becomes undecidable again (cf. Theorem~\ref{thm-ext-int} and  Proposition~\ref{prop-ext-char}-\ref{prop-indexof}).
\end{itemize}

Our decision procedure for $\strline[\replaceall]$ where the pattern parameters of the $\replaceall$ function are regular expressions, follows the automata-theoretical approach. The key idea is explained as follows: Let us consider the simple formula $C \equiv x = \replaceall(y, a, z) \wedge x \in e_1 \wedge y \in e_2 \wedge z \in e_3$. 
Suppose that $\cA_1,\cA_2,\cA_3$ are the nondeterministic finite state automata corresponding to $e_1,e_2,e_3$ respectively. 
We nondeterministically generate from $\cA_1$ a new regular constraint $\cA'_2$ for $y$, and $\cA'_3$ for $z$ respectively. Then the satisfiability of $C$ is turned into testing the nonemptiness of the intersection of $\cA_2$ and $\cA'_2$, as well as the nonemptiness of the intersection of $\cA_3$ and $\cA'_3$. When there are multiple occurrences of the $\replaceall$ function, this process can be iterated. 
Our decision procedure enjoys the following advantages:
\begin{itemize}
	\item it is automata-theoretic and built on a neat automata construction, moreover, when the formula is satisfiable, a solution can be synthesised, 
	
	\item the decision procedure is modular and amenable to implementation,  in the sense that the $\replaceall$ terms are removed one by one to generate more and more regular constraints,
	
	\item the decision procedure requires exponential space, but for the cases that are meaningful in practice, the decision procedure uses only polynomial space. 
\end{itemize}

%EXPSPACE algorithm
%
%a table to summarise the results.


\paragraph{Organisation.} 
This paper is organised as follows: Preliminaries are given in Section~\ref{sec-prel}. The core string language is defined in Section~\ref{sec-core}. The main results of this paper are summarised in Section~\ref{sec-sat}. The decision procedure is presented in Section~\ref{sec:replaceallsl}-\ref{sec:replaceallre}, case by case. The extensions of the core string language are investigated in Section~\ref{sec-ext}. The related work can be found in Section~\ref{sec-rel}.
