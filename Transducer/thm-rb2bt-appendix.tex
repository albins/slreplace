%!TEX root = main.tex
\newcommand\init{\mathsf{init}}
\newcommand\mkright{\mathsf{markright}}
\newcommand\mkleft{\mathsf{markleft}}
\newcommand\finalpass{\mathsf{finalpass}}
\newcommand\reverse{\mathsf{reverse}}
\newcommand\concatpt{\mathsf{concat}}
\newcommand\symof[1]{\overline{#1}}

\section{Proofs in Section~\ref{subsec:krb} }\label{app-rb-2pt}


%=========================================================
%=========================================================
\hide{
\subsection{Proof of Proposition~\ref{prop-sweep-rb}: Reversal bound for \SPPT{}s}

Suppose $\Transducer=(\controls, X, q_0, \finals, \transrel)$ is a \emph{functional} \SPPT{}  with $X= \{x_1,\ldots, x_\arity\}$, and $(w, w', w_1,\ldots, w_\arity) \in \transet(\Transducer)$. 

Then there is an accepting run of $\Transducer$ on $w$, equipped with $w_1,\ldots, w_\arity$, with the output $w'$. 
Let $w = a_1 \ldots a_n$. In addition, let $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$. 
Then for each $i \in [0, n+1]$, let $\vec{\rho}_i$ denote the sequence of states of the run when the reading head is in in position $i$.

We apply the following reduction to the accepting run until no more reduction can be done. 

Let $\rho_0 = (q_1, \ldots, q_{2m+1})$. If $q_i = q_j$ for some $i < j$, then it must be the case that each transition in the subrun between $q_i$ and $q_j$ outputs $\epsilon$. Because otherwise, the subrun produces a nonempty output and we can repeat the subrun one more time and produces a different output than $w'$. This would contradict to the fact that $\Transducer$ is functional. Therefore, we can remove the subrun between $q_i$ and $q_j$, with the state $q_i$ remained, and get a shorter accepting run of $\Transducer$ on $w$, equipped with $w_1,\ldots, w_\arity$, with the same output $w'$.
We can apply similar reductions to $\rho_{n+1}$.

In the end, we get an accepting run of $\Transducer$ on $w$, equipped with $w_1,\ldots, w_\arity$, with the same output $w'$, where all the states in $\vec{\rho}_0$ (resp. $\vec{\rho}_{n+1}$) are mutually distinct. Then $|\vec{\rho}_0|, |\vec{\rho}_{n+1}| \le |\controls|$ and the accepting run contains at most $2|\controls|-2$ reversals (there is no reversal for the first state of $\vec{\rho}_0$ and the last state of $\vec{\rho}_{n+1}$). 


\subsection{Proof of Proposition~\ref{prop:trans}: Translation from \SPPT{}s to \PT{}s and $\Transducer_{\sf reverse}$}

%================= theorem ====================================
%Any symbolic execution $S$ where string functions are given by \SPPT{}s can be translated to $S'$ where string functions are given by \PT{}s and $\Transducer_{\sf reverse}$, and $ \rcdep(S')\in \mathcal{O}(\rcphi(S) \cdot \rcdep(S))$. 
%
%Intuitively, by Proposition~\ref{prop-sweep-rb}, a run of an \SPPT{} $\Transducer$ can be split into $2n-1$ subruns (where $n$ is the number of  states of $\Transducer$), each travelling in a single direction.
%We can simulate the subruns with $2n-1$ one-way \PT{}s whose outputs are concatenated.
%Right-to-left subruns are simulated left-to-right, and thus the output must be reversed before concatenation.

%==============================================================



%We compute the pre-image of a $k$-\RBPPT{}s and show
%$\ell(|\Transducer|, |\Aut|) = C|\Transducer||\Aut|$
%for some constant $C$.
%%
%Let
%$y := \Transducer(x)$
%be an assignment statement in $S$ such that
%$\Transducer = (\controls, q_0, \finals, \transrel)$
%is $(2k)$-reversal bounded for some $k > 0$.
%%
%For this we will first implement
%$y := \Transducer(x)$
%using a program that only has one-way transducers -- which may not be
%functional -- and the function $\reverse$.
%%
%We will then argue that we can apply the generic decision procedure and still
%obtain a correct pre-image computation.
%%
%For this we rely on the complete program being functional (since $\Transducer$
%is), even if individual components are not.

\subsubsection{Handling Parameters.}
For simplicity, we will assume $\Transducer$ has no parameters.
%
In the general case, we can always reduce
$y := \Transducer(x, x_1, \ldots, x_n)$
to
\[
    \begin{array}{rcl}
        y_0 &:=& \Transducer'(x); \\
        y_1 &:=& \replaceall(\symof{x_1}, y_0, x_1); \\
            &\vdots& \\
        y_n &:=& \replaceall(\symof{x_n}, y_{n-1}, x_n);
    \end{array}
\]
where $\Transducer'$ simply outputs a special symbol $\symof{x_i}$ in place of
the contents of a variable $x_i$.

\subsubsection{Program Encoding.}

As mentioned before, each accepting run of $\Transducer$ on an input string can be split into $2n-2$
subruns without reversals (notice that for sweeping transducers,  the turning points are always the ends of the tape).
%
Intuitively, we shall split $y$ into $2n-2$ substrings, corresponding to the
$2n-2$ maximal subruns, and for each substring of $y$, use one \PT{} and the
reverse function to produce it. To avoid clutter, we let $k=n-1$. 



For preparation, we introduce the following \FT{}s:
$\init$,
$\mkleft$,
$\mkright$,
%$\finalpass$,
$\reverse$,
$\concatpt$.
These \FT{}s behave as follows.
\begin{itemize}
	\item
	$\init$ begins by outputting $q_0$ and then directly copying its input to
	the output tape, and then nondeterministically  outputs some $q\in \controls$. 
	
	\item
	$\mkright$ copies the input, except for the last cell, to the output tape and then nondeterministically  outputs some $q\in \controls$.  
	
	
%	marks the beginning and end of a forwards run of $\Transducer$ with states from $\controls$,
%	assuming that an initial or backwards marking has already taken place (that
%	is, either one or two states from $\controls$ appear in the end of the input).
%	%
%	It directly copies its input to the output tape until it the first instance
%	of some
%	$q \in \controls$.
%	%
%	This $q$ is also outputted.
%	%
%	After this, it will copy the rest of the input tape to the output tape with
%	the exception that any occurrence of a state from $\controls$ is not copied
%	(erased).
%	%
%	At some point during this second phase it will non-deterministically output
%	a single
%	$q' \in \controls$
%	between the copies of two input characters and then continue to copy its
%	input to the output until the end of the tape (ignoring any $\controls$).
%	
	\item
	$\mkleft$ reads the first cell of the tape (which is supposed to be some $q\in \controls$), nondeterministically replaces it with some $q\in \controls$, and copies the rest of input to the output tape. 
%	$\suffix$ marks the end and beginning of a backwards run assuming $\prefix$
%	has previously marked the beginning and end of the preceding forwards run.
%	%
%	It will do this by copying the input tape directly to the output tape,
%	omitting the first instance of $\controls$.
%	%
%	Additionally, before the second occurrence of some $\controls$ it will
%	non-deterministically output some single $q \in \controls$ between the
%	copies of two input characters.
%	%
%	On encountering the second instance of $\controls$ it will copy this and
%	continue to copy the remainder of the tape.
%	
%	\item
%	$\finalpass$ behaves as prefix, but instead of non-deterministically
%	choosing a position to output some
%	$q \in \controls$
%	it will output some accepting $q$ after all input has been copied.
%	%
%	Note, it will still copy the first instance of some $\controls$ to the
%	output tape.
%	
	\item
	$\reverse$ reverses its input string.
	
	\item
	$\concatpt$ concatenates its arguments.
\end{itemize}
%
We illustrate the use of these \FT{}s with an example.  Let the input word be
$a b c a b c$
and consider the program below.
%
To the left of the program we give the output of an example run with the input
$x = a b c a b c$.
%%
\[
\begin{array}{rcll}
x_0 &:=& \init(x);
& \qquad (x_0 = q_0\ a\ b\ c\ a\ b\ c\ q_1) \\
x_1 &:=& \mkleft(x_0);
& \qquad (x_1 = q_2\ a\ b\ c\ a\ b\ c\ q_1) \\
x_2 &:=& \mkright(x_1);
& \qquad (x_2 = q_2\ a\ b\ c\ a\ b\ c\ q_3) \\
x_3 &:=& \mkleft(x_2);
& \qquad (x_3 = q_4\ a\ b\ c\ a\ b\ c\ q_3) \\
%x_4 &:=& \suffix(x_3);
%& \qquad (x_4 = a\ b\ c\ a\ q_4\ b\ q_3\ c) \\
%x_5 &:=& \finalpass(x_4)
%& \qquad (x_5 = a\ b\ c\ a\ q_4\ b\ c\ q_5) \\
\end{array}
\]
%%
The values of
$x_0, \ldots, x_5$
correspond to a $4$-reversal run of $\Transducer$.
%%
%Beginning at $q_0$ we first read $abca$ and reach $q_1$; here we reverse
%direction and read $ac$ to reach $q_2$; next we reverse direction again and
%read $c a b$ to reach $q_3$; after another reversal $b$ is read and the state
%$q_4$ is reached; finally, $bc$ is read and $q_5$ is reached at the end of the
%tape.

We define $\Transducer_f$ and $\Transducer_b$ which simulate a
single-direction run of $\Transducer$ between the two instances of $\controls$
in the forwards or backwards direction.
%
That is
\begin{itemize}
	\item
	$\Transducer_f$.  %(from the beginning of the input tape) skips over all
	%characters until the first instance of $\controls$ is found.
	%
	Let the first cell be $q$.
	%
	$\Transducer_f$ starts simulating $\Transducer$ in the left-to-right direction
	starting from $q$.
	%
	That is, it can only simulate moves of the form
	$(q, a, d, q', b)$
	where
	$d \in \{\Stay, \Right\}$.
	%
	Any output is written to the output tape.
	%
	This simulation continues until end of tape where $\Transducer_f$ reads  
	$q' \in \controls$.
	%
	It accepts only if the simulation has also reached $q'$.
	
	\item
	$\Transducer_b$. %(from the beginning of the input tape) skips over all
	%characters until the first instance of $\controls$ is found.
	%
	Let this first cell be $q$.
	%
    $\Transducer_b$  starts simulating a right-to-left run of $\Transducer$ for a run
	that would end at $q$.
	%
	To do this it has to perform moves \emph{in reverse};
	that is, for moves of $\Transducer$ of the form
	$(q, a, d, q', b)$
	where
	$d \in \{\Left, \Stay\}$
	the transducer $\Transducer_b$ can simulate
	$(q', a, d^{-1}, q, b)$
	where
	$(\Left)^{-1} = \Right$
	and
	$(\Stay)^{-1} = \Stay$.
	%
	Any output is written to the output tape.
	%
	This simulation continues until the end of tape where $\Transducer_b$ reads 
	$q' \in \controls$
	and accepts only if the simulation has also reached $q'$.
\end{itemize}

%We can now apply $\Transducer_f$ to the output of each use of $\prefix$ or
%$\finalpass$ and $\Transducer_b$ to the output of each use of $\suffix$.
%%
Since $\Transducer_b$ performs its simulation in reverse, we need to apply
$\reverse$ to its output.
%
Then, we concatenate all outputs to obtain $y$.
%
Thus, the output $y$ of the following program $S$ on an input $x$ is the same
as
$y := \Transducer(x)$
when $\Transducer$ performs $2k$ reversals.
\[
\begin{array}{rcl}
x_0 &:=& \init(x); \\
x_1 &:=& \mkleft(x_0); \\
x_2 &:=& \mkright(x_1); \\
&\vdots& \\
x_{2k-1} &:=& \mkleft(x_{2k-2}); \\
%x_{2n} &:=& \mkright(x_{2n-1}); \\
%x_{2k+1} &:=& \finalpass(x_{2k}); \\
\\
y_0 &:=& \Transducer_f(x_0); \\
y'_1 &:=& \Transducer_b(x_1); \\
y_1 &:=& \reverse(y'_1); \\
&\vdots& \\
y_{2k-2} &:=& \Transducer_f(x_{2k-2}); \\
y'_{2k-1} &:=& \Transducer_b(x_{2k-1}); \\
y_{2k-1} &:=& \reverse(y'_{2k-1}); \\
%y_{2k-1} &:=& \Transducer_f(x_{2k+1}); \\
\\
y &:=& \concatpt(y_0, \ldots, y_{2k-1})
\end{array}
\]
}
%=========================================================
%=========================================================

%
%
%Each accepting run of $\Transducer$ on an input string can be split into $2k+1$
%maximal subruns without reversals (i.e.\ split the run at the turning points).
%%
%Intuitively, we shall split $y$ into $2k+1$ substrings, corresponding to the
%$2k+1$ maximal subruns, and for each substring of $y$, use one \PT{} and the
%reverse function to produce it.
%
%
%For preparation, we introduce the following \FT{}s:
%    $\init$,
%    $\prefix$,
%    $\suffix$,
%    $\finalpass$,
%    $\reverse$,
%    $\concatpt$.
%These \FT{}s behave as follows.
%\begin{itemize}
%\item
%    $\init$ begins by outputting $q_0$ and then directly copying its input to
%    the output tape.
%
%\item
%    $\prefix$ marks the beginning and end of a forwards run of $\Transducer$,
%    assuming that an initial or backwards marking has already taken place (that
%    is, either one or two states from $\controls$ appear in the input).
%    %
%    It directly copies its input to the output tape until it the first instance
%    of some
%    $q \in \controls$.
%    %
%    This $q$ is also output.
%    %
%    After this, it will copy the rest of the input tape to the output tape with
%    the exception that any occurrence of a state from $\controls$ is not copied
%    (erased).
%    %
%    At some point during this second phase it will non-deterministically output
%    a single
%    $q' \in \controls$
%    between the copies of two input characters and then continue to copy its
%    input to the output until the end of the tape (ignoring any $\controls$).
%
%\item
%    $\suffix$ marks the end and beginning of a backwards run assuming $\prefix$
%    has previously marked the beginning and end of the preceding forwards run.
%    %
%    It will do this by copying the input tape directly to the output tape,
%    omitting the first instance of $\controls$.
%    %
%    Additionally, before the second occurrence of some $\controls$ it will
%    non-deterministically output some single $q \in \controls$ between the
%    copies of two input characters.
%    %
%    On encountering the second instance of $\controls$ it will copy this and
%    continue to copy the remainder of the tape.
%
%\item
%    $\finalpass$ behaves as prefix, but instead of non-deterministically
%    choosing a position to output some
%    $q \in \controls$
%    it will output some accepting $q$ after all input has been copied.
%    %
%    Note, it will still copy the first instance of some $\controls$ to the
%    output tape.
%
%\item
%    $\reverse$ reverses its input string.
%
%\item
%    $\concatpt$ concatenates its arguments.
%\end{itemize}
%
%We illustrate the use of these \FT{}s with an example.  Let the input word be
%$a b c a b c$
%and consider the program below.
%%
%To the left of the program we give the output of an example run with the input
%$x = a b c a b c$.
%%
%\[
%    \begin{array}{rcll}
%        x_0 &:=& \init(x);
%            & \qquad (x_0 = q_0\ a\ b\ c\ a\ b\ c) \\
%        x_1 &:=& \prefix(x_0);
%            & \qquad (x_1 = q_0\ a\ b\ c\ a\ q_1\ b\ c) \\
%        x_2 &:=& \suffix(x_1);
%            & \qquad (x_2 = a\ b\ q_2\ c\ a\ q_1\ b\ c) \\
%        x_3 &:=& \prefix(x_2);
%            & \qquad (x_3 = a\ b\ q_2\ c\ a\ b\ q_3\ c) \\
%        x_4 &:=& \suffix(x_3);
%            & \qquad (x_4 = a\ b\ c\ a\ q_4\ b\ q_3\ c) \\
%        x_5 &:=& \finalpass(x_4)
%            & \qquad (x_5 = a\ b\ c\ a\ q_4\ b\ c\ q_5) \\
%    \end{array}
%\]
%%
%The values of
%$x_0, \ldots, x_5$
%correspond to a $4$-reversal run of $\Transducer$.
%%
%Beginning at $q_0$ we first read $abca$ and reach $q_1$; here we reverse
%direction and read $ac$ to reach $q_2$; next we reverse direction again and
%read $c a b$ to reach $q_3$; after another reversal $b$ is read and the state
%$q_4$ is reached; finally, $bc$ is read and $q_5$ is reached at the end of the
%tape.
%
%We now define $\Transducer_f$ and $\Transducer_b$ which simulate a
%single-direction run of $\Transducer$ between the two instances of $\controls$
%in the forwards or backwards direction.
%%
%That is
%\begin{itemize}
%\item
%    $\Transducer_f$ (from the beginning of the input tape) skips over all
%    characters until the first instance of $\controls$ is found.
%    %
%    Let this first instance be $q$.
%    %
%    It then starts simulating $\Transducer$ in the left-to-right direction
%    starting from $q$.
%    %
%    That is, it can only simulate moves of the form
%    $(q, a, d, q', b)$
%    where
%    $d \in \{\Stay, \Right\}$.
%    %
%    Any output is written to the output tape.
%    %
%    This simulation continues until $\Transducer_f$ reads some
%    $q' \in \controls$.
%    %
%    It accepts only if the simulation has also reached $q'$.
%
%\item
%    $\Transducer_b$ (from the beginning of the input tape) skips over all
%    characters until the first instance of $\controls$ is found.
%    %
%    Let this first instance be $q$.
%    %
%    It then starts simulating a right-to-left run of $\Transducer$ for a run
%    that would end at $q$.
%    %
%    To do this it has to perform moves \emph{in reverse};
%    that is, for moves of $\Transducer$ of the form
%    $(q, a, d, q', b)$
%    where
%    $d \in \{\Left, \Stay\}$
%    the transducer $\Transducer_b$ can simulate
%    $(q', a, d^{-1}, q, b)$
%    where
%        $(\Left)^{-1} = \Right$
%        and
%        $(\Stay)^{-1} = \Stay$.
%    %
%    Any output is written to the output tape.
%    %
%    This simulation continues until $\Transducer_b$ reads some
%    $q' \in \controls$
%    and accepts only if the simulation has also reached $q'$.
%\end{itemize}
%
%We can now apply $\Transducer_f$ to the output of each use of $\prefix$ or
%$\finalpass$ and $\Transducer_b$ to the output of each use of $\suffix$.
%%
%Since $\Transducer_b$ performs its simulation in reverse, we need to apply
%$\reverse$ to its output.
%%
%Then, we concatenate all outputs to obtain $y$.
%%
%Thus, the output $y$ of the following program $S$ on an input $x$ is the same
%as
%$y := \Transducer(x)$
%when $\Transducer$ performs $2k$ reversals.
%\[
%    \begin{array}{rcl}
%        x_0 &:=& \init(x); \\
%        x_1 &:=& \prefix(x_0); \\
%        x_2 &:=& \suffix(x_1); \\
%        &\vdots& \\
%        x_{2k-1} &:=& \prefix(x_{2k-2}); \\
%        x_{2k} &:=& \suffix(x_{2k-1}); \\
%        x_{2k+1} &:=& \finalpass(x_{2k}); \\
%        \\
%        y_1 &:=& \Transducer_f(x_1); \\
%        y'_2 &:=& \Transducer_b(x_2); \\
%        y_2 &:=& \reverse(y'_2); \\
%        &\vdots& \\
%        y_{2k-1} &:=& \Transducer_f(x_{2k-1}); \\
%        y'_{2k} &:=& \Transducer_b(x_{2k}); \\
%        y_{2k} &:=& \reverse(y'_{2k}); \\
%        y_{2k+1} &:=& \Transducer_f(x_{2k+1}); \\
%        \\
%        y &:=& \concatpt(y_1, \ldots, y_{2k+1})
%    \end{array}
%\]

%===============================================================

%Proposition~\ref{prop:trans} is shown in
%\shortlong{the full version}{Appendix~\ref{app-rb-2pt}}.
%Intuitively, a run of a $k$-\RBPPT{} can be split into $k$ runs, each travelling in a single direction.
%We simulate the runs with $k$ one-way \PT{}s whose outputs are concatenated.
%Right-to-left runs are simulated left-to-right, and thus the output must be reversed before concatenation.



\subsection{Proof of Corollary~\ref{cor-s2pt}}
%
%The path feasibility of string constraints with \FT{}s, replaceall, concatenation, and reverse is $\expspace$-complete.
\begin{proof}
We first notice that, by Lemma~\ref{lem-rb2pt}, since \FT{}s are corresponding to 0-\RBPPT{}s, they satisfy the regularity condition \prerec{} with  $\ell(|\Transducer|, |\Aut|) = |\Transducer||\Aut|$. It is also easy to observe that concatenation and reverse satisfy  \prerec{} with  $\ell_{\sf conc}(|\Aut|) = \bigO(|\Aut|)$, and $\ell_{\sf reverse}(|\Aut|) = \bigO(|\Aut|)$. By Theorem~\ref{thm-generic-dec}, the decision procedure requires exponential space. 

For replaceall  $\replaceall_{p}(sub, rep)$ where $p$ is a fixed regular expression, we notice that, by Proposition~\ref{prop-replace-pt}, the transducer $\Transducer_p$ modelling this function is of exponential size in that of $p$, i.e., $|\Transducer_p| \in 2^{\bigO(|p|^c)}$ for some constant $c > 0$. By Theorem~\ref{thm-generic-dec}, the decision procedure requires
$$\bigO(|\Transducer_p|^{\rcdep(S)} \rcpsi(S)^{\rcdep(S)}) \in 2^{\bigO(\rcdep(S) |p|^{c})} (\rcpsi(S))^{\rcdep(S)}$$ 
space, which is still exponential.  
%
%
%	$$(\rcdim(S)+1)^{\rcdep(S)}  \rcasrt(S) \left(\ell^{\langle \rcdep(S)
%	\rangle}(\rcphi(S), \rcpsi(S)) \right)^{O(1)}$$
\end{proof}



%\section{Proof of Theorem~\ref{thm-rb-2pt}: $k$-\RBPPT{} is in EXPSPACE}\label{app-rb-2pt}






\hide{
We compute the pre-image of a $k$-\RBPPT{}s and show
$\ell(|\Transducer|, |\Aut|) = C|\Transducer||\Aut|$
for some constant $C$.
%
Let
$y := \Transducer(x)$
be an assignment statement in $S$ such that
$\Transducer = (\controls, q_0, \finals, \transrel)$
is $(2k)$-reversal bounded for some $k > 0$.
%
For this we will first implement
$y := \Transducer(x)$
using a program that only has one-way transducers -- which may not be
functional -- and the function $\reverse$.
%
We will then argue that we can apply the generic decision procedure and still
obtain a correct pre-image computation.
%
For this we rely on the complete program being functional (since $\Transducer$
is), even if individual components are not.

\subsection{Handling Parameters}

For simplicity, we will assume $\Transducer$ has no parameters.
%
In the general case, we can always reduce
$y := \Transducer(x, x_1, \ldots, x_n)$
to
\[
    \begin{array}{rcl}
        y_0 &:=& \Transducer'(x); \\
        y_1 &:=& \replaceall(\symof{x_1}, y_0, x_1); \\
            &\vdots& \\
        y_n &:=& \replaceall(\symof{x_n}, y_{n-1}, x_n);
    \end{array}
\]
where $\Transducer'$ simply outputs a special symbol $\symof{x_i}$ in place of
the contents of a variable $x_i$.

\subsection{Program Encoding}

Each accepting run of $\Transducer$ on an input string can be split into $2k+1$
maximal subruns without reversals (i.e.\ split the run at the turning points).
%
Intuitively, we shall split $y$ into $2k+1$ substrings, corresponding to the
$2k+1$ maximal subruns, and for each substring of $y$, use one \PT{} and the
reverse function to produce it.


For preparation, we introduce the following \FT{}s:
    $\init$,
    $\prefix$,
    $\suffix$,
    $\finalpass$,
    $\reverse$,
    $\concatpt$.
These \FT{}s behave as follows.
\begin{itemize}
\item
    $\init$ begins by outputting $q_0$ and then directly copying its input to
    the output tape.

\item
    $\prefix$ marks the beginning and end of a forwards run of $\Transducer$,
    assuming that an initial or backwards marking has already taken place (that
    is, either one or two states from $\controls$ appear in the input).
    %
    It directly copies its input to the output tape until it the first instance
    of some
    $q \in \controls$.
    %
    This $q$ is also output.
    %
    After this, it will copy the rest of the input tape to the output tape with
    the exception that any occurrence of a state from $\controls$ is not copied
    (erased).
    %
    At some point during this second phase it will non-deterministically output
    a single
    $q' \in \controls$
    between the copies of two input characters and then continue to copy its
    input to the output until the end of the tape (ignoring any $\controls$).

\item
    $\suffix$ marks the end and beginning of a backwards run assuming $\prefix$
    has previously marked the beginning and end of the preceding forwards run.
    %
    It will do this by copying the input tape directly to the output tape,
    omitting the first instance of $\controls$.
    %
    Additionally, before the second occurrence of some $\controls$ it will
    non-deterministically output some single $q \in \controls$ between the
    copies of two input characters.
    %
    On encountering the second instance of $\controls$ it will copy this and
    continue to copy the remainder of the tape.

\item
    $\finalpass$ behaves as prefix, but instead of non-deterministically
    choosing a position to output some
    $q \in \controls$
    it will output some accepting $q$ after all input has been copied.
    %
    Note, it will still copy the first instance of some $\controls$ to the
    output tape.

\item
    $\reverse$ reverses its input string.

\item
    $\concatpt$ concatenates its arguments.
\end{itemize}

We illustrate the use of these \FT{}s with an example.  Let the input word be
$a b c a b c$
and consider the program below.
%
To the left of the program we give the output of an example run with the input
$x = a b c a b c$.
%
\[
    \begin{array}{rcll}
        x_0 &:=& \init(x);
            & \qquad (x_0 = q_0\ a\ b\ c\ a\ b\ c) \\
        x_1 &:=& \prefix(x_0);
            & \qquad (x_1 = q_0\ a\ b\ c\ a\ q_1\ b\ c) \\
        x_2 &:=& \suffix(x_1);
            & \qquad (x_2 = a\ b\ q_2\ c\ a\ q_1\ b\ c) \\
        x_3 &:=& \prefix(x_2);
            & \qquad (x_3 = a\ b\ q_2\ c\ a\ b\ q_3\ c) \\
        x_4 &:=& \suffix(x_3);
            & \qquad (x_4 = a\ b\ c\ a\ q_4\ b\ q_3\ c) \\
        x_5 &:=& \finalpass(x_4)
            & \qquad (x_5 = a\ b\ c\ a\ q_4\ b\ c\ q_5) \\
    \end{array}
\]
%
The values of
$x_0, \ldots, x_5$
correspond to a $4$-reversal run of $\Transducer$.
%
Beginning at $q_0$ we first read $abca$ and reach $q_1$; here we reverse
direction and read $ac$ to reach $q_2$; next we reverse direction again and
read $c a b$ to reach $q_3$; after another reversal $b$ is read and the state
$q_4$ is reached; finally, $bc$ is read and $q_5$ is reached at the end of the
tape.

We now define $\Transducer_f$ and $\Transducer_b$ which simulate a
single-direction run of $\Transducer$ between the two instances of $\controls$
in the forwards or backwards direction.
%
That is
\begin{itemize}
\item
    $\Transducer_f$ (from the beginning of the input tape) skips over all
    characters until the first instance of $\controls$ is found.
    %
    Let this first instance be $q$.
    %
    It then starts simulating $\Transducer$ in the left-to-right direction
    starting from $q$.
    %
    That is, it can only simulate moves of the form
    $(q, a, d, q', b)$
    where
    $d \in \{\Stay, \Right\}$.
    %
    Any output is written to the output tape.
    %
    This simulation continues until $\Transducer_f$ reads some
    $q' \in \controls$.
    %
    It accepts only if the simulation has also reached $q'$.

\item
    $\Transducer_b$ (from the beginning of the input tape) skips over all
    characters until the first instance of $\controls$ is found.
    %
    Let this first instance be $q$.
    %
    It then starts simulating a right-to-left run of $\Transducer$ for a run
    that would end at $q$.
    %
    To do this it has to perform moves \emph{in reverse};
    that is, for moves of $\Transducer$ of the form
    $(q, a, d, q', b)$
    where
    $d \in \{\Left, \Stay\}$
    the transducer $\Transducer_b$ can simulate
    $(q', a, d^{-1}, q, b)$
    where
        $(\Left)^{-1} = \Right$
        and
        $(\Stay)^{-1} = \Stay$.
    %
    Any output is written to the output tape.
    %
    This simulation continues until $\Transducer_b$ reads some
    $q' \in \controls$
    and accepts only if the simulation has also reached $q'$.
\end{itemize}

We can now apply $\Transducer_f$ to the output of each use of $\prefix$ or
$\finalpass$ and $\Transducer_b$ to the output of each use of $\suffix$.
%
Since $\Transducer_b$ performs its simulation in reverse, we need to apply
$\reverse$ to its output.
%
Then, we concatenate all outputs to obtain $y$.
%
Thus, the output $y$ of the following program $S$ on an input $x$ is the same
as
$y := \Transducer(x)$
when $\Transducer$ performs $2k$ reversals.
\[
    \begin{array}{rcl}
        x_0 &:=& \init(x); \\
        x_1 &:=& \prefix(x_0); \\
        x_2 &:=& \suffix(x_1); \\
        &\vdots& \\
        x_{2k-1} &:=& \prefix(x_{2k-2}); \\
        x_{2k} &:=& \suffix(x_{2k-1}); \\
        x_{2k+1} &:=& \finalpass(x_{2k}); \\
        \\
        y_1 &:=& \Transducer_f(x_1); \\
        y'_2 &:=& \Transducer_b(x_2); \\
        y_2 &:=& \reverse(y'_2); \\
        &\vdots& \\
        y_{2k-1} &:=& \Transducer_f(x_{2k-1}); \\
        y'_{2k} &:=& \Transducer_b(x_{2k}); \\
        y_{2k} &:=& \reverse(y'_{2k}); \\
        y_{2k+1} &:=& \Transducer_f(x_{2k+1}); \\
        \\
        y &:=& \concatpt(y_1, \ldots, y_{2k+1})
    \end{array}
\]


\subsection{Computing the Pre-Image}

We can apply our generic decision procedure to compute the pre-image of the
program $S$.
%
Since correctness of the decision procedure relies on each transducer encoding
a function, the reduction is not \textit{a priori} correct.
%
Fortunately, we can use the fact that the program implements a function to
retain correctness.

For this, we reason backwards.
%
We first assume that the constraints on $y$ are non-conjunctive \FA{}.
%
That is, we expand conjunctive \FA{}s into a sequence of assertions, each
containing a single \FA{}.
%
Let $A_1, \ldots, A_n$ be the set of such \FA{}.
%
We apply the generic decision procedure to each \FA{} in turn and for each
$A_i$ obtain a set of constraints
$B^i_1, \ldots, B^i_m$
on $x$.
%
It will be shown that any value of $x$ satisfying each $B^i_j$ will map to a
value of $y$ that satisfies $A_i$.
%
Thus, if there is a value of $x$ satisfying $B^i_j$ for all $i, j$, and since
$\Transducer$ is functional, the value of $y$ mapped to will satisfy all $A_i$
as required.

We now consider a single
$A \in \{A_1, \ldots, A_n\}$
and drop the index $i$.
%
We make the following observations.
\begin{itemize}
\item
    From the pre-image of $\concatpt$ we select a tuple
    $A^c_1, \ldots, A^c_n$
    of constraints which require that $y_i$ accepted by $A^c_i$.
    %
    These are each of size $|A|$.
\item
    For any \FA{} $A$ and one-way (nondeterministic) transducer $\Transducer'$
    we can compute in polynomial time a \FA{} $B$ that is the pre-image of $A$
    under $\Transducer'$.
    %
    Its size is $|T||A|$.
    %
    This is a standard result.
    %
    \mat{cite?}
\end{itemize}
%
Figure~\ref{fig:aut-deps} shows the dependencies of the variables in $S$.
%
In Figure~\ref{fig:aut-constraints} we show the same diagram except variables
are replaced by the automata constraints each variable must satisfy.
%
We explain how to obtain these constraints.
%
First $y$ must satisfy $A$.
%
From the pre-image of $\concat$ we obtain
$A^c_1, \ldots, A^c_{2k+1}$
as remarked above.
%
When $\reverse$ is applied we obtain $A'_i$ which is the reverse of $A^c_i$ and of the same size.
%
Now we reach the top row of the diagram.

On the far right we obtain $B_{2k+1}$ as the pre-image of $A^c_{2k+1}$ under $\Transducer_f$.
%
This, as all automata here, is of linear size.
%
To $x_k$ we obtain two constraints:
    $B^1_{2k}$ which is the pre-image of $B_{2k+1}$ under $\finalpass$, and
    $B^2_{2k}$ which is the pre-image of $A'_{2k}$ under $\Transducer_b$.
%
Notice, we computed these pre-images independently.
%
This is where we may lose precision in our algorithm, since the values assigned to the variables may diverge between the separate automata.
%
We continue to $x_{2k-1}$ where we obtain three automata: one from $B^1_{2k}$, one from $B^2_{2k}$ and on from $A^c_{2k-1}$.
%
This continues leftwards along the row until $x$ is reached.

\begin{figure}
    \begin{tikzpicture}
        \node (x) {$x$};
        \node (x0) [right=of x] {$x_0$};
        \node (x1) [right=of x0] {$x_1$};
        \node (x2) [right=of x1] {$x_2$};
        \node (xdots) [right=of x2] {$\cdots$};
        \node (xkkm) [right=of xdots] {$x_{2k-1}$};
        \node (xkk) [right=of xkkm] {$x_{2k}$};
        \node (xkkp) [right=of xkk] {$x_{2k+1}$};
        \node (yp2) [below=of x2] {$y'_2$};
        \node (y2) [below=of yp2] {$y_2$};
        \node (y1) [below=of x1,left=of y2] {$y_1$};
        \node (ypkk) [below=of xkk] {$y'_{2k}$};
        \node (ykk) [below=of ypkk] {$y_{2k}$};
        \node (ykkm) [below=of xkkm,left=of ykk] {$y_{2k-1}$};
        \node (ykkp) [below=of xkkp,right=of ykk] {$y_{2k+1}$};
        \node (ydots) [below=of xdots,right=of y2] {$\cdots$};
        \node (concat) [below=of ydots] {$\concatpt$};
        \node (y) [below=of concat] {$y$};
        \path[->]
            (x) edge node [above] {$\init$} (x0)
            (x0) edge node [above] {$\prefix$} (x1)
            (x1) edge node [above] {$\suffix$} (x2)
            (x2) edge node [above] {$\prefix$} (xdots)
            (xdots) edge node [above] {$\prefix$} (xkkm)
            (xkkm) edge node [above] {$\suffix$} (xkk)
            (xkk) edge node [above] {$\finalpass$} (xkkp);
        \path[->]
            (x1) edge node [left] {$\Transducer_f$} (y1)
            (y1) edge (concat)
            (concat) edge (y);
        \path[->]
            (x2) edge node [left] {$\Transducer_b$} (yp2)
            (yp2) edge node [left] {$\reverse$} (y2)
            (y2) edge (concat);
        \path[->]
            (xkkm) edge node [left] {$\Transducer_f$} (ykkm)
            (ykkm) edge (concat);
        \path[->]
            (xkk) edge node [left] {$\Transducer_b$} (ypkk)
            (ypkk) edge node [left] {$\reverse$} (ykk)
            (ykk) edge (concat);
        \path[->]
            (xkkp) edge node [left] {$\Transducer_f$} (ykkp)
            (ykkp) edge (concat);
    \end{tikzpicture}
    \caption{\label{fig:aut-deps} The dependencies in $S$.}
\end{figure}

\begin{figure}
    \begin{tikzpicture}
        \node (x) {$
            \begin{array}{c}
                B^1, \\
                \vdots \\
                B^{2k+1}
            \end{array}
        $};
        \node (x0) [right=of x] {$
            \begin{array}{c}
                B^1_0, \\
                \vdots \\
                B^{2k+1}_0
            \end{array}
        $};
        \node (x1) [right=of x0] {$
            \begin{array}{c}
                B^1_1, \\
                \vdots \\
                B^{2k+1}_1
            \end{array}
        $};
        \node (x2) [right=of x1] {$
            \begin{array}{c}
                B^1_2, \\
                \vdots \\
                B^{2k}_2
            \end{array}
        $};
        \node (xdots) [right=of x2] {$\cdots$};
        \node (xkkm) [right=of xdots] {$
            \begin{array}{c}
                B^1_{2k-1}, \\
                B^2_{2k-1}, \\
                B^3_{2k-1}
            \end{array}
        $};
        \node (xkk) [right=of xkkm] {$
            \begin{array}{c}
                B^1_{2k}, \\
                B^2_{2k}
            \end{array}
        $};
        \node (xkkp) [right=of xkk] {$B_{2k+1}$};
        \node (yp2) [below=of x2] {$A'_2$};
        \node (y2) [below=of yp2] {$A^c_2$};
        \node (y1) [below=of x1,left=of y2] {$A^c_1$};
        \node (ypkk) [below=of xkk] {$A'_{2k}$};
        \node (ykk) [below=of ypkk] {$A^c_{2k}$};
        \node (ykkm) [below=of xkkm,left=of ykk] {$A^c_{2k-1}$};
        \node (ykkp) [below=of xkkp,right=of ykk] {$A^c_{2k+1}$};
        \node (ydots) [below=of xdots,right=of y2] {$\cdots$};
        \node (concat) [below=of ydots] {$\concatpt$};
        \node (y) [below=of concat] {$A$};
        \path[->]
            (x) edge node [above] {$\init$} (x0)
            (x0) edge node [above] {$\prefix$} (x1)
            (x1) edge node [above] {$\suffix$} (x2)
            (x2) edge node [above] {$\prefix$} (xdots)
            (xdots) edge node [above] {$\prefix$} (xkkm)
            (xkkm) edge node [above] {$\suffix$} (xkk)
            (xkk) edge node [above] {$\finalpass$} (xkkp);
        \path[->]
            (x1) edge node [left] {$\Transducer_f$} (y1)
            (y1) edge (concat)
            (concat) edge (y);
        \path[->]
            (x2) edge node [left] {$\Transducer_b$} (yp2)
            (yp2) edge node [left] {$\reverse$} (y2)
            (y2) edge (concat);
        \path[->]
            (xkkm) edge node [left] {$\Transducer_f$} (ykkm)
            (ykkm) edge (concat);
        \path[->]
            (xkk) edge node [left] {$\Transducer_b$} (ypkk)
            (ypkk) edge node [left] {$\reverse$} (ykk)
            (ykk) edge (concat);
        \path[->]
            (xkkp) edge node [left] {$\Transducer_f$} (ykkp)
            (ykkp) edge (concat);
    \end{tikzpicture}
    \caption{\label{fig:aut-constraints} The automata constructed for $S$.}
\end{figure}

We now argue that despite this divergence, the constraints
$B^1, \ldots, B^{2k+1}$
can be satisfied by some value of $x$ iff
$x = \Transducer(y)$
and $y$ satisfies $A$.
%
The right-to-left inclusion is clear since a run of $\Transducer$ can be mapped
onto an assignment to variables in $S$ that satisfy the program.
%
In the other direction, the danger is that intermediate variables may take on
multiple values since the constraints are not synchronised.
%
That is, a variable in $S$ may take on a different value for each path through
the automaton constraints it must satisfy.
%
The worst-case for this situation is show in Figure~\ref{fig:worst-case}.
%
Notice there are $2k+1$ values even for $x_{2k+1}$ which had only one automaton
constraint.
%
This is because, from $x$ it can be reached from any of the $2k+1$ values for
$x_1$.
%
Also notice that the variable $y$ only has one value.
%
We know from the fact that $\Transducer$ is functional that there can only be
one value $v$ for $y$ given $w$ for $x$.
%
Moreover, all the relations together in our program preserve this
functionality.

\begin{figure}
    \begin{tikzpicture}
        \node (x) {$w$};
        \node (x0) [right=of x] {$w_0$};
        \node (x1) [right=of x0] {$
            \begin{array}{c}
                w^1_1, \\
                \vdots \\
                w^{2k+1}_1
            \end{array}
        $};
        \node (x2) [right=of x1] {$
            \begin{array}{c}
                w^1_2, \\
                \vdots \\
                w^{2k+1}_2
            \end{array}
        $};
        \node (xdots) [right=of x2] {$\cdots$};
        \node (xkkm) [right=of xdots] {$
            \begin{array}{c}
                w^1_{2k-1}, \\
                \vdots \\
                w^{2k+1}_{2k-1}
            \end{array}
        $};
        \node (xkk) [right=of xkkm] {$
            \begin{array}{c}
                w^1_{2k}, \\
                \vdots \\
                w^{2k+1}_{2k}
            \end{array}
        $};
        \node (xkkp) [right=of xkk] {$
            \begin{array}{c}
                w^1_{2k+1}, \\
                \vdots \\
                w^{2k+1}_{2k+1}
            \end{array}
        $};
        \node (yp2) [below=of x2] {$
             \begin{array}{c}
                u^1_{2}\ ', \\
                \vdots \\
                u^{2k+1}_{2}\ '
            \end{array}
        $};
        \node (y2) [below=of yp2] {$
            \begin{array}{c}
                u^1_{2}, \\
                \vdots \\
                u^{2k+1}_{2}
            \end{array}
        $};
        \node (y1) [below=of x1,left=of y2] {$
            \begin{array}{c}
                u^1_{1}, \\
                \vdots \\
                u^{2k+1}_{1}
            \end{array}
        $};
        \node (ypkk) [below=of xkk] {$
            \begin{array}{c}
                u^1_{2k}\ ', \\
                \vdots \\
                u^{2k+1}_{2k}\ '
            \end{array}
        $};
        \node (ykk) [below=of ypkk] {$
            \begin{array}{c}
                u^1_{2k}, \\
                \vdots \\
                u^{2k+1}_{2k}
            \end{array}
        $};
        \node (ykkm) [below=of xkkm,left=of ykk] {$
            \begin{array}{c}
                u^1_{2k-1}, \\
                \vdots \\
                u^{2k+1}_{2k-1}
            \end{array}
        $};
        \node (ykkp) [below=of xkkp,right=of ykk] {$
            \begin{array}{c}
                u^1_{2k+1}, \\
                \vdots \\
                u^{2k+1}_{2k+1}
            \end{array}
        $};
        \node (ydots) [below=of xdots,right=of y2] {$\cdots$};
        \node (concat) [below=of ydots] {$\concatpt$};
        \node (y) [below=of concat] {$v$};
        \path[->]
            (x) edge node [above] {$\init$} (x0)
            (x0) edge node [above] {$\prefix$} (x1)
            (x1) edge node [above] {$\suffix$} (x2)
            (x2) edge node [above] {$\prefix$} (xdots)
            (xdots) edge node [above] {$\prefix$} (xkkm)
            (xkkm) edge node [above] {$\suffix$} (xkk)
            (xkk) edge node [above] {$\finalpass$} (xkkp);
        \path[->]
            (x1) edge node [left] {$\Transducer_f$} (y1)
            (y1) edge (concat)
            (concat) edge (y);
        \path[->]
            (x2) edge node [left] {$\Transducer_b$} (yp2)
            (yp2) edge node [left] {$\reverse$} (y2)
            (y2) edge (concat);
        \path[->]
            (xkkm) edge node [left] {$\Transducer_f$} (ykkm)
            (ykkm) edge (concat);
        \path[->]
            (xkk) edge node [left] {$\Transducer_b$} (ypkk)
            (ypkk) edge node [left] {$\reverse$} (ykk)
            (ykk) edge (concat);
        \path[->]
            (xkkp) edge node [left] {$\Transducer_f$} (ykkp)
            (ykkp) edge (concat);
    \end{tikzpicture}
    \caption{\label{fig:aut-constraints} The dependencies and automata constructed from $S$.}
\end{figure}


\subsection{The Pre-Image Returned}

For clarity, we emphasis that the pre-image computation for $\Transducer$
returns a conjunctive automaton representing the intersection of
$B^1, \ldots, B^{2k+1}$
which were the constraints obtained on $x$.
%
These are of a size $C|T||A|$ where $C$ is a constant bound by
$|\concat||\reverse||\Transducer_f||\Transducer_b||\finalpass||\suffix|^k|\prefix|^k|\init|$.
%
Note, the number of states needed to implement $\prefix$ and $\suffix$ is
fixed: the transducers simply need to remember if they have output one or two
states of $\Transducer$.
%
Furthermore, $k$ is fixed.
}
