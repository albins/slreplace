%!TEX root = main.tex

\section{Introduction}
\label{sec:intro}

Strings are a fundamental data type in virtually all programming languages.
Their generic nature can, however, lead to many subtle programming 
bugs, some with security consequences, e.g., cross-site scripting
(XSS), which is among OWASP Top 10 Application Security Risks
\cite{owasp17}. One effective
automatic testing method for identifying subtle programming errors
%automatically generating test cases 
%generation with a good coverage 
is based on \emph{symbolic executions} 
\cite{king76} and combinations with dynamic analysis
called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
See \cite{symbex-survey} for an excellent survey. Unlike purely random testing,
which runs only \emph{concrete} program executions on different 
inputs, the techniques of symbolic executions analyse \emph{static} paths
(also called symbolic executions) through the software system under test.
Since such a path is simply a sequence of assignments and
conditionals/assertions, it can be viewed as a constraint $\varphi$ (over 
appropriate data domains) and a 
solver could be invoked on $\varphi$ to check the \emph{feasibility}
of the static path, which can be used for generating inputs that lead to 
certain parts of the program or an erroneous behaviour.
%a undesirable program behaviour.
%or an exploration of a new part of the
%system. 

A symbolic execution analysis relies on constraint solvers at its core. When 
the system
under test is a program that uses string data type (including most programs 
written in scripting languages like JavaScript and PHP), these techiques 
crucially need constraint solvers over the string domain (a.k.a. \emph{string 
solvers}). This in fact has been one main reason behind the development of
the theory, implementation, and symbolic execution applications of string 
solving in the past decade, e.g., see 
\cite{BTV09,Berkeley-JavaScript,HAMPI,Stranger,Vijay-length,YABI14,Abdulla14,LB16,fang-yu-circuits,Abdulla17,CCHLW18,HJLRV18,S3,TCJ16,Z3-str,Z3-str2,cvc4,Saner,RVG12,jalangi,expose}.

%\subsubsection*{
\smallskip
\noindent
\textbf{Constraints from Symbolic Executions. }
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be understood in terms of the
problem of \emph{path 
feasibility} over a bounded program $S$ with neither loop nor
branching. %with variable
%assignments and assertions. 
That is, $S$ is a sequence of assignments and conditionals/assertions, i.e., 
generated by the grammar
\begin{equation} 
    S ::= \qquad y := f(x_1,\ldots,x_\arity) \ |\
    \text{\ASSERT{$g(x_1,\ldots,x_\arity)$}}\ |\ 
            S_1; S_2\ 
            \label{eq:symbex}
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation}
where $f: (\Sigma^*)^\arity \to \Sigma^*$ and $g: (\Sigma^*)^\arity \to \{0,1\}$ are
some partial string functions. 
The syntaxes for the functions $f$ and $g$ are now
left undefined, but will be instantiated as one explores algorithmic issues.
The following is a simple example of a symbolic execution $S$
which uses string variables ($x$, $y$, and $z$'s) and string constants
(letters \texttt{a} and \texttt{b}), and the concatenation operator ($\concat$):
\begin{equation}
        z_1 := x \concat \text{\texttt{ba}} \concat y;\quad 
        z_2 := y \concat \text{\texttt{ab}} \concat x;\quad
        \ASSERT{z_1 == z_2}
        \label{eq:intro_ex}
\end{equation}
%with additional assertions on the way. 
%\mat{Should the ``straight-line'' restriction be explicitly defined?}
The problem of \defn{path feasibility/satisfiability}\footnote{
%of a symbolic execution with string data type 
    It is equivalent to 
satisfiability of string constraints in SMT framework
\cite{SMT-CACM,SMT-chapter,KS08}.
%can be viewed as constraints over the 
%string domain 
Simply convert a symbolic execution $S$ 
into a \emph{Static Single Assignment} (SSA) form (i.e. use a new 
variable 
on l.h.s. of each assignment) and treat assignments as equality,
e.g., formula for the above example is
        $z_1 = x + \text{\texttt{ba}} + y \wedge
        z_2 = y + \text{\texttt{ab}} + x\ \wedge
        z_1 = z_2$.
Many decidable string logics can be more naturally phrased in terms of
path feasibility.}
asks whether, for a given program $S$, there exist \emph{input} strings (e.g.
%instantiations of variables that do not appear in the left-hand side of an 
%assignment) 
$x$ and $y$ in Example in (\ref{eq:intro_ex}))
that can successfully take
$S$ to the end of the program while satisfying all the assertions. 
Example in (\ref{eq:intro_ex}) can be satisfied by
assigning $y$ (resp.~$x$) to $\texttt{b}$ (resp.~the empty string). 


\OMIT{
In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
%generally, 
binary relations viewed as functions (as in programming, not mathematics) that 
nondeterministically choose an output string corresponding to an input string. 
For example, the 
notation $x := ?$ is common in the program verification to 
denote a nondeterministic assignment to $x$. More generally, nondeterministic
behaviour could be needed due to unknown inputs from a human user or other 
sources (e.g. databases). In this case, path feasibility of a
symbolic execution $S$
is defined in an \emph{angelic} way: each function in $S$
should be able to produce \emph{some} output string that takes $S$ to the end of the
program.
}


\OMIT{
\smallskip
\noindent
\fbox{\parbox{0.96\textwidth}{
    \textbf{Remark.}

Below is an example of the conversion from a symbolic execution (left)
to a string constraint (right). They contain variables ($x$, $y$, and $z$'s)
and string constants (letters \texttt{a} and \texttt{b}),
as well as the concatenation operator (+).
%See Figure \ref{fig:SSA} for an
%example.


\smallskip

%\begin{figure}
    {
    \qquad
    \begin{minipage}{.49\linewidth}
        $z_1 := x + \text{\texttt{ba}} + y$;\\
        $z_2 := y + \text{\texttt{ab}} + x$;\\
        \ASSERT{$z_1 == z_2$};
    \end{minipage}
    \quad
    \begin{minipage}{.49\linewidth}
        $z_1 = x + \text{\texttt{ba}} + y\ \wedge$\\
        $z_2 = y + \text{\texttt{ab}} + x\ \wedge$\\
        $z_1 = z_2$
    \end{minipage}
    }
    %\caption{String constraint (right) corresponding to a symbolic execution
    %(left)
    %\label{fig:SSA}}
%\end{figure}

In the sequel, we will use framework of Bjorner \emph{et al.} \cite{BTV09} 
since most decidable string logics can be more naturally phrased in this
way.
}
}
}

\smallskip
\noindent
\textbf{Decidable string constraint languages.}
A central theme in string solving is to design an
expressive string constraint language for symbolic executions of 
string-manipulating
programs that admits \emph{decidability}. 
%\OMIT{
%This 
%is tricky since it does not take much to obtain undecidability
%\cite{BTV09}. 
%}
%\OMIT{
%However, recent advances have been made by imposing 
%\emph{syntactic restrictions} on the shape of the formulas
%(e.g. solved form, acyclicity, and straight-line 
%\cite{LB16,Abdulla14,Vijay-length}) that are still satisfied by string 
%constraints that arise in practice. 
%}
Being the most basic string operation,
concatenation is typically present in a string theory.
Constraints in the \emph{theory of concatenation} 
are symbolic executions %(see (\ref{eq:symbex}))
with concatenation of string constants/variables in the
assignment ($f$ in (\ref{eq:symbex})) and equality/disequality checks of
variables in the assertions ($g$ in (\ref{eq:symbex})).
%Concatenation (+) and string equality (=) are typically present in a string 
%theory since they are the most basic string operations. 
Example in (\ref{eq:intro_ex}) is an instance of a constraint in this theory.
%For example, the
%expression $\varphi(x,y) \equiv\ x + \texttt{ba} + y = y + 
%\texttt{ab} 
%+ x$ is a constraint in the 
%theory, where $x$ and $y$ are string variables and the alphabet is
%$\{\texttt{a},\texttt{b}\}$.
%It can be satisfied by the assignment $y$ (resp.~$x$) is mapped to $\texttt{b}$
%(resp.~the empty string). 
The theory of concatenation was 
proven to be decidable in the seminal
paper by Makanin \cite{Makanin} on \emph{word equations}, followed by the
extension by B\"{u}chi and Senger \cite{buchi}.
This decidability holds even when
\emph{regular constraints} (i.e. regular expression matching, e.g., 
$y \in (\texttt{ab})^*$) --- useful to specify the set of ``bad'' strings ---
are allowed as assertions \cite{Schulz}. 
%Decidability becomes slightly problematic beyond this.
%string operation (e.g. to specify the set of ``bad'' strings) which
%can be incorporated to the theory of concatenation (as an assertion) without 
%sacrificing decidability 
%It seems difficult, however, to extend this
%theory with other useful string operations while preserving decidability.
%For example, it is a long-standing open problem whether 
%A couple of decades after Makanin's result
%it was finally shown \cite{P04,J17} that the complexity of the theory of 
%concatenation with regular expression matching is PSPACE-complete.

%or the \emph{replaceall} function
%(replacing every occurrence of a string matching a pattern with another
%string) \cite{CCHLW18,fang-yu-circuits,YABI14,Stranger,S3,TCJ16} 

Sanitisers (e.g. htmlescape and backslash-escape)
and implicit browser transductions (e.g. innerHTML)
are two types of string functions that are frequently used in client-side
web applications. Many XSS vulnerabilities are caused by
subtle interactions between these functions and other parts of the
applications, e.g., see \cite{web-model,Kern14,DV13,LB16,mXSS}. 
(One-way) \emph{Finite-state transducers} 
\cite{BEK,web-model,DV13,symbolic-transducer,LB16}
are a good formal model of such string functions that satisfy some
good closure and algorithmic properties. 
%This model is the class of
%\emph{finite-state transductions}
Finite transducers are just like
finite-state automata but with an output tape.
%\OMIT{
%The second model is the \emph{replaceall} function
%\cite{fang-yu-circuits,YABI14,Stranger,S3,TCJ16,Saner}, i.e.,
%replacing every occurrence of an input string matching a pattern with a constant
%string. The second model is less expressive than the first.
%}
Unfortunately, adding finite-state transductions to
the theory of concatenation (in the assignment of (\ref{eq:symbex})) results in 
undecidability \cite{LB16}.
More recently, a decidable logic with these additional string 
operations \cite{LB16} has been obtained by imposing 
the \emph{straight-line restriction}. %, which is
%syntactic restrictions (solved forms
%\cite{Vijay-length}, acyclicity \cite{Abdulla14,BFL13}, and straight-line
%\cite{LB16}) on the shape of string constraints. 
%a syntactic restriction on the shape of input constraints. 
This is done 
by \emph{disallowing string equality checks in the assertions} $g$ in 
(\ref{eq:symbex}). In other words, concatenation and finite-state transductions
can both be used in assignments, while only regular constraints can be used in
assertions. The string logic is still 
sufficiently expressive
for many examples that arise in practice \cite{LB16,HJLRV18}.


\OMIT{
However, there are many other useful string 
operations including string length function
\cite{Vijay-length,Berkeley-JavaScript}, replaceall
function (replacing every occurrence of a string matching a pattern with another
string) \cite{CCHLW18,fang-yu-circuits,YABI14,Stranger,S3,TCJ16}, 
finite-state transductions \cite{LB16,BEK,web-model,DV13}.
Adding them to the theory of concatenation
either results in an undecidable string theory \cite{LB16,BFL13,GB16}
or one whose decidability is a long-standing open problem \cite{Vijay-length}.
}


\OMIT{
Even though the complexity of the logic is EXPSPACE-complete 
\cite{LB16} (i.e. requires double exponential time in the worst case), 
a fast solver \cite{HJLRV18} --- exploiting alternating
automata and hardware verification --- has recently been developed.
}

Despite the expressive power of finite-state transducers, 
they cannot model some important string functions. In addition to string
concatenation (which justifies combining transducers and concatenation in 
string constraints \cite{LB16}), there are two other important examples. The 
first example is the replaceall functions $\replaceall_p(sub,rep)$ where the subject $sub$ and the replacement 
$rep$ are string \emph{variables}, i.e., 
replacing every matching of the pattern $p$ in the subject $sub$ by $rep$.
%replacing every occurrence of a string $s$ in subject $sub$ matching the pattern $p$ by $rep$. 
%As argued in \cite{CCHLW18},
In a recent paper \cite{CCHLW18},
such replaceall functions were argued to be important for modelling string 
functions used in web templating like Mustache.js \cite{Mustache}, and
that straight-line string constraints with replaceall/concatenation in 
assignments were shown to be decidable.
%\OMIT{
%The more restricted replaceall
%functions where $rep$ is a string constant can be modelled by finite-state  
%transducers \cite{LB16}. 
%}
%It was shown in \cite{CCHLW18} that
%theory of concatenation with regular constraints and this general replaceall
%function is decidable whenever the straight-line restriction is imposed.
Secondly, the string reverse function cannot be expressed by a finite-state
transducer. To admit such a function, we need to allow \emph{two-way} 
finite-state transducers \cite{Berstel,Sakarovitch}, which so far have not 
been incorporated into a string constraint language. \emph{Our proposal is to
design a expressive decidable string constraint language that admits all the
aforementioned string functions, which furthermore unifies the decidable string 
logics of \cite{CCHLW18,LB16}.}

%restrictions limit the way the equality operator relates string variables in 
%the constraints. For example, we obtain the decidable \emph{straight-line logic}
%\cite{LB16} if we remove string equality from an assertion, but we allow


%
%
%For this reason, a lot of effort is spent instead on developing fast practical
%\emph{heuristics} for string solving
%\cite{Z3-str,Z3-str2,S3,TCJ16,YABI14,Berkeley-JavaScript,cvc4,HAMPI} without a
%guarantee of completeness. \anthony{More citation is needed here} 
%One fundamental question
%in constraint solving over strings, to which hitherto only partial answers are 
%available: 
%\emph{which string operations can we
%incorporate into a decidable theory over strings?}

%Talk about symbolic execution. Dynamic symbolic execution.

\smallskip
\noindent
\textbf{Contributions.} Rather than admitting many different classes of string 
functions in our constraint language, we introduce \emph{parametric 
transducers}, an expressive formalism for modelling string (partial) functions 
$f: (\ialphabet^*)^\arity \to \ialphabet^*$ with multiple inputs $x_1,\ldots, 
x_\arity$. Parametric
transducers strictly generalise the standard finite-state transducers (which take only
one input) by allowing: (1) parameters $x_2,\ldots,x_\arity$ in the output
($x_1$, the first argument of $f$, is placed on the input tape), 
and (2) the two-way (left/right) head pointing to the input tape. 
%input head moving in two directions. 
Parametric transducers are capable of modelling the string functions as 
diverse as replaceall, string reverse, and concatenation, as well as finite-state transductions, thus \emph{unifying them into one single formalism}.
%In addition, 
%not only can parametric
%transducers model the $\replaceall_p(sub,rep)$ function, string reverse, and
%concatenation,
As a result of the expressibility, parametric transducers can model string functions required in \emph{context-sensitive
auto-sanitisation} in web templating systems \cite{SSS11}, e.g., Closure 
\cite{Closure} and Handlebars \cite{Handlebars}. 
We provide a \emph{generic} automata-theoretic decision procedure for the \emph{path 
feasibility problem} of symbolic executions that use parametric transducers in 
assignments and regular constraints in assertions. Our constraint language
is one of the \emph{most expressive decidable} string languages for symbolic 
executions of programs with strings.
%Among others, our algorithm implies decidability (with the same complexity)
%of the string constraint 
%languages with finite transducers and concatenation \cite{LB16}, and
%replaceall \cite{CCHLW18}.
%
We also provide a detailed complexity 
analysis of the generic decision procedure and its instantiations with different classes of transducers.\footnote{
\emph{Worst-case complexity} results  do not prohibit fast solvers 
\emph{in practice}, e.g., SLOTH for the straight-line 
logic with finite transducers ({\sc expspace}) 
\cite{HJLRV18}, and MONA for Weak Second-Order
Theory of Successors ({\sc nonelementary}). Rather, they
\emph{inform} algorithmic techniques that could work in practice, e.g., 
symbolic techniques.}
%
%which ranges between {\sc expspace} (same as in \cite{LB16,CCHLW18}) and
%{\sc nonelementary} (i.e. complexity cannot be bounded by a $n$-fold exponential
%function for every fixed $n > 0$). 
Among others, our generic decision procedure implies that \emph{the path feasibility problem is $\expspace$-complete for the straight-line string constraint language including all the aforementioned string functions, namely, functional one-way finite-state transducers, concatenation, replaceall, and reverse}, thus strictly generalising the $\expspace$-completeness result for (functional one-way) finite transducers and concatenation in \cite{LB16}, and
for replaceall in \cite{CCHLW18}.
%
Finally, we extend our results to symbolic automata/transducers
\cite{BEK,symbolic-transducer,DV13,symbolic-transducer-power}, which are crucial for practical 
applications requiring large alphabets (e.g.~UTF16).

%\input{auto-sanitisation}


