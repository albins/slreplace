\section{Introduction}
\label{sec:intro}

Strings are a fundamental data type in virtually all programming languages.
Their generic nature can, however, lead to many subtle programming 
bugs, some with security consequences, e.g., cross-site scripting
(XSS) and code injections, both of which are ranked top 10 by Open Web
Application Security Projects (OWASP) in 2017 \cite{owasp17}. One effective
automatic software testing method for identifying subtle programming errors
%automatically generating test cases 
%generation with a good coverage 
is based on \emph{symbolic executions} 
\cite{king76} and combinations with dynamic analysis
called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
See \cite{symbex-survey} for an excellent survey. Unlike purely random testing,
which runs only \emph{concrete} (i.e. actual) program executions on different 
inputs, the techniques of symbolic executions analyse \emph{static} paths
(also called symbolic executions) through the software system under test.
Since such a path is simply a sequence of assignments and
conditionals/assertions, it can be viewed as a constraint $\varphi$ (over 
appropriate domains corresponding to the data types used in the path) and a 
constraint solver could be invoked on $\varphi$ to check the \emph{feasibility}
of the static path, which can be used for generating inputs that lead to 
an undesirable program behaviour or an exploration of a new part of the
system. 

A symbolic executions analysis relies on constraint solvers at its core. When 
the system
under test is a program that uses string data type (including most programs 
written in scripting languages like JavaScript and PHP), these techiques 
crucially need constraint solvers over the string domain (a.k.a. \emph{string 
solvers}). This in fact has been one main reason behind the development of
the theory, implementation, and symbolic execution applications of string constraint 
solving in the past decade, e.g., see 
\cite{BTV09,Berkeley-JavaScript,HAMPI,Stranger,Vijay-length,YABI14,Abdulla14,LB16,fang-yu-circuits,Abdulla17,CCHLW18,HJLRV18,S3,TCJ16,Z3-str,Z3-str2,cvc4,BCFJKKV08,RVG12,jalangi,expose}.

%\subsubsection*{
\smallskip
\noindent
\textbf{Constraints from Symbolic Executions: }
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be understood in terms of the
problem of \emph{path 
feasibility} over a bounded program $S$ with neither loop nor
branching. %with variable
%assignments and assertions. 
That is, $S$ is a sequence of assignments and conditionals/assertions, i.e., 
generated by the grammar
\begin{equation}
    S ::= \qquad y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$g(x_1,\ldots,x_n)$}}\ |\ 
            S_1; S_2\ 
            \label{eq:symbex}
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation}
where $f: (\Sigma^*)^n \to \Sigma^*$ and $g: (\Sigma^*)^n \to \{0,1\}$ are
some partial string functions. 
The syntaxes for the functions $f$ and $g$ are now
left undefined, but will be instantiated as one explores algorithmic issues.
%with additional assertions on the way. 
%\mat{Should the ``straight-line'' restriction be explicitly defined?}
The problem of \defn{path feasibility}
asks whether, for a given program $S$, there exist \emph{input} strings (i.e. 
instantiations of variables that do not appear in the left-hand side of an 
assignment) that can successfully take
$S$ to the end of the program while satisfying all the assertions. 
\OMIT{
In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
%generally, 
binary relations viewed as functions (as in programming, not mathematics) that 
nondeterministically choose an output string corresponding to an input string. 
For example, the 
notation $x := ?$ is common in the program verification to 
denote a nondeterministic assignment to $x$. More generally, nondeterministic
behaviour could be needed due to unknown inputs from a human user or other 
sources (e.g. databases). In this case, path feasibility of a
symbolic execution $S$
is defined in an \emph{angelic} way: each function in $S$
should be able to produce \emph{some} output string that takes $S$ to the end of the
program.
}

A central research theme in the past decade or so is to design an
expressive string constraint language for symbolic executions of 
string-manipulating
programs that admits \emph{decidability}. As pointed out in \cite{BTV09}, this 
is rather tricky since it does not take much to obtain undecidability. 
However, recent advances have been made by imposing 
\emph{syntactic restrictions} on the shape of the formulas
(e.g. solved form, acyclicity, and straight-line 
\cite{LB16,Abdulla14,Vijay-length}) that are still satisfied by string 
constraints that arise in practice. 

\smallskip
\noindent
\fbox{\parbox{0.96\textwidth}{
    \textbf{Remark.}
Path feasibility of a symbolic execution with string data type is equivalent to 
satisfiability of string constraints in the framework of Satisfiability Modulo
Theories (SMT) \cite{SMT-CACM,SMT-chapter,KS08}.
%can be viewed as constraints over the 
%string domain 
To see this, simply convert a symbolic execution $S$ 
into a \emph{Static Single Assignment} (SSA) form (i.e. introduce a new 
variable 
on the left hand side of each assignment) and treat assignments as equality. 
Below is an example of the conversion from a symbolic execution (left)
to a string constraint (right). They contain variables ($x$, $y$, and $z$'s)
and string constants (letters \texttt{a} and \texttt{b}),
as well as the concatenation operator (+).
%See Figure \ref{fig:SSA} for an
%example.


\smallskip

%\begin{figure}
    {
    \qquad
    \begin{minipage}{.49\linewidth}
        $z_1 := x + \text{\texttt{ba}} + y$;\\
        $z_2 := y + \text{\texttt{ab}} + x$;\\
        \ASSERT{$z_1 == z_2$};
    \end{minipage}
    \quad
    \begin{minipage}{.49\linewidth}
        $z_1 = x + \text{\texttt{ba}} + y\ \wedge$\\
        $z_2 = y + \text{\texttt{ab}} + x\ \wedge$\\
        $z_1 = z_2$
    \end{minipage}
    }
    %\caption{String constraint (right) corresponding to a symbolic execution
    %(left)
    %\label{fig:SSA}}
%\end{figure}

In the sequel, we will use framework of Bjorner \emph{et al.} \cite{BTV09} 
since most decidable string logics can be more naturally phrased in this
way.
}
}
\smallskip

\noindent
\textbf{A brief survey of decidable string constraint languages:}
Concatenation (+) is typically present in a string theory since it is perhaps
the most basic string operation. The \emph{theory of concatenation} can be
obtained from symbolic executions (see (\ref{eq:symbex}))
by allowing concatenation of string constants/variables in the
assignment (i.e. $f$ in (\ref{eq:symbex})) and equality checks in the
assertions/conditionals (i.e. $g$ in (\ref{eq:symbex})).
%Concatenation (+) and string equality (=) are typically present in a string 
%theory since they are the most basic string operations. 
An example of a constraint in this theory can be found in the above remark, 
which can be satisfied by
assigning $y$ (resp.~$x$) to $\texttt{b}$ (resp.~the empty string). 
%For example, the
%expression $\varphi(x,y) \equiv\ x + \texttt{ba} + y = y + 
%\texttt{ab} 
%+ x$ is a constraint in the 
%theory, where $x$ and $y$ are string variables and the alphabet is
%$\{\texttt{a},\texttt{b}\}$.
%It can be satisfied by the assignment $y$ (resp.~$x$) is mapped to $\texttt{b}$
%(resp.~the empty string). 
Even in this case, the theory of concatenation was 
not known to be decidable until the seminal
paper by Makanin \cite{Makanin} on \emph{word equations}, followed by the
extension by B\"{u}chi and Senger \cite{buchi} to all quantifier-free formulas.
Regular expression matching (e.g. $y \in (\texttt{ab})^*$) is another useful
string operation (in fact, crucial to specify the set of ``bad'' strings) which
can be incorporated to the theory of concatenation (as an assertion) without 
sacrificing decidability \cite{Schulz}. 
%It seems difficult, however, to extend this
%theory with other useful string operations while preserving decidability.
%For example, it is a long-standing open problem whether 
%A couple of decades after Makanin's result
%it was finally shown \cite{P04,J17} that the complexity of the theory of 
%concatenation with regular expression matching is PSPACE-complete.
However, there are many other useful string 
operations including string length function, replaceall
function (replacing every occurrence of a string matching a pattern with another
string), finite-state transductions, and casting functions (e.g. conversions
between integers and strings). Adding them to the theory of concatenation
either results in an undecidable string theory \cite{LB16,BFL13,GB16}
or one whose decidability is a long-standing open problem \cite{Vijay-length}.

\OMIT{
Following the framework of Satisfiability Modulo Theories (SMT)
\cite{SMT-CACM,SMT-chapter,KS08}, string constraints are typically 
quantifier-free first-order formulas. 
}


%
%
%For this reason, a lot of effort is spent instead on developing fast practical
%\emph{heuristics} for string solving
%\cite{Z3-str,Z3-str2,S3,TCJ16,YABI14,Berkeley-JavaScript,cvc4,HAMPI} without a
%guarantee of completeness. \anthony{More citation is needed here} 
%One fundamental question
%in constraint solving over strings, to which hitherto only partial answers are 
%available: 
%\emph{which string operations can we
%incorporate into a decidable theory over strings?}

%Talk about symbolic execution. Dynamic symbolic execution.

\input{auto-sanitisation}
