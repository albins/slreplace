%!TEX root = main.tex

\section{Introduction}
\label{sec:intro}

Strings are a fundamental data type in virtually all programming languages.
Their generic nature can, however, lead to many subtle programming 
bugs, some with security consequences, e.g., cross-site scripting
(XSS), which is among OWASP Top 10 Application Security Risks
\cite{owasp17}. One effective
automatic testing method for identifying subtle programming errors
%automatically generating test cases 
%generation with a good coverage 
is based on \emph{symbolic executions} 
\cite{king76} and combinations with dynamic analysis
called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
See \cite{symbex-survey} for an excellent survey. Unlike purely random testing,
which runs only \emph{concrete} program executions on different 
inputs, the techniques of symbolic executions analyse \emph{static} paths
(also called symbolic executions) through the software system under test.
Since such a path is simply a sequence of assignments and
conditionals/assertions, it can be viewed as a constraint $\varphi$ (over 
appropriate data domains) and a 
solver could be invoked on $\varphi$ to check the \emph{feasibility}
of the static path, which can be used for generating inputs that lead to 
certain parts of the program or an erroneous behaviour.
%a undesirable program behaviour.
%or an exploration of a new part of the
%system. 

A symbolic execution analysis relies on constraint solvers at its core. When 
the system
under test is a program that uses string data type (including most programs 
written in scripting languages like JavaScript and PHP), these techiques 
crucially need constraint solvers over the string domain (a.k.a. \emph{string 
constraint solvers}). This in fact has been one main reason behind the development of
the theory, implementation, and symbolic execution applications of string constraint 
solving in the past decade, e.g., see 
\cite{BTV09,Berkeley-JavaScript,HAMPI,Stranger,Vijay-length,YABI14,Abdulla14,LB16,fang-yu-circuits,Abdulla17,CCHLW18,HJLRV18,S3,TCJ16,Z3-str,Z3-str2,cvc4,Saner,RVG12,jalangi,expose}.

%\subsubsection*{
\smallskip
\noindent
\textbf{Constraints from Symbolic Executions: }
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be understood in terms of the
problem of \emph{path 
feasibility} over a bounded program $S$ with neither loop nor
branching. %with variable
%assignments and assertions. 
That is, $S$ is a sequence of assignments and conditionals/assertions, i.e., 
generated by the grammar
\begin{equation} 
    S ::= \qquad y := f(x_1,\ldots,x_\arity) \ |\
    \text{\ASSERT{$g(x_1,\ldots,x_\arity)$}}\ |\ 
            S_1; S_2\ 
            \label{eq:symbex}
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation}
where $f: (\Sigma^*)^\arity \to \Sigma^*$ and $g: (\Sigma^*)^\arity \to \{0,1\}$ are
some partial string functions. 
The syntaxes for the functions $f$ and $g$ are now
left undefined, but will be instantiated as one explores algorithmic issues.

The following is a simple example of a symbolic execution $S$
which uses string variables ($x$, $y$, and $z$'s) and string constants
(letters \texttt{a} and \texttt{b}), and the concatenation operator ($\concat$):
\begin{equation}
        z_1 := x \concat \text{\texttt{ba}} \concat y;\quad 
        z_2 := y \concat \text{\texttt{ab}} \concat x;\quad
        \ASSERT{z_1 == z_2}
        \label{eq:intro_ex}
\end{equation}
%with additional assertions on the way. 
%\mat{Should the ``straight-line'' restriction be explicitly defined?}
The problem of \defn{path feasibility/satisfiability}\footnote{
%of a symbolic execution with string data type 
    This is equivalent to 
satisfiability of string constraints in the framework of SMT
\cite{SMT-CACM,SMT-chapter,KS08}.
%can be viewed as constraints over the 
%string domain 
Simply convert a symbolic execution $S$ 
into a \emph{Static Single Assignment} (SSA) form (i.e. introduce a new 
variable 
on the left hand side of each assignment) and treat assignments as equality,
e.g., the corresponding formula for the above example is
        $z_1 = x + \text{\texttt{ba}} + y \wedge
        z_2 = y + \text{\texttt{ab}} + x\ \wedge
        z_1 = z_2$.
Many decidable string logics can be more naturally phrased in terms of
path feasibility.}
asks whether, for a given program $S$, there exist \emph{input} strings (e.g.
%instantiations of variables that do not appear in the left-hand side of an 
%assignment) 
$x$ and $y$ in Example in (\ref{eq:intro_ex}))
that can successfully take
$S$ to the end of the program while satisfying all the assertions. 
Example in (\ref{eq:intro_ex}) can be satisfied by
assigning $y$ (resp.~$x$) to $\texttt{b}$ (resp.~the empty string). 


\OMIT{
In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
%generally, 
binary relations viewed as functions (as in programming, not mathematics) that 
nondeterministically choose an output string corresponding to an input string. 
For example, the 
notation $x := ?$ is common in the program verification to 
denote a nondeterministic assignment to $x$. More generally, nondeterministic
behaviour could be needed due to unknown inputs from a human user or other 
sources (e.g. databases). In this case, path feasibility of a
symbolic execution $S$
is defined in an \emph{angelic} way: each function in $S$
should be able to produce \emph{some} output string that takes $S$ to the end of the
program.
}


\OMIT{
\smallskip
\noindent
\fbox{\parbox{0.96\textwidth}{
    \textbf{Remark.}

Below is an example of the conversion from a symbolic execution (left)
to a string constraint (right). They contain variables ($x$, $y$, and $z$'s)
and string constants (letters \texttt{a} and \texttt{b}),
as well as the concatenation operator (+).
%See Figure \ref{fig:SSA} for an
%example.


\smallskip

%\begin{figure}
    {
    \qquad
    \begin{minipage}{.49\linewidth}
        $z_1 := x + \text{\texttt{ba}} + y$;\\
        $z_2 := y + \text{\texttt{ab}} + x$;\\
        \ASSERT{$z_1 == z_2$};
    \end{minipage}
    \quad
    \begin{minipage}{.49\linewidth}
        $z_1 = x + \text{\texttt{ba}} + y\ \wedge$\\
        $z_2 = y + \text{\texttt{ab}} + x\ \wedge$\\
        $z_1 = z_2$
    \end{minipage}
    }
    %\caption{String constraint (right) corresponding to a symbolic execution
    %(left)
    %\label{fig:SSA}}
%\end{figure}

In the sequel, we will use framework of Bjorner \emph{et al.} \cite{BTV09} 
since most decidable string logics can be more naturally phrased in this
way.
}
}
}

\smallskip
\noindent
\textbf{Decidable string constraint languages:}
A central theme in string constraint solving is to design an
expressive string constraint language for symbolic executions of 
string-manipulating
programs that admits \emph{decidability}. 
\OMIT{
This 
is tricky since it does not take much to obtain undecidability
\cite{BTV09}. 
}
\OMIT{
However, recent advances have been made by imposing 
\emph{syntactic restrictions} on the shape of the formulas
(e.g. solved form, acyclicity, and straight-line 
\cite{LB16,Abdulla14,Vijay-length}) that are still satisfied by string 
constraints that arise in practice. 
}
Being the most basic string operation,
concatenation is typically present in a string theory.
Constraints in the \emph{theory of concatenation} 
are symbolic executions (see (\ref{eq:symbex}))
with concatenation of string constants/variables in the
assignment ($f$ in (\ref{eq:symbex})) and equality/disequality checks of
variables in the assertions ($g$ in (\ref{eq:symbex})).
%Concatenation (+) and string equality (=) are typically present in a string 
%theory since they are the most basic string operations. 
Example in (\ref{eq:intro_ex}) is an instance of a constraint in this theory.
%For example, the
%expression $\varphi(x,y) \equiv\ x + \texttt{ba} + y = y + 
%\texttt{ab} 
%+ x$ is a constraint in the 
%theory, where $x$ and $y$ are string variables and the alphabet is
%$\{\texttt{a},\texttt{b}\}$.
%It can be satisfied by the assignment $y$ (resp.~$x$) is mapped to $\texttt{b}$
%(resp.~the empty string). 
The theory of concatenation was 
proven to be decidable in the seminal
paper by Makanin \cite{Makanin} on \emph{word equations}, followed by the
extension by B\"{u}chi and Senger \cite{buchi}.
This decidability holds even when
\emph{regular constraints} (i.e. regular expression matching, e.g., 
$y \in (\texttt{ab})^*$) --- useful to specify the set of ``bad'' strings ---
are allowed as an assertion \cite{Schulz}. 
%Decidability becomes slightly problematic beyond this.
%string operation (e.g. to specify the set of ``bad'' strings) which
%can be incorporated to the theory of concatenation (as an assertion) without 
%sacrificing decidability 
%It seems difficult, however, to extend this
%theory with other useful string operations while preserving decidability.
%For example, it is a long-standing open problem whether 
%A couple of decades after Makanin's result
%it was finally shown \cite{P04,J17} that the complexity of the theory of 
%concatenation with regular expression matching is PSPACE-complete.

%or the \emph{replaceall} function
%(replacing every occurrence of a string matching a pattern with another
%string) \cite{CCHLW18,fang-yu-circuits,YABI14,Stranger,S3,TCJ16} 

Sanitisers (e.g. htmlescape and backslash-escape)
and implicit browser transductions (e.g. innerHTML)
are two types of string functions that are frequently used in client-side
web applications. Many XSS vulnerabilities are caused by
subtle interactions between these functions and other parts of the
applications, e.g., see \cite{web-model,Kern14,DV13,LB16,mXSS}. 
\emph{Finite-state transducers} 
\cite{BEK,web-model,DV13,symbolic-transducer,LB16}
are a good formal model of such string functions that satisfy some
good closure and algorithmic properties. 
%This model is the class of
%\emph{finite-state transductions}
Roughly speaking, finite transducers are
finite-state machines that transform an input string to an output string. 
\OMIT{
The second model is the \emph{replaceall} function
\cite{fang-yu-circuits,YABI14,Stranger,S3,TCJ16,Saner}, i.e.,
replacing every occurrence of an input string matching a pattern with a constant
string. The second model is less expressive than the first.
}
Unfortunately, adding finite-state transductions to
the theory of concatenation (in the assignment of (\ref{eq:symbex})) results in 
undecidability \cite{LB16}.
More recently, a decidable logic with these additional string 
operations \cite{LB16} has been obtained by imposing 
the \emph{straight-line restriction}. %, which is
%syntactic restrictions (solved forms
%\cite{Vijay-length}, acyclicity \cite{Abdulla14,BFL13}, and straight-line
%\cite{LB16}) on the shape of string constraints. 
%a syntactic restriction on the shape of input constraints. 
This is done 
by \emph{disallowing string equality checks in the assertions} $g$ in 
(\ref{eq:symbex}). In other words, concatenation and finite-state transductions
can be used in an assignment, while only regular constraints can be used in
assertions. The string logic is still 
sufficiently expressive
for many examples that arise in practice \cite{LB16,HJLRV18}.


\OMIT{
However, there are many other useful string 
operations including string length function
\cite{Vijay-length,Berkeley-JavaScript}, replaceall
function (replacing every occurrence of a string matching a pattern with another
string) \cite{CCHLW18,fang-yu-circuits,YABI14,Stranger,S3,TCJ16}, 
finite-state transductions \cite{LB16,BEK,web-model,DV13}.
Adding them to the theory of concatenation
either results in an undecidable string theory \cite{LB16,BFL13,GB16}
or one whose decidability is a long-standing open problem \cite{Vijay-length}.
}


\OMIT{
Even though the complexity of the logic is EXPSPACE-complete 
\cite{LB16} (i.e. requires double exponential time in the worst case), 
a fast solver \cite{HJLRV18} --- exploiting alternating
automata and hardware verification --- has recently been developed.
}

Despite the expressive power of finite-state transducers, 
they cannot model some important string functions. We mention two examples. The first 
example is 
the 
replaceall functions $\replaceall_p(sub,rep)$ where the subject $sub$ and the replacement 
$rep$ are string \emph{variables}, i.e., 
replacing every matching of the pattern $p$ in the subject $sub$ by $rep$.
%replacing every occurrence of a string $s$ in subject $sub$ matching the pattern $p$ by $rep$. 
%As argued in \cite{CCHLW18},
Such replaceall
functions are important \cite{CCHLW18} for modelling string functions used in 
web 
templating like Mustache.js \cite{Mustache}. The more restricted replaceall
functions where $rep$ is a string constant can be modelled by finite-state  
transducers \cite{LB16}.
%It was shown in \cite{CCHLW18} that
%theory of concatenation with regular constraints and this general replaceall
%function is decidable whenever the straight-line restriction is imposed.
The second example is the string reverse function.

%restrictions limit the way the equality operator relates string variables in 
%the constraints. For example, we obtain the decidable \emph{straight-line logic}
%\cite{LB16} if we remove string equality from an assertion, but we allow


%
%
%For this reason, a lot of effort is spent instead on developing fast practical
%\emph{heuristics} for string solving
%\cite{Z3-str,Z3-str2,S3,TCJ16,YABI14,Berkeley-JavaScript,cvc4,HAMPI} without a
%guarantee of completeness. \anthony{More citation is needed here} 
%One fundamental question
%in constraint solving over strings, to which hitherto only partial answers are 
%available: 
%\emph{which string operations can we
%incorporate into a decidable theory over strings?}

%Talk about symbolic execution. Dynamic symbolic execution.

\smallskip
\noindent
\textbf{Contributions.} The main results in this paper can be summarised
as follows. We introduce \emph{parametric 
transducers}, an expressive formalism for modelling string (partial) functions 
$f: (\ialphabet^*)^\arity \to \ialphabet^*$ with multiple inputs $x_1,\ldots, x_\arity$. Parametric
transducers strictly generalise the standard finite-state transducers (which take only
one input) by allowing: (1) parameters $x_2,\ldots,x_\arity$ in the output
($x_1$, the first argument of $f$, is placed on the input tape), 
and (2) the two-way (left/right) head pointing to the input tape. 
%input head moving in two directions. 
Parametric transducers are capable of modeling the string functions as diverse as replaceall, string reverse, and concatenation, as well as finite-state transductions, thus \emph{unifying them into one single formalism}.
%In addition, 
%not only can parametric
%transducers model the $\replaceall_p(sub,rep)$ function, string reverse, and
%concatenation,
As a result of the expressibility, parametric transducers can model string functions required in \emph{context-sensitive
auto-sanitisation} in web templating systems \cite{SSS11}, e.g., Closure 
\cite{Closure} and Handlebars \cite{Handlebars}. 
We show \emph{decidability of path 
feasibility problem} of string manipulating programs that use parametric transducers in an 
assignment and regular constraints in an assertion. Our constraint language
is one of the \emph{most expressive decidable} string languages for symbolic executions
of programs with strings, and \emph{strictly} generalises 
%the decidability of 
the state-of-the-art decidable ones, e.g. 
the subcases of finite-state transducers \cite{LB16}
and replaceall \cite{CCHLW18}. We also provide a detailed complexity 
analysis\footnote{
\emph{Worst-case complexity} results of course do not prohibit fast solvers 
\emph{in practice}, e.g., SLOTH for the straight-line 
logic with finite transducers (EXPSPACE) 
\cite{HJLRV18}, and MONA for Weak Second-Order
Theory of Successors (nonelementary). Rather, they
\emph{inform} algorithmic techniques that could work in practice, e.g., 
symbolic techniques.},
which ranges between EXPSPACE (same as in \cite{LB16,CCHLW18}) and
nonelementary (i.e. time complexity cannot be bounded by a $k$-fold exponential
function for any fixed $k > 0$). 
Finally, we extend our results to symbolic automata/transducers
\cite{BEK,symbolic-transducer,DV13,symbolic-transducer-power}, which are crucial for practical 
applications requiring large alphabets (e.g.~UTF16).

\input{auto-sanitisation}
