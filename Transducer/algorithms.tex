%!TEX root = main.tex

%\section{Algorithmic results}

\section{A generic decision procedure with recognisable relations} \label{sec:algo}

In this section,  we present a generic decision procedure for the path feasibility problem %$\straightline[\transet]$ 
of string manipulating program in the SSA form (defined in Section~\ref{subsec:symexe}), 
based on the notion of recognisable relations. We assume that each assertion \ASSERT{$g(x_1,\ldots,x_n)$} satisfies that $g(x_1,\ldots,x_n)$ is a conjunction of regular constraints
 %each variable $x_i$ is constrained regularly, i.e., it is of the form 
 $x_i \in \Aut$ where $\Aut$ is an \FA{}.   \zhilin{I put the assumption that $g$ is a conjunction of regular constraints here.}

%
%
%an $\straightline[\transet]$ formula $\varphi \wedge \psi$ where $\varphi$ and $\psi$ are relational and  regular constraints respectively.

For the string function $f(x_1,\ldots,x_n)$, we assume that its pre-image of a regular language is a recognisable relation defined below.  

\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \ldots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \ldots\times L^{(i)}_k$ where $L^{(i)}_j$ is regular for each $j\in [k]$.
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}


For a recognisable relation $R$, a \emph{representation} of $R$ is a collection of tuples $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_k)_{i\in [n]}$  such that 
$R = \bigcup_{i=1}^n \Lang(\Aut^{(i)}_1) \times \ldots\times \Lang(\Aut^{(i)}_k)$, where each $\Aut^{(i)}_j$ is an \FA. 
%The numbers $k, n$ are called the \emph{dimension} and \emph{width}  of the representation respectively, 
%Each \FA{} $\Aut^{(i)}_j$ is called an \emph{atom} of the representation.
%
Furthermore, to obtain tight space complexity bounds (in some cases), we use an alternative  \emph{conjunctive} representation of \FA{}s. %iof each atoms of the representation, 
More precisely, for each \FA{} $\Aut$ such that $\Lang(\Aut) = \Lang(\Aut_1) \cap \ldots \cap \Lang(\Aut_m)$, where each $\Aut_i$ is an \FA{}, we represent $\Aut$ \emph{conjunctively} as a tuple $(\Aut_1, \ldots, \Aut_m)$, which takes $\sum \limits_{i \in [m]} |\Aut_i|$ space, while the standard product-automaton representation takes $\prod \limits_{i \in [m]} |\Aut_i|$ space.
%More precisely, we encode each \FA{} as 
%$((\controls, \transrel), S)$ such that $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$ is the \emph{conjunctive} acceptance condition such that a string is accepted by $((\controls, \transrel), S)$ if for \emph{every} $(q, q') \in S$, there is a run of $(\controls, \transrel)$ on the string where $q$ and $q'$ are the first and last state of the run respectively. 
%
%Note that $\Lang(((\controls, \transrel), S)) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$, where $\cB_{q,q'}$ is the \FA{} $(\controls, q, \{q'\}, \transrel)$.
%
%We remark that the nonemptiness checking  can be done in nondeterministic logarithmic space for the standard representation of \FA{}s, but requires polynomial space for the conjunctive representation. (One needs to build up the product automaton which is of size $|Q|^{|S|}$.) 
%
Accordingly, a representation of $R$, say $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_k)_{i\in [n]}$, is called a \emph{conjunctive representation} if each \FA{} $\Aut^{(i)}_j$ is represented conjunctively.
More explicitly, a conjunctive representation of $R$ is of the form 
%
$$\left((\Aut^{(i)}_{1, 1}, \ldots, \Aut^{(i)}_{1, m_{i, 1}}), \ldots, (\Aut^{(i)}_{k, 1}, \ldots, \Aut^{(i)}_{k, m_{i,k}})\right)_{i\in [n]},$$ 
where $\max(\{m_{i,1},\ldots, m_{i,k} \mid i \in [n]\})$ is called the \emph{width}, $\Aut^{(i)}_{r, s}$'s are called the \emph{atoms}, and the maximum size of the atoms is called the \emph{atom size} of the representation respectively.
%
%Every (standard) representation of $R$  can be transformed into a conjunctive one easily. For instance, let $(\Aut_1, \Aut_2)$ be a representation of $R$ with $\Aut_i = (\controls_i, q_{i,0}, \finals_i, \transrel_i)$ for $i=1,2$, then $R$ is conjunctively represented by 
%
%$$\left(\left((\controls_1, \transrel_1), \{(q_{1,0}, q_1)\}\right), \left((\controls_2, \transrel_2), \{(q_{2,0}, q_2)\} \right)\right)_{(q_1, q_2) \in \finals_1 \times  \finals_2}.$$

%as follows: 
%Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Then $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$. Furthermore,  $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q\})$ can be decoupled as a pair $\cC^{(i)}_{j, (q^{(i)}_{0, j}, q)} = \left(\left(\controls^{(i)}_j,  \transrel^{(i)}_j \right), \{(q^{(i)}_{0,j}, q)\} \right)$. Therefore, $R$ is conjunctively represented by 
%
%$$\bigcup_{i \in [n], (q^{(i)}_1, \ldots, q^{(i)}_k) \in \finals^{(i)}_1 \times \ldots \times   \finals^{(i)}_k }  \cC^{(i)}_{1, (q^{(i)}_{0, 1}, q^{(i)}_1)}\times \ldots \times \cC^{(i)}_{k, (q^{(i)}_{0, k}, q^{(i)}_k)} .$$

%
%
%\footnote{Each representation can be turned into one satisfying the requirement as follows: Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Since $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$, we have $R = \bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \Lang(\Aut^{(i)}_1(q^{(i)}_{0, 1}, \{q^{(i)}_1\})) \times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\}))$. Each NFA $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})$ can be encoded as a pair $((\controls^{(i)}_j,  \transrel^{(i)}_j), \{(q^{(i)}_{0,j}, q^{(i)}_j)\})$.} 
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
It follows that one can reconstruct $R$ by using the alternative representation of automata by  
%we do the following transformation:
%
%Each representation can be turned into one satisfying the requirement as follows: 
%we have 
\begin{align*}
R  & =   \bigcup_{i=1}^n \prod_{j=1}^k \Lang(\Aut^{(i)}_j) \\
& =   \bigcup_{i=1}^n  \prod_{j=1}^k \bigcup \limits_{q_j \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q_j\}))\\
&=	\bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \prod_{j=1}^k \Lang(\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})) 
%\times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\})).
\end{align*}
%
%
%that each atom $\Aut^{(i)}_j$ is \emph{succinctly} encoded into a pair $((\controls, \transrel), S)$, where $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$, such that $\Lang(\Aut^{(i)}_j) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$ with $\cB_{q,q'} = (\controls, q, \transrel, \{q'\})$. 
%
\tl{shall we call it something like compact size, so later we can avoid "the size of the succinctly encoded NFA"? }
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%The \emph{size} of a conjunctive representation $((\controls, \transrel), S)$ is defined as $|\controls|$. Moreover, we define the  \emph{atom size} of a conjunctive representation of $R$ to be the maximum size of the atoms therein.


In the sequel, %when we say a representation of $R$, 
the representation of $R$ simply refers to a \emph{conjunctive} representation of $R$. Moreover, a conjunctive \FA{} refers to a tuple $(\Aut_1, \ldots, \Aut_m)$ where each $\Aut_i$ is an \FA.
%$((\controls, \transrel), S)$ whereas an \FA{} refers to an \FA{} in the original form, i.e. $(\controls, q_0, \finals, \transrel)$.

\medskip

%Let $\Transducer$ be a parametric transducer %from $\transet$ with $k$ parameters ($k\geq 0$), and 
As we have discussed in Section~\ref{subsec:symexe}, a string function $f(x_1, \cdots, x_k)$ with $k$ parameters ($k\geq 1$) gives rise to a relation $R_f\subseteq (\Sigma^*)^k \times \Sigma^*$. Let $\Aut$ be an FA. The \emph{pre-image} of $\Aut$ under $f$, denoted by $\Pre_{R_f}(\Aut)$, is 
\[\left\{(w_1,\ldots, w_k) \in (\Sigma^*)^k \mid \exists w.\ w\in f(w_1, \cdots, w_k)\text{ and } w\in\Lang(\Aut) \right\}.\]
%w is (one of) the output(s) of the string function $f$.  

%
%the set of tuples $(w, w_1,\ldots, w_k)$ such that there is an accepting run of $\Transducer$ on $w$ with output $w'\in \Lang(\Aut)$ when equipped with the parameters $w_1,\ldots, w_k$. 

\zhilin{i stopped here.}

The main result of this section is a generic decision procedure for the path feasibility problem of string manipulating program $S$ in the SSA form, under the \prerec{} assumption defined below:
\begin{quote}
%\item
{\bf The \prerec{} assumption}. For each string function $f$ in $S$ and each conjunctive \FA{} $\Aut$,  $\Pre_{R_f}(\Aut)$ is a recognisable relation. Furthermore, the space to compute a representation of $\Pre_{R_f}(\Aut)$ and the atom size of such a representation\footnote{Usually the amount of space is at least as large as the size of the representation; here for simplicity we assume that they are asymptotically the same.} are both bounded by $\ell(|f|, |\Aut|)$ for some monotone function $\ell$.  
%
%\item[A2] Each assertion $g$ in $S$ is given as a conjunction of atomic regular constraint $x\in \Aut$. 
\end{quote} 

Here $|f|$ is the size of a representation of $f$; the concrete definition depends on the form of $f$, which will be given when the generic decision procedure is instantiated in Section~\ref{sec-instan}. 

Given a string manipulating program $S$, w.l.o.g., we assume that each variable appears at most once\footnote{If, for instance, $x\in \Aut_1$ and $x\in \Aut_2$ both appear in the assertions of $S$, then we can lump them using $x\in \Aut_1 \times \Aut_2$.} in the assertions of $S$. Furthermore, we define $\rcdep(S)$ to be the number of assignments in $S$, $\rcdim(S)$ to be the maximum number of arguments of string functions in the assignments of $S$, $\rcphi(S)$ to be the maximum size of the representations of these string functions, and $\rcpsi(S)$ to be the maximum size of the \FA{}s appearing in the assertions of $S$. 


For $\ell:\Nat^2\rightarrow \Nat$, we define $\ell^{\langle n \rangle}(j, k)$ ($n\geq 1$) as $\ell^{\langle 1 \rangle}(j,k)= \ell(j, k)$ and $\ell^{\langle n+1 \rangle }(j, k) = \ell(j, \ell^{\langle n \rangle}(j,k))$. 
\mat{
    Do we need to talk about transducers in this section?
    Could we just get away with any relation $R$ such that $Pre_R(A)$ can be constructed effectively?
    It's a bit sad to introduce a generic framework, then tie it unnecessarily to parametric transducers.
    The complexity would need adjusting i guess, though i think it has issues already:
    \begin{itemize}
    \item
        $|\varphi|$ is not defined
    \item
        there is no given space bound on effectively constructing a representation of Pre -- only the size of the output is considered.
        Presumably the complexity given below assumes that the amount of space required to compute the representation is no more than the size of the representation.
    \end{itemize}
}
\tl{I have tried to accommodate this, though need to proof read carefully.}


%==== theorem ==============================
\begin{theorem}\label{thm-generic-dec}
	Given a string manipulating program $S$ satisfying the \prerec{} assumption, the path feasibility problem of $S$ can be decided in \emph{nondeterministic} 
	$|\vars(S)|(\rcdim(S)+1)^{c \rcdep(S)} \left(\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) \right)^c$ space for some $c > 0$.
\end{theorem}

%\begin{theorem}\label{thm-generic-dec}
%Suppose that %$\transet$ satisfies that 
%for each $\Transducer \in \transet$ and conjunctive NFA $\Aut$, $\Pre_\Transducer(\Aut)$ is a recognisable relation.  Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $f(|\Transducer|, |\Aut|)$ for some monotone function $f$, can be determined effectively. Then the satisfiability of a given $\straightline[\transet]$ formula $\varphi \wedge \psi$ can be decided in \emph{nondeterministic} 
%%\tl{why not remove  nondeterministic?} 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)}|\psi| \cdot (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%%, where $K$ is the maximum number of parameters of 
%%transducers appearing in the constraints, 
%%$D$ is the maximum length of the paths in $\cG(\varphi)$.
%\end{theorem}

%\begin{proof}
%Let $\varphi \wedge \psi$ be an $\straightline[\transet]$ formula. 

The rest of this section is devoted to the proof of Theorem~\ref{thm-generic-dec}.

Let $S$ be a string manipulating problem satisfying the \prerec{} assumption. 
We shall present a nondeterministic algorithm to decide the path feasibility problem of $S$.

We first \emph{nondeterministically} compute $\cE(x)$, a collection of conjunctive FAs over the alphabet $\Sigma$, for each variable $x \in \vars(S)$. %, by utilising the dependency graph $\cG(\varphi)$. 
% , in a top-down manner.

Initially, %let $\cG_0 := \cG(\varphi)$, and  
we construct $\cE_0(x)$ as follows: For each %conjunct 
%\mat{Can we use different terminology: we now have conjunctive NFA and conjuncts, which risks confusion}
$x \in \Aut$ appearing in the assertion of $S$, where $\Aut$ is an FA, let $\Aut = (\controls, q_0, \transrel, \finals)$, we \emph{nondeterministically} select one state $q \in \finals$ and include $((\controls, \transrel), \{(q_0, q)\})$ into $\cE_0(x)$.
  
 %$\Aut$ $\left\{\Aut \mid x\in \Aut \text{ is a conjunct of }\psi \right\}$ for each variable $x$. 

%Starting from $\cG_0$ we repeat the following procedure until %we reach some $i$ where 
%$\cG_i$ becomes empty, i.e., a graph without edges.

Notice that $S$ has $\rcdep(S)$ assignments. we start from the last assignment of $S$, and set $i:=1$. Sequentially for each assignment of $S$ we compute  $\cE_{i}$ until $i=\rcdep(S)+1$.  
%
%select (nondeterministically) a vertex $x$ of $\cG_i$ such that $x$ has no predecessors and has $k+1$ outgoing edges ($k\geq 0$) via edges $(x, (\Transducer, 0), y_0)$ and $(x, (\Transducer, j), y_j)$ with $j \in [k]$ in $\cG_i$. 
%(Intuitively this corresponds to a relational constraint $x=T(y_0, \vec{y})$ for $\vec{y}=(y_1, \ldots, y_k)$.
%Note that two different outgoing edges of $x$ in $\cG_i$ may correspond to the same variable.)

For the $i$-th iteration, suppose the assignment to be $y:= f(x_1, \cdots, x_k)$ with $k\geq 1$, and  $\cE_i(y)=\{\Aut_1, \ldots, \Aut_n\}$, 
where $\Aut_j$ is a conjunctive FA for each $j \in [n]$.
%$(\Sigma, Q_j, q_{0,j}, F_j, \delta_j)$ 
By the premise of the theorem, $\Pre_{R_f}(\Aut_j)$ is a recognisable relation and a representation of which, say $(\Aut^{(j')}_{j, 0}, \Aut^{(j')}_{j, 1}, \ldots, \Aut^{(j')}_{j, k})_{ j'  \in [m_j]}$, can be computed effectively.
Then $\cE_{i+1}(x)$ for $x \in  \{x_1,\cdots, x_k\}$ is updated as follows: %and $\cG_{i+1}$ are computed as follows:
\begin{enumerate}
\item For each $j \in [n]$, nondeterministically select a tuple $\left(\Aut^{(r_j)}_{j, 0}, \ldots, \Aut^{(r_j)}_{j, k}\right)$ for some $r_j \in [m_j]$.
%
\item For each $x \in \{x_1,\ldots, x_k\}$, let
\[
    \cE_{i+1}(x):= \cE_{i}(x) \cup \left\{\Aut^{(r_j)}_{j, h} \mid  j \in [n], h \in [k], x = x_h \right\}.
\]
[For each vertex $z'  {\notin} \{y_0,\ldots, y_k\}$, let $\cE_{i+1}(z') := \cE_i(z')$.]
%We set $\cE_{i+1}(x) = \emptyset$.
%
%\item Let $\cG_{i+1}:= \cG_i \backslash \{(x, (\Transducer, j), y_j) \mid j \in \{0\} \cup [k]\}$.
\end{enumerate}
%For each iteration, $i$ is updated by  $i: = i+1$.
%\end{enumerate}
%
After all assignments of $S$ are scanned,  let $\cE(x):=\cE_{\rcdep(S)}(x)$ for each variable $x$.


%%=================================================================
%%=================================================================
\hide{
%\begin{example}
\tl{tbh, I think the algo is clear enough and the example does not add too much.}\zhilin{maybe, but the example is at least more concrete. Moreover, the description of the algorithm is short and dry, maybe just use the example to let the reader spend a bit more time on the algorithm and digest, although with some redundancy. We may remove it if we run out of space. May decide this later.}
Let us use an example to help the reader understand the computation of $\cE_{i+1}$ from $\cE_i$.  Suppose that in $\cG_i$, to compute $\cE_{i+1}$, we select a variable $x$, which has no predecessors and three outgoing edges, say $(x, (\Transducer, 0), y)$, $(x, (\Transducer, 1), z)$, and $(x, (\Transducer, 2), y)$, where $y$ and $z$ are two distinct variables, moreover, $\cE_i(x) = \{\Aut_1, \Aut_2\}$. Let us also assume that  $\Pre_{\Transducer}(\Aut_1)$ (resp. $\Pre_{\Transducer}(\Aut_2)$) is represented by $(\Aut^{(j')}_{1, 0}, \Aut^{(j')}_{1, 1}, \Aut^{(j')}_{1, 2})_{ j'  \in [2]}$ (resp. $(\Aut^{(j')}_{2, 0}, \Aut^{(j')}_{2, 1}, \Aut^{(j')}_{2, 2})_{ j'  \in [3]}$). If for $j = 1$ (resp. $j=2$), $(\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 1}, \Aut^{(1)}_{1, 2})$  (resp. $\left(\Aut^{(3)}_{2, 0}, \Aut^{(3)}_{2, 1}, \Aut^{(3)}_{2, 2}\right)$)  is selected, then $\cE_{i+1}(y) = \cE_i(y) \cup \{\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 2}, \Aut^{(3)}_{2, 0} \cup \Aut^{(3)}_{2, 2}\}$ and $\cE_{i+1}(z) = \cE_{i}(z) \cup \{\Aut^{(1)}_{1, 1}, \Aut^{(3)}_{2, 1}\}$. 
\tl{I have not updated this part as likely the proof will go to appendix}
}
%%=================================================================
%%=================================================================


To decide the path feasibility of $S$, we have the following nondeterministic algorithm: first (nondeterministically) construct the sets $\cE(x)$ for $x \in \vars(S)$ as detailed above, then 
%guessing an accepting run of the product of NFAs 
checking the emptiness of the product of conjunctive \FA{}s in $\cE(x)$ for each $x \in \vars(S)$.

\begin{example}
An example here to illustrate the generic decision procedure.
\end{example}

\zhilin{I simplified the complexity analysis. It is up to discussion whether it should be put in the appendix.}
\paragraph{Complexity analysis.}
For each $i$, 
%\begin{itemize}
%\item 
let $M_i$ be the maximum number of elements in $\cE_i(x)$ for $x  \in \vars(S)$,
%\item 
and $N_i$ be the maximum size of the conjunctive FAs in $\bigcup \limits_{x \in \vars(S)} \cE_i(x)$.
%\end{itemize}
Then we have $M_{i+1} \le (\rcdim(S)+1)M_i $. Moreover, since each string function $f$ satisfies   $|f| \le \rcphi(S)$, we have that $N_{i+1} \le \ell(|f|, N_i) \le \ell(\rcphi(S), N_i)$ (note that we have assumed that $\ell$ is monotonic). Because for each $x \in \vars(S)$, %$\cE_0(x)$ contains at most $|\psi|$ elements, and 
the conjunctive \FA{} in $\cE_0(x)$ is of size bounded by $\rcpsi(S)$, we have that for each $x \in \vars(S)$, $\cE(x)$ contains at most $(\rcdim(S)+1)^{\rcdep(S)}$ elements, and each conjunctive \FA{} in $\cE(x)$ is of size bounded by $\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$. 
We emphasise that, according to the \prerec{} assumption, the construction of these \FA{}s can be done in $\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$ space as well. 
Therefore, for each $x \in \vars(S)$, the product of these conjunctive \FA{}s  in $\cE(x)$ is of size $ (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^{(\rcdim(S)+1)^{\rcdep(S)}}$. Since the nonemptiness of a conjunctive \FA{} can be solved in polynomial space, we conclude that the aforementioned nondeterministic algorithm takes 
$$|\vars(S)|(\rcdim(S)+1)^{c \rcdep(S)} \left(\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) \right)^c$$
 space for some constant $c > 0$.



%%%%===========================original complexity analysis removed ====================================
%%%%===========================original complexity analysis removed ==================================
\hide{
%
Since each conjunctive FA $((Q, \delta), S)$ in $\cE(x)$ encodes an FA of size $|Q|^{|S|} \le |Q|^{|Q|^2} \approx 2^{O(|Q|^2 \log |Q|)}$, 
%\tl{I do not quite understand here} \zhilin{explained in the definition of conjunctive encodings of atoms} 
it holds that the product automaton of FAs in $\cE(x)$ is of size bounded by 
%
$$(\rcdim(S)+1)^{\rcdep(S)} \cdot 2^{\mathcal{O}((\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) )}.$$
%
Because the nonemptiness of an FA 
can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic space bounded by 
$$\mathcal{O}(\rcdep(S) (\log ((\rcdim(S)+1))) \cdot (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$
%=======
%$$2^{O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) )}.$$
%%
%Because the nonemptiness of an NFA 
%can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic 
%$$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) ) \mbox{ space.}$$
%>>>>>>> e8a132a375e6d8f5c007d33427151d3386a5f8ee
%
Therefore, overall, the space used by the aforementioned nondeterministic algorithm is 
$$\mathcal{O}((\rcdim(S)+1)^{\rcdep(S)} \cdot  (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log f^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$ 
%\zhilin{Please check the complexity}
%Therefore, the satisfiability can be checked by a nondeterministic Turing machine with 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%\end{proof}
}
