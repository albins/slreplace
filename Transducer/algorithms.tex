%!TEX root = main.tex

%\section{Algorithmic results}

\section{A generic decision procedure with recognisable relations} \label{sec:algo}

In this section,  we present a generic decision procedure for the path feasibility problem %$\straightline[\transet]$ 
of string manipulating program in the SSA form (defined in Section~\ref{subsec:symexe}), 
based on the notion of recognisable relations. We assume that each assertion \ASSERT{$g(x_1,\ldots,x_n)$} satisfies that $g(x_1,\ldots,x_n)$ is a conjunction of regular constraints
 %each variable $x_i$ is constrained regularly, i.e., it is of the form 
 $x_i \in \Aut$ where $\Aut$ is an \FA{}.   \zhilin{I put the assumption that $g$ is a conjunction of regular constraints here.}

%
%
%an $\straightline[\transet]$ formula $\varphi \wedge \psi$ where $\varphi$ and $\psi$ are relational and  regular constraints respectively.

For the string function $f(x_1,\ldots,x_n)$, we assume that its pre-image of a regular language is a recognisable relation defined below.  

\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \ldots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \ldots\times L^{(i)}_k$ where $L^{(i)}_j$ is regular for each $j\in [k]$.
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}


For a recognisable relation $R$, a \emph{representation} of $R$ is a collection of tuples $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_k)_{i\in [n]}$  such that 
$R = \bigcup_{i=1}^n \Lang(\Aut^{(i)}_1) \times \ldots\times \Lang(\Aut^{(i)}_k)$, where each $\Aut^{(i)}_j$ is an \FA. 
%The numbers $k, n$ are called the \emph{dimension} and \emph{width}  of the representation respectively, 
%Each \FA{} $\Aut^{(i)}_j$ is called an \emph{atom} of the representation.
%
Furthermore, to obtain tight space complexity bounds (in some cases), we use an alternative  \emph{conjunctive} representation of \FA{}s. %iof each atoms of the representation, 
More precisely, for each \FA{} $\Aut$ such that $\Lang(\Aut) = \Lang(\Aut_1) \cap \ldots \cap \Lang(\Aut_m)$, where each $\Aut_i$ is an \FA{}, we represent $\Aut$ \emph{conjunctively} as a tuple $(\Aut_1, \ldots, \Aut_m)$, which takes $\sum \limits_{i \in [m]} |\Aut_i|$ space, while the standard product-automaton representation takes $\prod \limits_{i \in [m]} |\Aut_i|$ space.
%More precisely, we encode each \FA{} as 
%$((\controls, \transrel), S)$ such that $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$ is the \emph{conjunctive} acceptance condition such that a string is accepted by $((\controls, \transrel), S)$ if for \emph{every} $(q, q') \in S$, there is a run of $(\controls, \transrel)$ on the string where $q$ and $q'$ are the first and last state of the run respectively. 
%
%Note that $\Lang(((\controls, \transrel), S)) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$, where $\cB_{q,q'}$ is the \FA{} $(\controls, q, \{q'\}, \transrel)$.
%
We remark that the nonemptiness checking  can be done in nondeterministic logarithmic space for the standard representation of \FA{}s, but requires polynomial space for the conjunctive representation. (One needs to build up the product automaton which is of exponential size.) 
%
Accordingly, a representation of $R$, say $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_k)_{i\in [n]}$, is called a \emph{conjunctive representation} if each \FA{} $\Aut^{(i)}_j$ is represented conjunctively.
More explicitly, a conjunctive representation of $R$ is of the form 
%
$$\left((\Aut^{(i)}_{1, 1}, \ldots, \Aut^{(i)}_{1, m_{i, 1}}), \ldots, (\Aut^{(i)}_{k, 1}, \ldots, \Aut^{(i)}_{k, m_{i,k}})\right)_{i\in [n]},$$ 
%
where $\max(\{m_{i,1},\ldots, m_{i,k} \mid i \in [n]\})$ is called the \emph{width}, $\Aut^{(i)}_{r, s}$'s are called the \emph{atoms}, and the maximum size of the atoms is called the \emph{atom size} of the representation respectively. Moreover, each tuple 
$$\left((\Aut^{(i)}_{1, 1}, \ldots, \Aut^{(i)}_{1, m_{i, 1}}), \ldots, (\Aut^{(i)}_{k, 1}, \ldots, \Aut^{(i)}_{k, m_{i,k}})\right)$$ 
is called a \emph{component} of the representation. 
%
%Every (standard) representation of $R$  can be transformed into a conjunctive one easily. For instance, let $(\Aut_1, \Aut_2)$ be a representation of $R$ with $\Aut_i = (\controls_i, q_{i,0}, \finals_i, \transrel_i)$ for $i=1,2$, then $R$ is conjunctively represented by 
%
%$$\left(\left((\controls_1, \transrel_1), \{(q_{1,0}, q_1)\}\right), \left((\controls_2, \transrel_2), \{(q_{2,0}, q_2)\} \right)\right)_{(q_1, q_2) \in \finals_1 \times  \finals_2}.$$

%as follows: 
%Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Then $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$. Furthermore,  $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q\})$ can be decoupled as a pair $\cC^{(i)}_{j, (q^{(i)}_{0, j}, q)} = \left(\left(\controls^{(i)}_j,  \transrel^{(i)}_j \right), \{(q^{(i)}_{0,j}, q)\} \right)$. Therefore, $R$ is conjunctively represented by 
%
%$$\bigcup_{i \in [n], (q^{(i)}_1, \ldots, q^{(i)}_k) \in \finals^{(i)}_1 \times \ldots \times   \finals^{(i)}_k }  \cC^{(i)}_{1, (q^{(i)}_{0, 1}, q^{(i)}_1)}\times \ldots \times \cC^{(i)}_{k, (q^{(i)}_{0, k}, q^{(i)}_k)} .$$

%
%
%\footnote{Each representation can be turned into one satisfying the requirement as follows: Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Since $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$, we have $R = \bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \Lang(\Aut^{(i)}_1(q^{(i)}_{0, 1}, \{q^{(i)}_1\})) \times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\}))$. Each NFA $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})$ can be encoded as a pair $((\controls^{(i)}_j,  \transrel^{(i)}_j), \{(q^{(i)}_{0,j}, q^{(i)}_j)\})$.} 
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
It follows that one can reconstruct $R$ by using the alternative representation of automata by  
%we do the following transformation:
%
%Each representation can be turned into one satisfying the requirement as follows: 
%we have 
\begin{align*}
R  & =   \bigcup_{i=1}^n \prod_{j=1}^k \Lang(\Aut^{(i)}_j) \\
& =   \bigcup_{i=1}^n  \prod_{j=1}^k \bigcup \limits_{q_j \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q_j\}))\\
&=	\bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \prod_{j=1}^k \Lang(\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})) 
%\times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\})).
\end{align*}
%
%
%that each atom $\Aut^{(i)}_j$ is \emph{succinctly} encoded into a pair $((\controls, \transrel), S)$, where $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$, such that $\Lang(\Aut^{(i)}_j) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$ with $\cB_{q,q'} = (\controls, q, \transrel, \{q'\})$. 
%
\tl{shall we call it something like compact size, so later we can avoid "the size of the succinctly encoded NFA"? }
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%The \emph{size} of a conjunctive representation $((\controls, \transrel), S)$ is defined as $|\controls|$. Moreover, we define the  \emph{atom size} of a conjunctive representation of $R$ to be the maximum size of the atoms therein.


In the sequel, %when we say a representation of $R$, 
the representation of $R$ simply refers to a \emph{conjunctive} representation of $R$. 

%Moreover, a conjunctive \FA{} refers to a tuple $(\Aut_1, \ldots, \Aut_m)$ where each $\Aut_i$ is an \FA. The \emph{size} of a conjunctive \FA{} $\Aut = (\Aut_1, \ldots, \Aut_m)$, denoted by $|\Aut|$, is defined as $\sum \limits_{i \in [m]} |\Aut_i|$.



\medskip

%Let $\Transducer$ be a parametric transducer %from $\transet$ with $k$ parameters ($k\geq 0$), and 
As we have discussed in Section~\ref{subsec:symexe}, a string function $f(x_1, \cdots, x_k)$ with $k$ parameters ($k\geq 1$) gives rise to a relation $R_f\subseteq (\Sigma^*)^k \times \Sigma^*$. Let $\Aut$ be an FA. The \emph{pre-image} of $\Aut$ under $f$, denoted by $\Pre_{R_f}(\Aut)$, is 
\[\left\{(w_1,\ldots, w_k) \in (\Sigma^*)^k \mid \exists w.\ w\in f(w_1, \cdots, w_k)\text{ and } w\in\Lang(\Aut) \right\}.\]
%w is (one of) the output(s) of the string function $f$.  

%
%the set of tuples $(w, w_1,\ldots, w_k)$ such that there is an accepting run of $\Transducer$ on $w$ with output $w'\in \Lang(\Aut)$ when equipped with the parameters $w_1,\ldots, w_k$. 


The main result of this section is a generic decision procedure for the path feasibility problem of string manipulating program $S$ in the SSA form, under the \prerec{} assumption defined below:
\begin{quote}
%\item
{\bf The \prerec{} assumption}. For each string function $f$ with $k$ arguments in $S$ and each \FA{} $\Aut$,  $\Pre_{R_f}(\Aut)$ is a recognisable relation. Furthermore, a representation of $\Pre_{R_f}(\Aut)$ can be computed effectively, where the width and atom size  
%\footnote{Usually the amount of space is at least as large as the size of the representation; here for simplicity we assume that they are asymptotically the same.} 
are bounded by $\ell_w(|f|, |\Aut|)$ and $\ell_a(|f|, |\Aut|)$ respectively, in addition, a component of the representation can be \emph{nondeterministically} computed in $k \cdot \ell_w(|f|, |\Aut|)\cdot \ell_a(|f|, |\Aut|)$ space, where $\ell_w$ and $\ell_a$ are two monotone functions. 
%
%\item[A2] Each assertion $g$ in $S$ is given as a conjunction of atomic regular constraint $x\in \Aut$. 
\end{quote} 

Here $|f|$ is the size of a representation of $f$; the concrete definition depends on the form of $f$, which will be given when the generic decision procedure is instantiated in Section~\ref{sec-instan}. 

Given a string manipulating program $S$, 
%w.l.o.g., we assume that each variable appears at most once\footnote{If, for instance, $x\in \Aut_1$ and $x\in \Aut_2$ both appear in the assertions of $S$, then we can lump them using $x\in \Aut_1 \times \Aut_2$.} in the assertions of $S$. 
%Furthermore, 
we define $\rcdep(S)$ to be the number of assignments in $S$, $\rcdim(S)$ to be the maximum number of arguments of string functions in the assignments of $S$, $\rcphi(S)$ to be the maximum size of the representations of these string functions, $\rcpsi(S)$ to be the maximum size of the \FA{}s appearing in the assertions of $S$, and $\rcreg(S)$ to be the maximum number of atomic regular constraints for each $x \in \vars(S)$.



For $\ell: \Nat^2 \rightarrow \Nat$, we define $\ell^{\langle n \rangle}(j, k)$ ($n \geq 1$) as $\ell^{\langle 1 \rangle}(j,k)= \ell(j, k)$ and $\ell^{\langle n+1 \rangle }(j, k) = \ell(j, \ell^{\langle n \rangle}(j,k))$. 
\mat{
    Do we need to talk about transducers in this section?
    Could we just get away with any relation $R$ such that $Pre_R(A)$ can be constructed effectively?
    It's a bit sad to introduce a generic framework, then tie it unnecessarily to parametric transducers.
    The complexity would need adjusting i guess, though i think it has issues already:
    \begin{itemize}
    \item
        $|\varphi|$ is not defined
    \item
        there is no given space bound on effectively constructing a representation of Pre -- only the size of the output is considered.
        Presumably the complexity given below assumes that the amount of space required to compute the representation is no more than the size of the representation.
    \end{itemize}
}
\tl{I have tried to accommodate this, though need to proof read carefully.}


%==== theorem ==============================
\begin{theorem}\label{thm-generic-dec}
	Given a string manipulating program $S$ satisfying the \prerec{} assumption, the path feasibility problem of $S$ can be decided in \emph{nondeterministic} 
	XXX space.
\end{theorem}

%\begin{theorem}\label{thm-generic-dec}
%Suppose that %$\transet$ satisfies that 
%for each $\Transducer \in \transet$ and conjunctive NFA $\Aut$, $\Pre_\Transducer(\Aut)$ is a recognisable relation.  Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $f(|\Transducer|, |\Aut|)$ for some monotone function $f$, can be determined effectively. Then the satisfiability of a given $\straightline[\transet]$ formula $\varphi \wedge \psi$ can be decided in \emph{nondeterministic} 
%%\tl{why not remove  nondeterministic?} 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)}|\psi| \cdot (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%%, where $K$ is the maximum number of parameters of 
%%transducers appearing in the constraints, 
%%$D$ is the maximum length of the paths in $\cG(\varphi)$.
%\end{theorem}

%\begin{proof}
%Let $\varphi \wedge \psi$ be an $\straightline[\transet]$ formula. 

The rest of this section is devoted to the proof of Theorem~\ref{thm-generic-dec}.

Let $S$ be a string manipulating problem satisfying the \prerec{} assumption. 
We shall present a nondeterministic algorithm to decide the path feasibility problem of $S$.

We first \emph{nondeterministically} compute $\cE(x)$, a collection of conjunctive FAs over the alphabet $\Sigma$, for each variable $x \in \vars(S)$. %, by utilising the dependency graph $\cG(\varphi)$. 
% , in a top-down manner.

  
 %$\Aut$ $\left\{\Aut \mid x\in \Aut \text{ is a conjunct of }\psi \right\}$ for each variable $x$. 

%Starting from $\cG_0$ we repeat the following procedure until %we reach some $i$ where 
%$\cG_i$ becomes empty, i.e., a graph without edges.

Notice that $S$ has $\rcdep(S)$ assignments. 
%
Initially, let $i: = \rcdep(S)$, and   
for each $x \in \vars(S)$, let $\cE_{\rcdep(S)}(x)$ be the set of \FA{}s $\Aut$ such that  
$x \in \Aut$ appears in an assertion of $S$. We iterate the following procedure and compute $\cE_{i}$ until $i=0$.
%

%We start from the last assignment of $S$, and set $i:=\rcdep(S)$. Sequentially for each assignment of $S$ we compute  $\cE_{i}$ until $i=0$.  

For the $i$-th iteration with $i > 0$, suppose the $i$-th assignment to be $y:= f(x_1, \cdots, x_k)$ with $k\geq 1$, and  $\cE_i(y)=\{\Aut_1, \ldots, \Aut_r\}$, 
where $\Aut_j$ is an  \FA{} for each $j \in [r]$.
%$(\Sigma, Q_j, q_{0,j}, F_j, \delta_j)$ 
By the premise of the theorem, for each $j \in [r]$, $\Pre_{R_f}(\Aut_j)$ is a recognisable relation and a representation of which, say 
%
$$\left((\Aut^{(j')}_{1, 1}, \ldots, \Aut^{(j')}_{1, m_{j', 1}}), \ldots, (\Aut^{(j')}_{k, 1}, \ldots, \Aut^{(j')}_{k, m_{j',k}})\right)_{j' \in [n_j]},$$ 
%
%$(\Aut^{(j')}_{j, 0}, \Aut^{(j')}_{j, 1}, \ldots, \Aut^{(j')}_{j, k})_{ j'  \in [m_j]}$, 
%
can be computed effectively.
Then $\cE_{i-1}(x)$ for $x \in  \{x_1,\cdots, x_k\}$ is updated as follows: %and $\cG_{i+1}$ are computed as follows:
\begin{enumerate}
\item For each $j \in [r]$, nondeterministically select a tuple 
%
$$\left((\Aut^{(s_j)}_{1, 1}, \ldots, \Aut^{(s_j)}_{1, m_{s_j, 1}}), \ldots, (\Aut^{(s_j)}_{k, 1}, \ldots, \Aut^{(s_j)}_{k, m_{s_j, k}})\right)$$
%$\left(\Aut^{(s_j)}_{j, 0}, \ldots, \Aut^{(s_j)}_{j, k}\right)$ 
for some $s_j \in [n_j]$.
%
\item For each $x \in \{x_1,\ldots, x_k\}$, let
\[
    \cE_{i-1}(x):= \cE_{i}(x) \cup \left\{\Aut^{(s_j)}_{h, j'} \mid  j \in [r], h \in [k], x = x_h, j' \in [m_{s_j, h}] \right\}.
\]
[For each vertex $x'  {\notin} \{x_1, \ldots, x_k\}$, let $\cE_{i+1}(x') := \cE_i(x')$.]
%We set $\cE_{i+1}(x) = \emptyset$.
%
%\item Let $\cG_{i+1}:= \cG_i \backslash \{(x, (\Transducer, j), y_j) \mid j \in \{0\} \cup [k]\}$.
\end{enumerate}
%For each iteration, $i$ is updated by  $i: = i+1$.
%\end{enumerate}
%
After all assignments of $S$ are scanned,  let $\cE(x):=\cE_0(x)$ for each variable $x$.


%%=================================================================
%%=================================================================
\hide{
%\begin{example}
\tl{tbh, I think the algo is clear enough and the example does not add too much.}\zhilin{maybe, but the example is at least more concrete. Moreover, the description of the algorithm is short and dry, maybe just use the example to let the reader spend a bit more time on the algorithm and digest, although with some redundancy. We may remove it if we run out of space. May decide this later.}
Let us use an example to help the reader understand the computation of $\cE_{i+1}$ from $\cE_i$.  Suppose that in $\cG_i$, to compute $\cE_{i+1}$, we select a variable $x$, which has no predecessors and three outgoing edges, say $(x, (\Transducer, 0), y)$, $(x, (\Transducer, 1), z)$, and $(x, (\Transducer, 2), y)$, where $y$ and $z$ are two distinct variables, moreover, $\cE_i(x) = \{\Aut_1, \Aut_2\}$. Let us also assume that  $\Pre_{\Transducer}(\Aut_1)$ (resp. $\Pre_{\Transducer}(\Aut_2)$) is represented by $(\Aut^{(j')}_{1, 0}, \Aut^{(j')}_{1, 1}, \Aut^{(j')}_{1, 2})_{ j'  \in [2]}$ (resp. $(\Aut^{(j')}_{2, 0}, \Aut^{(j')}_{2, 1}, \Aut^{(j')}_{2, 2})_{ j'  \in [3]}$). If for $j = 1$ (resp. $j=2$), $(\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 1}, \Aut^{(1)}_{1, 2})$  (resp. $\left(\Aut^{(3)}_{2, 0}, \Aut^{(3)}_{2, 1}, \Aut^{(3)}_{2, 2}\right)$)  is selected, then $\cE_{i+1}(y) = \cE_i(y) \cup \{\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 2}, \Aut^{(3)}_{2, 0} \cup \Aut^{(3)}_{2, 2}\}$ and $\cE_{i+1}(z) = \cE_{i}(z) \cup \{\Aut^{(1)}_{1, 1}, \Aut^{(3)}_{2, 1}\}$. 
\tl{I have not updated this part as likely the proof will go to appendix}
}
%%=================================================================
%%=================================================================


To decide the path feasibility of $S$, we have the following nondeterministic algorithm: first (nondeterministically) construct the sets $\cE(x)$ for $x \in \vars(S)$ as detailed above, then 
%guessing an accepting run of the product of NFAs 
checking the emptiness of the product of \FA{}s in $\cE(x)$ for each $x \in \vars(S)$.

\begin{example}
An example here to illustrate the generic decision procedure.
\end{example}

\zhilin{I simplified the complexity analysis. It is up to discussion whether it should be put in the appendix.}
\paragraph{Complexity analysis.}
For each $i$, 
%\begin{itemize}
%\item 
let $M_i$ be the maximum number of elements in $\cE_i(x)$ for $x  \in \vars(S)$,
%\item 
and $N_i$ be the maximum size of the \FA{}s in $\bigcup \limits_{x \in \vars(S)} \cE_i(x)$.
%\end{itemize}
Then we have $M_{i-1} \le (k \cdot \ell_w(|f|, N_i)+1) M_i \le (\rcdim(S) \cdot \ell_w(|f|, N_i)+1) M_i$  (note that we have assumed that $\ell_w$ and $\ell_a$ are monotonic). Moreover, since each string function $f$ satisfies   $|f| \le \rcphi(S)$, we have that $N_{i-1} \le \ell_a(|f|, N_i) \le \ell_a(\rcphi(S), N_i)$. Because for each $x \in \vars(S)$, %$\cE_0(x)$ contains at most $|\psi|$ elements, and 
each \FA{} in $\cE_{\rcdep(S)}(x)$ is of size bounded by $\rcpsi(S)$, we have that for each $x \in \vars(S)$, each \FA{} in $\cE(x)$ is of size bounded by $\ell_a^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$, and $\cE(x)$ contains at most 
$$
\begin{array}{l}
|\cE_{\rcdep(S)}(x)  | \prod \limits_{i = 1}^m (\rcdim(S) \ell_w(|f|, N_i) + 1) \le \\
\rcreg(S)  \prod \limits_{i = 1}^m \left(\rcdim(S) \ell_w^{\langle \rcdep(S)- i+1\rangle} (\rcphi(S), \rcpsi(S)) + 1\right)
\end{array}
$$ elements.
We emphasise that, according to the \prerec{} assumption, the construction of these \FA{}s can be done in nondeterministic 
$
%k \cdot \ell^{\langle \rcdep(S)\rangle}_w(|f|, \rcpsi(S))\cdot \ell^{\langle \rcdep(S)\rangle}_a(|f|, \rcpsi(S)) \le 
\rcdim(S) \cdot \ell^{\langle \rcdep(S)\rangle}_w(\rcphi(S), \rcpsi(S))\cdot \ell^{\langle \rcdep(S)\rangle}_a(\rcphi(S), \rcpsi(S)) $ space. 
Therefore, for each $x \in \vars(S)$, the nonemptiness of the product of \FA{}s  in $\cE(x)$ can be solved in nondeterministic 
\[
\begin{array}{l}
\rcreg^c(S)  \left(\prod \limits_{i = 1}^m \left(\rcdim(S) \ell_w^{\langle \rcdep(S)- i+1\rangle} (\rcphi(S), \rcpsi(S)) + 1\right)^c\right)\ \cdot \\
\hspace{2cm} \log^c \ell_a^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))
\end{array}
\]
space for some constant $c > 0$.

\begin{example}
	We slightly extend the $\text{replaceAll}$ example given in Figure \ref{fig:SSA} to illustrate the generic decision procedure. Suppose that the String manipulating program $S$ is 
		$\ASSERT{x_0\in L_0}$, $x_1 = \text{replaceAll}(x_0,\texttt{a},y)$, $\ASSERT{x_1\in L_1}$; $x_2= \text{replaceAll}(x_1, \texttt{b}, y)$, $\ASSERT{x_2\in L_2}$. The variables are $x, x_1, x_2, y$, and clearly $\rcdep(S)=2$ and $\rcdim(S)=2$ (as the replaceAll function here has two arguments). 
		
		To run the algorithm, initially we have $ \cE_0(x_i)= \{\Aut_i\}$ for $i=0,1,2$, and $ \cE_0(y)= \emptyset$. 
		
		Then we start with the last assignment $x_2=\text{replaceAll}(x_1,\texttt{b},y)$. By the PreRec assumption, the pre-image of $\Aut_2$ under $\text{replaceAll}_b$ is a recognisable relation. In other
		words, we obtain the resulting regular constraints for $x_1$ and $y$. By nondeterministic selection, we update $\cE_0$ to $\cE_1$ with $\cE_1(x_0)=\{\Aut_0\}$, $\cE_1(x_1)=\{\Aut_1,\Aut_1'\}$, $\cE_1(x_2)=\{\Aut_2\}$ (remains unchanged), and $\cE_1(y)=\{\Aut^1_y\}$. 
		
		We continue with the assignment $x_1 = \text{replaceAll}(x_0,\texttt{a},y)$. Again by the PreRec assumption, the pre-image of both $\Aut_1,\Aut_1'$ from $\cE_1(x_1)$ under  $\text{replaceAll}_a$ is a recognisable relation. In other
		words, we obtain the resulting regular constraints for $x_0$ and $y$. By nondeterministic selection, we update $\cE_1$ to $\cE_2$ with $\cE_2(x_0)=\{\Aut_0, \Aut_0'\}$, $\cE_2(x_1)=\{\Aut_1,\Aut_1'\}$, $\cE_2(x_2)=\{\Aut_2\}$ (these two remain unchanged), and $\cE_2(y)=\{\Aut^1_y, \Aut^2_y\}$.
		
		The iteration now is done. We then only need to check nonemptiness of the product automata from $\cE_2(x_i)$ ($i=0,1,2$) and $\cE_2(y)$. \qed
		
		\end{example}

%
%Given a string manipulating program $S$, w.l.o.g., we assume that each variable appears at most once\footnote{If, for instance, $x\in \Aut_1$ and $x\in \Aut_2$ both appear in the assertions of $S$, then we can lump them using $x\in \Aut_1 \times \Aut_2$.} in the assertions of $S$. Furthermore, we define $\rcdep(S)$ to be the number of assignments in $S$, $\rcdim(S)$ to be the maximum number of arguments of string functions in the assignments of $S$, $\rcphi(S)$ to be the maximum size of the representations of these string functions, and $\rcpsi(S)$ to be the maximum size of the \FA{}s appearing in the assertions of $S$. 




%%%%===========================original complexity analysis removed ====================================
%%%%===========================original complexity analysis removed ==================================
\hide{
%
Since each conjunctive FA $((Q, \delta), S)$ in $\cE(x)$ encodes an FA of size $|Q|^{|S|} \le |Q|^{|Q|^2} \approx 2^{O(|Q|^2 \log |Q|)}$, 
%\tl{I do not quite understand here} \zhilin{explained in the definition of conjunctive encodings of atoms} 
it holds that the product automaton of FAs in $\cE(x)$ is of size bounded by 
%
$$(\rcdim(S)+1)^{\rcdep(S)} \cdot 2^{\mathcal{O}((\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) )}.$$
%
Because the nonemptiness of an FA 
can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic space bounded by 
$$\mathcal{O}(\rcdep(S) (\log ((\rcdim(S)+1))) \cdot (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$
%=======
%$$2^{O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) )}.$$
%%
%Because the nonemptiness of an NFA 
%can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic 
%$$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) ) \mbox{ space.}$$
%>>>>>>> e8a132a375e6d8f5c007d33427151d3386a5f8ee
%
Therefore, overall, the space used by the aforementioned nondeterministic algorithm is 
$$\mathcal{O}((\rcdim(S)+1)^{\rcdep(S)} \cdot  (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log f^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$ 
%\zhilin{Please check the complexity}
%Therefore, the satisfiability can be checked by a nondeterministic Turing machine with 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%\end{proof}
}
