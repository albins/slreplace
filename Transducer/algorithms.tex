%!TEX root = main.tex

%\section{Algorithmic results}

\section{A generic decision procedure} \label{sec:algo}

\zhilin{shall we use symbolic representation $S$ in order to not confuse the readers as well as ourselves ? }

In this section, we present a generic decision procedure for any
%straight-line \emph{constraint language} 
straight-line symbolic execution $S$
that satisfies one further condition:
the pre-image of a regular language under any function 
$f: (\ialphabet^*)^\arity \to \ialphabet^*$ in the constraint satisfies a 
``\emph{regularity condition}''.
In the case when $\arity=1$, this regularity condition would state that the pre-image
of a regular language under the function $f$ is \emph{effectively regular}, i.e. an \FA{} can be computed to represent the pre-image of the regular language under $f$. This is
satisfied by \FT{}s \cite{Berstel,BG07,BG08}, and there is
a decision procedure for satisfiability of the straight-line constraint
language %immediately follows from the decision procedure 
with $f: \ialphabet^* \to \ialphabet^*$ being an \FT{}, e.g., see 
\cite{LB16,BG07,BG08}. %This decision procedure, in fact, works when each
%function $f$ satisfies the regularity condition. 
We illustrate this decision procedure below.

\begin{example}
    Consider the symbolic execution $S$
    \[
        \ASSERT{x \in L_0}; \quad y := f(x); \quad z := g(y); 
        \quad \ASSERT{y \in L_1}; \quad \ASSERT{z \in L_2}
    \]
    where $f, g: \ialphabet^* \to \ialphabet^*$ satisfy the regularity 
    condition. To check the path feasibility of $S$, we repeatedly \emph{remove the last
    assignment} from the program by pre-image computation. More
    precisely, we compute the pre-image $g^{-1}(L_2)$
    of $L_2$ under $g$, which by assumption is a regular language $L_2'$,
    yielding the equi-path-feasible program:
    \[
        \ASSERT{x \in L_0}; \quad y := f(x); \quad \ASSERT{y \in L_1}; \quad  \ASSERT{y \in L_2'} 
    \]
%    \[
%        \ASSERT{x \in L_0}; \quad y := f(x); \quad \ASSERT{y \in L_1}; \quad 
%        \ASSERT{x \in L_2'}
%    \]
    Computing the regular pre-image $L_1' := f^{-1}(L_1 \cap L'_2)$ gives us
    the program:
    \[
        \ASSERT{x \in L_0}; \quad \ASSERT{x \in L_1'}.
    \]
%
%    \[
%        \ASSERT{x \in L_0}; \quad \ASSERT{x \in L_1'}; \quad \ASSERT{x \in L_2'}
%    \]
    Checking the path feasibility of this program amounts to checking the nonemptiness of
    $L_0 \cap L_1'$, which can be done by a simple \FA{} algorithm.
    \qed
\end{example}
How do we generalise this generic decision procedure to partial functions $f: 
(\ialphabet^*)^\arity \to \ialphabet^*$ with possibly multiple inputs, which at least
subsume parametric transducers? 
One answer is to use the generalisation of
%There are at least three generalisations
of the notion of ``regularity'' from languages to relations 
by means of \emph{recognisable relations} \cite{choffrut-survey}.
[Other more expressive notions of regularity exist (see \cite{choffrut-survey}),
but they are not suitable for generalising the aforementioned decision
procedure for $\arity=1$.]
%(in the increasing order of expressivity):
%(a) \emph{recognisable} relations, (b) \emph{regular} relations 
%(a.k.a.~synchronised rational relations), and (c) \emph{rational} relations. 
%Loosely speaking, regular and rational relations are generated by transducers
%with $k$ input/output tapes (or variants thereof).
%Loosely speaking, rational relations can be generated by one-way finite 
%transducers with $k$ input/output tapes. Regular relations can be defined in 
%the same 
%way, but the $k$ heads
%pointing to $k$ tapes move in a ``synchronised'' way. 
\OMIT{
They both have \emph{tight couplings} between the $k$ inputs tapes, which makes 
it impossible to generalise the above generic decision procedure for $k=1$. 
This tight coupling is, however, absent in recognisable relations.
}
%
%For each string function $f(x_1,\ldots,x_n)$, we assume that its pre-image of a regular language is a recognisable relation defined below.  

\begin{definition}[Recognisable relations]
	%Assume a finite alphabet $\Sigma$. 
    A $\arity$-ary relation $R\subseteq \Sigma^*\times \ldots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \ldots\times L^{(i)}_\arity$ where $L^{(i)}_j$ is regular for each $j\in [\arity]$.
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}
In other words, a recognisable relation is simply a finite union of 
cartesian products of regular languages. 
For a recognisable relation $R$, a \emph{representation} of $R$ is a collection of tuples $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_\arity)_{i\in [n]}$  such that 
$R = \bigcup_{i=1}^n \Lang(\Aut^{(i)}_1) \times \ldots\times \Lang(\Aut^{(i)}_\arity)$, where each $\Aut^{(i)}_j$ is an \FA. 
%The numbers $k, n$ are called the \emph{dimension} and \emph{width}  of the representation respectively, 
Each tuple $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_\arity)$ is called a \emph{disjunct} of the representation, and  each \FA{} $\Aut^{(i)}_j$ is called an \emph{atom} of the representation.
%
\begin{theorem}
    There is a procedure which, given a symbolic execution $S$ wherein 
    each $f: (\ialphabet^*)^\arity \to \ialphabet^*$ satisfies the regularity 
    condition (with respect to recognisable relations), decides whether $S$
    is path feasible.
    \label{th:gen}
\end{theorem}
%
\begin{proof}
    We provide a nondeterministic procedure which generalises the case when
    all functions $f$ take only one input. Let $S$  be a symbolic execution, $y := f(\bar x)$ (where
    $\bar x = x_1,\ldots,x_\arity$) be the last
    assignment in $S$, and $\sigma := \{ y \in L_1,\ldots, y \in L_s\}$
    be the set of all regular constraints on $y$ in assertions of $S$.
    Let $S'$ be the program obtained by removing $y := f(\bar x)$ along
    with all assertions with conditionals in $\sigma$.
    Compute the regular language $L := L_1 \cap \cdots \cap L_s$ using
    the product construction. By 
    assumption, we can compute a finite set of disjuncts
    $(\Aut^{(i)}_1, \ldots, \Aut^{(i)}_\arity)$  to represent
    $f^{-1}(L)$. Nondeterministically guess one such disjunct
    $(\Aut_1, \ldots, \Aut_\arity)$. Let $S''$ be the program 
    \[
        S'; \quad \ASSERT{x_1 \in \Lang(\Aut_1)}; \quad \cdots\quad ; \quad \ASSERT{x_\arity \in
        \Lang(\Aut_\arity)}
    \]
    Then, $S$ is path-feasible iff there is a nondeterministic guess leading
    to a construction of $S''$ that is path-feasible. 

    In conclusion, the procedure will terminate when $S$ is a conjunction of
    assertions on input variables, whose path feasibility can be
    decided by checking language nonemptiness of \FA{}s.
\end{proof}
\OMIT{
Fortunately, recognisability is
right notion of ``regularity'' that we need for pre-images of partial
functions $f: (\ialphabet^*)^k \to \ialphabet^*$, which will be satisfied by
parametric transducers as we will see in Section \ref{sec-instan}.
}



%
\smallskip
\noindent
\textbf{Complexity consideration: }
Although the algorithm in the proof of Theorem \ref{th:gen} is conceptually 
clear, to obtain tight complexity bounds in this paper, it is crucial to 
avoid applying the product construction before each pre-image computation.
To this end, we make two modifications and state a theorem with complexity. 

Firstly,
since we assume that each $f: (\ialphabet^*)^\arity \to \ialphabet^*$
in $S$ is a partial function, it follows that $f^{-1}(L_1 \cap L_2) = 
f^{-1}(L_1) \cap f^{-1}(L_2)$. This is \emph{false} in general if $f$ is a \emph{relation}.
This means that, for each $y := f(\bar x)$, we can \emph{separately} compute 
the preimage $f^{-1}(L)$ for each regular constraint $y \in L$ in an assertion
of $S$, i.e., no product construction is performed.
%as in the proof
%of Theorem \ref{th:gen}. 

The second modification concerns the representation of each atom
in a disjunct of a representation of recognisable relations. We propose
to use (a variant of) conjunctions of regular constraints called
\emph{conjunctive \FA{}}. 
%iof each atoms of the representation, 
More precisely, each conjunctive \FA{} is a tuple $\Aut = ((\controls, \transrel), S)$
such that $(\controls, \transrel)$ is a transition graph of an \FA{} and 
$S \subseteq \controls \times \controls$ is a \emph{conjunctive acceptance 
condition}, i.e., a string $w$ is accepted by $\Aut$ if 
for \emph{every} $(q, q') \in S$, there is a run of $(\controls, \transrel)$ on
$w$ from $q$ to $q'$. 
%
Note that $\Lang(((\controls, \transrel), S)) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$, where $\cB_{q,q'}$ is the \FA{} $(\controls, q, \{q'\}, \transrel)$. Evidently, a  conjunctive \FA{} $\Aut=((\controls, \transrel), S)$ is a \emph{succint} representation of the product of \FA{}s $\cB_{q,q'}$, which has a size exponentially large than that of $\Aut$ in the worst case.
%
%We remark that the nonemptiness checking  can be done in nondeterministic logarithmic space for the standard representation of \FA{}s, but requires polynomial space for the conjunctive representation. (One needs to build up the product automaton which is of size $|Q|^{|S|}$.) 
%
Accordingly, a representation of $R$ is called a \emph{conjunctive
representation} if every atom in the representation is a conjunctive \FA{}.
Since each \FA{} $\Aut = 
(\ialphabet, \controls, q_0, \finals, \transrel)$
can be assumed to have only one final state (i.e. $\finals = \{q_F\}$), each 
\FA{} can be identified with the conjunctive \FA{}
$((\controls,\transrel),\{(q_0,q_F)\})$.
The \emph{size} of a conjunctive representation $((\controls, \transrel), S)$ is defined as $|\controls|$. Define the  \emph{atom size} of a conjunctive representation of $R$ to be the maximum size of the atoms therein.

%as follows: 
%Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Then $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$. Furthermore,  $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q\})$ can be decoupled as a pair $\cC^{(i)}_{j, (q^{(i)}_{0, j}, q)} = \left(\left(\controls^{(i)}_j,  \transrel^{(i)}_j \right), \{(q^{(i)}_{0,j}, q)\} \right)$. Therefore, $R$ is conjunctively represented by 
%
%$$\bigcup_{i \in [n], (q^{(i)}_1, \ldots, q^{(i)}_k) \in \finals^{(i)}_1 \times \ldots \times   \finals^{(i)}_k }  \cC^{(i)}_{1, (q^{(i)}_{0, 1}, q^{(i)}_1)}\times \ldots \times \cC^{(i)}_{k, (q^{(i)}_{0, k}, q^{(i)}_k)} .$$

%
%
%\footnote{Each representation can be turned into one satisfying the requirement as follows: Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \transrel^{(i)}_j, \finals^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Since $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$, we have $R = \bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \Lang(\Aut^{(i)}_1(q^{(i)}_{0, 1}, \{q^{(i)}_1\})) \times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\}))$. Each NFA $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})$ can be encoded as a pair $((\controls^{(i)}_j,  \transrel^{(i)}_j), \{(q^{(i)}_{0,j}, q^{(i)}_j)\})$.} 
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
It follows that one can reconstruct $R$ by using the alternative representation of automata by  
%we do the following transformation:
%
%Each representation can be turned into one satisfying the requirement as follows: 
%we have 
\begin{align*}
R  & =   \bigcup_{i=1}^n \prod_{j=1}^k \Lang(\Aut^{(i)}_j) \\
& =   \bigcup_{i=1}^n  \prod_{j=1}^k \bigcup \limits_{q_j \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q_j\}))\\
&=	\bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \prod_{j=1}^k \Lang(\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})) 
%\times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\})).
\end{align*}
%
%
%that each atom $\Aut^{(i)}_j$ is \emph{succinctly} encoded into a pair $((\controls, \transrel), S)$, where $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$, such that $\Lang(\Aut^{(i)}_j) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$ with $\cB_{q,q'} = (\controls, q, \transrel, \{q'\})$. 
%
\tl{shall we call it something like compact size, so later we can avoid "the size of the succinctly encoded NFA"? }
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%The maximum size of (the succinct encodings of) the atoms of a representation is called the \emph{atom size} of the representation. 
%=======
%Furthermore, in order to get better space complexity upper bounds (in some cases), we require\footnote{Each representation can be turned into one satisfying the requirement as follows: Suppose $\Aut^{(i)}_j=(\controls^{(i)}_j, q^{(i)}_{0,j}, \finals^{(i)}_j, \transrel^{(i)}_j)$ for $i \in [n]$ and $j \in [k]$. Since $\Lang(\Aut^{(i)}_j) = \bigcup \limits_{q \in \finals^{(i)}_j} \Lang(\Aut^{(i)}_j(q^{(i)}_{0,j}, \{q\}))$, we have $R = \bigcup \limits_{i=1}^n \bigcup \limits_{\forall j \in [k]. q^{(i)}_j \in \finals^{(i)}_j } \Lang(\Aut^{(i)}_1(q^{(i)}_{0, 1}, \{q^{(i)}_1\})) \times \ldots \times \Lang(\Aut^{(i)}_k(q^{(i)}_{0, k}, \{q^{(i)}_k\}))$. Each NFA $\Aut^{(i)}_j(q^{(i)}_{0, j}, \{q^{(i)}_j\})$ can be encoded as a pair $((\controls^{(i)}_j,  \transrel^{(i)}_j), \{(q^{(i)}_{0,j}, q^{(i)}_j)\})$.} 
%%
%that each atom $\Aut^{(i)}_j$ is \emph{succinctly} encoded into a pair $((\controls, \transrel), S)$, where $(\controls, \transrel)$ is a transition graph and $S \subseteq \controls \times \controls$, such that $\Lang(\Aut^{(i)}_j) = \bigcap \limits_{(q,q') \in S} \Lang(\cB_{q,q'})$ with $\cB_{q,q'} = (\controls, q, \{q'\}, \transrel)$. The size of $((\controls, \transrel), S)$ is defined as $|\controls|$. The maximum size of (the succinct encodings of) the atoms of a representation is called the \emph{atom size} of the representation. 
%>>>>>>> 104e69ae6204529f3ecd049a9405556039c70921

%it is the product of $\cB(q, \{q'\})$ for an NFA $\cB=(\controls, q_0, \transrel, \finals)$ and $(q, q') \in S$ with $S \subseteq Q \times Q$, then we encode $\Aut^{(i)}_j$ \emph{succinctly} as a pair $(\transrel, S)$. Note that the \emph{size} of this succinct encoding is $|\transrel|+|S|$, which is polynomial in $|\controls|$, while $|\Aut^{(i)}_j|$ is exponential in $|S|$.

\OMIT{
In the sequel, %when we say a representation of $R$, 
the representation of $R$ simply refers to a \emph{conjunctive} representation of $R$. Moreover, a conjunctive \FA{} refers to a pair $((\controls, \transrel), S)$ whereas an \FA{} refers to an \FA{} in the original form, i.e. $(\controls, q_0, \finals, \transrel)$.
%

}


\OMIT{
%Let $\Transducer$ be a parametric transducer %from $\transet$ with $k$ parameters ($k\geq 0$), and 
As we have discussed in Section~\ref{subsec:symexe}, a string function $f(x_1, \cdots, x_k)$ with $k$ parameters ($k\geq 1$) gives rise to a relation $R_f\subseteq (\Sigma^*)^k \times \Sigma^*$. Let $\Aut$ be an FA. The \emph{pre-image} of $\Aut$ under $f$, denoted by $\Pre_{R_f}(\Aut)$, is 
\[\left\{(w_1,\ldots, w_k) \in (\Sigma^*)^k \mid \exists w.\ w\in f(w_1, \cdots, w_k)\text{ and } w\in\Lang(\Aut) \right\}.\]
}
%w is (one of) the output(s) of the string function $f$.  

%
%the set of tuples $(w, w_1,\ldots, w_k)$ such that there is an accepting run of $\Transducer$ on $w$ with output $w'\in \Lang(\Aut)$ when equipped with the parameters $w_1,\ldots, w_k$. 

\OMIT{
The main result of this section is a generic decision procedure for the path feasibility problem of string manipulating program $S$ in the SSA form, under the \prerec{} assumption defined as follows.
}

We now provide a refined version of Theorem \ref{th:gen} that accounts for
complexity (full proof in the \shortlong{full version}{appendix}). First,
our regularity condition (called \prerec{}) now incorporates conjunctive
\FA{}s as representations of atoms and accounts for complexity:
for each function $f$ in $S$ and each conjunctive \FA{} $\Aut$,
there is an algorithm that runs in $\ell(|f|,|\Aut|)$ space which enumerates 
each disjunct of $f^{-1}(\Aut)$ in conjunctive representation.
%not only assumes that each
\OMIT{
(1) each function $f$ in $S$ and each conjunctive \FA{} $\Aut$,  $\Pre_{R_f}(\Aut)$ is a recognisable relation. Furthermore, 
a representation of $\Pre_{R_f}(\Aut)$, whose atom size is bounded by  $\ell(|f|, |\Aut|)$ for some monotone function $\ell$, can be computed effectively. We also assume that each disjunct of the representation can be nondeterministically computed in $\ell(|f|, |\Aut|)$ space.
}
%the space to compute a representation of $\Pre_{R_f}(\Aut)$ and the atom size of such a representation\footnote{Usually the amount of space is at least as large as the size of the representation; here for simplicity we assume that they are asymptotically the same.} are both bounded by $\ell(|f|, |\Aut|)$ for some monotone function $\ell$.  
%
%\item[A2] Each assertion $g$ in $S$ is given as a conjunction of atomic regular constraint $x\in \Aut$. 
%\end{quote} 
%
Here $|f|$ is the size of a representation of $f$, which will be defined
when we
%
%; the concrete definition depends on the form of $f$, which will be given when the generic decision procedure is instantiated in Section~\ref{sec-instan}. 
instantiate the generic decision procedure in Section~\ref{sec-instan}.
We also define some size parameters of $S$.
%w.l.o.g., we assume that each variable appears at most once\footnote{If, for instance, $x\in \Aut_1$ and $x\in \Aut_2$ both appear in the assertions of $S$, then we can lump them using $x\in \Aut_1 \times \Aut_2$.} in the assertions of $S$. 
%Furthermore, 
Let $\rcdep(S)$ be the number of assignments in $S$, $\rcdim(S)$ be the maximum arity of string functions in the assignments of $S$, $\rcphi(S)$ 
be the maximum size of the representations of these string functions,  $\rcasrt(S)$ be the number of assertions in $S$,
and $\rcpsi(S)$ be the maximum size of the \FA{}s appearing in the assertions of 
$S$.
%, and $\rcreg(S)$ to be the maximum number of atomic regular constraints for 
%any one variable in $S$. 
Moreover,
for $\ell:\Nat^2\rightarrow \Nat$, we define $\ell^{\langle n \rangle}(j, k)$ ($n\geq 1$) as $\ell^{\langle 1 \rangle}(j,k)= \ell(j, k)$ and $\ell^{\langle n+1 \rangle }(j, k) = \ell(j, \ell^{\langle n \rangle}(j,k))$. 

%%%=========================================
\hide{
\mat{
    Do we need to talk about transducers in this section?
    Could we just get away with any relation $R$ such that $Pre_R(A)$ can be constructed effectively?
    It's a bit sad to introduce a generic framework, then tie it unnecessarily to parametric transducers.
    The complexity would need adjusting i guess, though i think it has issues already:
    \begin{itemize}
    \item
        $|\varphi|$ is not defined
    \item
        there is no given space bound on effectively constructing a representation of Pre -- only the size of the output is considered.
        Presumably the complexity given below assumes that the amount of space required to compute the representation is no more than the size of the representation.
    \end{itemize}
}
\tl{I have tried to accommodate this, though need to proof read carefully.}
}
%%%=========================================


%==== theorem ==============================
\begin{theorem}\label{thm-generic-dec}
	Given a symbolic execution $S$ satisfying \prerec{}, the 
    path feasibility problem of $S$ can be decided in \emph{nondeterministic} 
        %
	$$(\rcdim(S)+1)^{\rcdep(S)}  \rcasrt(S) \left(\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) \right)^c$$
	%
	space for some constant $c > 0$.
%
%	$|\vars(S)|(\rcdim(S)+1)^{\rcdep(S)}  \rcreg(S) \left(\ell^{\langle
%    \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) \right)^c$ space for some constant
%    $c > 0$.
\end{theorem}


%\begin{theorem}\label{thm-generic-dec}
%Suppose that %$\transet$ satisfies that 
%for each $\Transducer \in \transet$ and conjunctive NFA $\Aut$, $\Pre_\Transducer(\Aut)$ is a recognisable relation.  Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $f(|\Transducer|, |\Aut|)$ for some monotone function $f$, can be determined effectively. Then the satisfiability of a given $\straightline[\transet]$ formula $\varphi \wedge \psi$ can be decided in \emph{nondeterministic} 
%%\tl{why not remove  nondeterministic?} 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)}|\psi| \cdot (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%%, where $K$ is the maximum number of parameters of 
%%transducers appearing in the constraints, 
%%$D$ is the maximum length of the paths in $\cG(\varphi)$.
%\end{theorem}

%\begin{proof}
%Let $\varphi \wedge \psi$ be an $\straightline[\transet]$ formula. 


    \OMIT{
\begin{example}	
%	Let us use an example to help the reader understand the computation of $\cE_{i+1}$ from $\cE_i$.  Suppose that in $\cG_i$, to compute $\cE_{i+1}$, we select a variable $x$, which has no predecessors and three outgoing edges, say $(x, (\Transducer, 0), y)$, $(x, (\Transducer, 1), z)$, and $(x, (\Transducer, 2), y)$, where $y$ and $z$ are two distinct variables, moreover,
%	
%	
%	 $\cE_i(x) = \{\Aut_1, \Aut_2\}$. Let us also assume that  $\Pre_{\Transducer}(\Aut_1)$ (resp. $\Pre_{\Transducer}(\Aut_2)$) is represented by $(\Aut^{(j')}_{1, 0}, \Aut^{(j')}_{1, 1}, \Aut^{(j')}_{1, 2})_{ j'  \in [2]}$ (resp. $(\Aut^{(j')}_{2, 0}, \Aut^{(j')}_{2, 1}, \Aut^{(j')}_{2, 2})_{ j'  \in [3]}$). If for $j = 1$ (resp. $j=2$), $(\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 1}, \Aut^{(1)}_{1, 2})$  (resp. $\left(\Aut^{(3)}_{2, 0}, \Aut^{(3)}_{2, 1}, \Aut^{(3)}_{2, 2}\right)$)  is selected, then $\cE_{i+1}(y) = \cE_i(y) \cup \{\Aut^{(1)}_{1, 0}, \Aut^{(1)}_{1, 2}, \Aut^{(3)}_{2, 0} \cup \Aut^{(3)}_{2, 2}\}$ and $\cE_{i+1}(z) = \cE_{i}(z) \cup \{\Aut^{(1)}_{1, 1}, \Aut^{(3)}_{2, 1}\}$. 
%	
	We slightly extend the $\text{replaceAll}$ example given in Figure \ref{fig:SSA} to illustrate the generic decision procedure. Suppose that the String manipulating program $S$ is 
		$\ASSERT{x_0\in L_0}$, $x_1 = \text{replaceAll}(x_0,\texttt{a},y)$, $\ASSERT{x_1\in L_1}$; $x_2= \text{replaceAll}(x_1, \texttt{b}, y)$, $\ASSERT{x_2\in L_2}$. The variables are $x, x_1, x_2, y$, and clearly $\rcdep(S)=2$ and $\rcdim(S)=2$ (as the replaceAll function here has two arguments). 
		
		To run the algorithm, initially we have $ \cE_2(x_i)= \{\Aut_i\}$ for $i=0,1,2$, and $ \cE_2(y)= \emptyset$. 
		
		Then we start with the last assignment $x_2=\text{replaceAll}(x_1,\texttt{b},y)$. By the PreRec assumption, the pre-image of $\Aut_2$ under $\text{replaceAll}_b$ is a recognisable relation, which is 
		represented by  $(\Aut^{(k)}_{2, 1}, \Aut^{(k)}_{2, 2})_{ k=1,2,3}$. By nondeterministic selection (the machine happens to pick $k=1$), we update $\cE_2$ to $\cE_1$ with $\cE_1(x_0)=\{\Aut_0\}$ (remains unchanged), $\cE_1(x_1)=\{\Aut_1,\Aut^{(1)}_{2,1}\}$, $\cE_1(x_2)=\{\Aut_2\}$ (remains unchanged), and $\cE_1(y)=\{\Aut^{(1)}_{2,2}\}$. 
		
			%		In other
		%		words, we obtain the resulting regular constraints for $x_1$ and $y$. Assume that  $\Pre_{\Transducer}(\Aut_1)$ (resp. $\Pre_{\Transducer}(\Aut_2)$) is represented by $(\Aut^{(j')}_{1, 0}, \Aut^{(j')}_{1, 1}, \Aut^{(j')}_{1, 2})_{ j'  \in [2]}$  
		
		We continue with the assignment $x_1 = \text{replaceAll}(x_0,\texttt{a},y)$. Again by the PreRec assumption, the pre-image of both $\Aut_1,\Aut^{(1)}_{2,1}$ from $\cE_1(x_1)$ under  $\text{replaceAll}_a$ is a recognisable relation. In this case, suppose 
		the pre-image of $\Aut_1$ is represented by $(\mathcal{B}^{(k)}_{1, 1}, \mathcal{B}^{(k)}_{1, 2})_{k = 1,2}$, and the pre-imeage of $\Aut^{(1)}_{2,1})$ is represented by $( \mathcal{C}^{(\ell)}_{2, 1}, \mathcal{C}^{(\ell)}_{2, 2})_{ \ell=1,2,3}$. 
		
		%In other words, we obtain the resulting regular constraints for $x_0$ and $y$. 
		
		By nondeterministic selection (the machine happens to pick $k=2$ and $\ell=3$), we update $\cE_1$ to $\cE_0$ with $\cE_2(x_0)=\{\Aut_0, \mathcal{B}^{(2)}_{1,1}, \mathcal{C}^{(3)}_{1,1}\}$, $\cE_0(x_1)=\{\Aut_1,\Aut^{(1)}_{2,1}\}$, $\cE_0(x_2)=\{\Aut_2\}$ (these two remain unchanged), and $\cE_0(y)=\{\Aut^{(1)}_{2,2}, \mathcal{B}^{(2)}_{1,2},  \mathcal{C}^{(3)}_{1,2}\}$.
		
		The iteration now is done. We then only need to check nonemptiness of the product automata from $\cE_0(x_i)$ ($i=0,1,2$) and $\cE_0(y)$. \qed
\end{example}

%\zhilin{I simplified the complexity analysis. More details are put in the appendix.}
\paragraph{Complexity analysis.}
For each $i$, 
%\begin{itemize}
%\item 
let $M_i$ be the maximum number of elements in $\cE_i(x)$ for $x  \in \vars(S)$,
%\item 
and $N_i$ be the maximum size of the conjunctive FAs in $\bigcup \limits_{x \in \vars(S)} \cE_i(x)$.
%\end{itemize}
%<<<<<<< HEAD
%Then we have $M_{i-1} \le (k \cdot \ell_w(|f|, N_i)+1) M_i \le (\rcdim(S) \cdot \ell_w(|f|, N_i)+1) M_i$  (note that we have assumed that $\ell_w$ and $\ell_a$ are monotonic). Moreover, since each string function $f$ satisfies   $|f| \le \rcphi(S)$, we have that $N_{i-1} \le \ell_a(|f|, N_i) \le \ell_a(\rcphi(S), N_i)$. Because for each $x \in \vars(S)$, %$\cE_0(x)$ contains at most $|\psi|$ elements, and 
%each \FA{} in $\cE_{\rcdep(S)}(x)$ is of size bounded by $\rcpsi(S)$, we have that for each $x \in \vars(S)$, each \FA{} in $\cE(x)$ is of size bounded by $\ell_a^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$, and $\cE(x)$ contains at most 
%$$
%\begin{array}{l}
%|\cE_{\rcdep(S)}(x)  | \prod \limits_{i = 1}^m (\rcdim(S) \ell_w(|f|, N_i) + 1) \le \\
%\rcreg(S)  \prod \limits_{i = 1}^m \left(\rcdim(S) \ell_w^{\langle \rcdep(S)- i+1\rangle} (\rcphi(S), \rcpsi(S)) + 1\right)
%\end{array}
%$$ elements.
%We emphasise that, according to the \prerec{} assumption, the construction of these \FA{}s can be done in nondeterministic 
%$
%%k \cdot \ell^{\langle \rcdep(S)\rangle}_w(|f|, \rcpsi(S))\cdot \ell^{\langle \rcdep(S)\rangle}_a(|f|, \rcpsi(S)) \le 
%\rcdim(S) \cdot \ell^{\langle \rcdep(S)\rangle}_w(\rcphi(S), \rcpsi(S))\cdot \ell^{\langle \rcdep(S)\rangle}_a(\rcphi(S), \rcpsi(S)) $ space. 
%Therefore, for each $x \in \vars(S)$, the nonemptiness of the product of \FA{}s  in $\cE(x)$ can be solved in nondeterministic 
%\[
%\begin{array}{l}
%\rcreg^c(S)  \left(\prod \limits_{i = 1}^m \left(\rcdim(S) \ell_w^{\langle \rcdep(S)- i+1\rangle} (\rcphi(S), \rcpsi(S)) + 1\right)^c\right)\ \cdot \\
%\hspace{2cm} \log^c \ell_a^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))
%\end{array}
%\]
%space for some constant $c > 0$.
%
%\begin{example}

%		
%		\end{example}
%
%%
%%Given a string manipulating program $S$, w.l.o.g., we assume that each variable appears at most once\footnote{If, for instance, $x\in \Aut_1$ and $x\in \Aut_2$ both appear in the assertions of $S$, then we can lump them using $x\in \Aut_1 \times \Aut_2$.} in the assertions of $S$. Furthermore, we define $\rcdep(S)$ to be the number of assignments in $S$, $\rcdim(S)$ to be the maximum number of arguments of string functions in the assignments of $S$, $\rcphi(S)$ to be the maximum size of the representations of these string functions, and $\rcpsi(S)$ to be the maximum size of the \FA{}s appearing in the assertions of $S$. 
%
%
%=======
Then we have $M_{i-1} \le (\rcdim(S)+1)M_i $. Moreover, since each string function $f$ satisfies   $|f| \le \rcphi(S)$, we have that $N_{i-1} \le \ell(|f|, N_i) \le \ell(\rcphi(S), N_i)$ (note that we have assumed that $\ell$ is monotonic). Because for each $x \in \vars(S)$, $\cE_{\rcdep(S)}(x)$ contains at most $\rcreg(S)$ elements, and 
each conjunctive \FA{} in $\cE_{\rcdep(S)}(x)$ is of size bounded by $\rcpsi(S)$, we have that for each $x \in \vars(S)$, $\cE(x)$ contains at most $(\rcdim(S)+1)^{\rcdep(S)}\rcreg(S)$ elements, and each conjunctive \FA{} in $\cE(x)$ is of size bounded by $\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$. 
%We emphasise that, according to the \prerec{} assumption, the construction of these \FA{}s can be done in nondeterministic $\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))$ space as well. 
Then by utilising  the \prerec{} assumption and Proposition~\ref{prop-conj-fa-prod}, after some simple calculations, we can deduce that the aforementioned nondeterministic algorithm takes 
$|\vars(S)|(\rcdim(S)+1)^{\rcdep(S)}  \rcreg(S) \left(\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) \right)^c$
 space for some constant $c > 0$.
 


%%%%===========================original complexity analysis removed ====================================
%%%%===========================original complexity analysis removed ==================================
\hide{
%
Since each conjunctive FA $((Q, \delta), S)$ in $\cE(x)$ encodes an FA of size $|Q|^{|S|} \le |Q|^{|Q|^2} \approx 2^{O(|Q|^2 \log |Q|)}$, 
%\tl{I do not quite understand here} \zhilin{explained in the definition of conjunctive encodings of atoms} 
it holds that the product automaton of FAs in $\cE(x)$ is of size bounded by 
%
$$(\rcdim(S)+1)^{\rcdep(S)} \cdot 2^{\mathcal{O}((\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)) )}.$$
%
Because the nonemptiness of an FA 
can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic space bounded by 
$$\mathcal{O}(\rcdep(S) (\log ((\rcdim(S)+1))) \cdot (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log \ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$
%=======
%$$2^{O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) )}.$$
%%
%Because the nonemptiness of an NFA 
%can be decided in nondeterministic logarithmic space, we deduce that the nonemptiness checking for $\cE(x)$ can be done in nondeterministic 
%$$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} |\psi|  (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|) ) \mbox{ space.}$$
%>>>>>>> e8a132a375e6d8f5c007d33427151d3386a5f8ee
%
Therefore, overall, the space used by the aforementioned nondeterministic algorithm is 
$$\mathcal{O}((\rcdim(S)+1)^{\rcdep(S)} \cdot  (\ell^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S)))^2 \log f^{\langle \rcdep(S) \rangle}(\rcphi(S), \rcpsi(S))).$$ 
%\zhilin{Please check the complexity}
%Therefore, the satisfiability can be checked by a nondeterministic Turing machine with 
%$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$ space.
%\end{proof}
}
}
