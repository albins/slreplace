%!TEX root = main.tex

\section{The Framework: Transducers, Straight-Line Programs}
\label{sec:framework}

In this section we first review the framework of straight-line programs from
\cite{LB16} for analysing symbolic execution of programs with strings, which
involves capturing ``built-in'' functions using finite-state transductions.
We will then introduce the notion of parametric transducers, and show that
they can capture many other interesting string functions that cannot be captured
within the framework of \cite{LB16}. In particular, this allows us to capture
string functions $f: (\Sigma^*)^k \to \Sigma^*$ with multiple input strings
(e.g. the replaceall function), and the string reverse function. 
The framework of straight-line programs from \cite{LB16} can be adapted
to this new notion of transducers, whose path feasibility problem, defined below, will be shown
to be decidable in Section \ref{sec:algo}.


\anthony{Some abbreviations: 
\begin{itemize}
    \item 2PT, two-way parametric transducers
    \item 1PT, one-way parametric transducers
    \item 2RPT, two-way reversal-bounded parametric transducers
    \item 2T, two-way non-parametric transducers
    \item 1T, one-way non-parametric transducers
\end{itemize}
}

\subsection{A symbolic execution analysis framework}
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be viewed as the problem of \emph{path 
feasibility} over \emph{loopless} string-manipulating programs $S$ with variable 
assignments and assertions, i.e., generated by the grammar
\begin{equation*}
    S ::= y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$g(x_1,\ldots,x_n)$}}\ |\ 
            S_1; S_2\ 
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation*}
where $f: (\Sigma^*)^n \to \Sigma^*$ and $g: (\Sigma^*)^n \to \{0,1\}$ are
some string functions. 
That is, each symbolic execution $S$ is simply a 
straight-line
program with additional assertions on the way. The problem of path feasibility 
asks whether, for a given program $S$, there exist input strings that take
$S$ to the end of the program while satisfying all the assertions.
%Straight-line programs with assertions 
Notice that such straight-line programs can be viewed as constraints over the 
domain of strings by turning such programs 
into a Static Single Assignment (SSA) form (i.e. introduce a new variable 
on the left hand side of each assignment). The authors initiated the exploration
of what kind of string functions $f$ and $g$ for which the above path 
feasibility problem can be algorithmically solved. 

\subsection{The ``straight-line'' framework}
One clean and powerful way to instantiate the string functions $f$ and $g$
in the assignments/conditionals is to allow some form of finite-state
transducers in their definitions.
%question of incorporating some form of transducers into the definitions of 
%
%the string functions $f$ and $g$ were briefly explored in \cite{BTV09}. 
This proposal was already explored in \cite{BTV09}, wherein the authors mention
that
%
%In
%summary, whenever all 
if the string functions $f$ and $g$ in the program can be captured by 
synchronised $k$-track finite automata (a.k.a.~\defn{automatic structures} 
\cite{BG04}), then
the path feasibility problem becomes decidable. The authors noted, however, that
this is too narrow for applications since string concatenation cannot be
captured in this framework. 

In a recent paper \cite{LB16}, Lin \& Barcelo 
proposed to allow concatenation, regular constraints (i.e. regular expression 
matching), and \emph{one-way} finite-state transducers (not synchronised as in \cite{BTV09}, but only permits one input string and one output string) in straight-line programs. 
%We will define finite-state
%transducers in the following subsection, but 
Roughly speaking, such a transducer is an NFA with an extra output (write-only) 
track, i.e., upon reading an input symbol, it may decide to output (or not output) a symbol 
on the output track. We will define this in more detail below.
In general, the input/output tracks of finite-state transducers may be asynchronous, which means that they cannot be captured by automatic structures of \cite{BG04}. 
Finite-state transducers are powerful for modelling many
different string functions including sanitisation functions (e.g. htmlescape and
backslash-escape) and implicit browser transductions in HTML5 applications (e.g.
innerHTML). Although they noted that this is
undecidable by the result of \cite{BFL13}, decidability can be obtained 
by disallowing \emph{string equality checks in the assertions $g$}, i.e., after
a simplification, we may assume that $g$ contains only regular constraints.
%In
%particular, an application of finite-state transducer and string equality checks
%are prohibited in $g$. 
The dubbed the
resulting class of string constraints \emph{the straight-line fragment}.
They showed that the straight-line fragment is sufficiently powerful in
interesting applications including analysis of cross-site scripting (XSS)
vulnerabilities. Decidable extensions of the straight-line fragment (including
length constraints and disequality checks) were given by the authors, which 
we will discuss in Section \ref{sec:extensions}.

The following is the precise definition
of two-way and one-way finite-state transducers.
\begin{definition}[Finite-State Transducers]
    Let $\ialphabet$ an alphabet.
    A \emph{nondeterministic two-way (finite) \emph{transducers}} (2NFT) over 
    $\ialphabet$ is a tuple $\Transducer = (\ialphabet, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where  $\controls$, $\EndLeft$, $\EndRight$, $q_0$ are precisely the same as those of Definition~\ref{def:2nfa}
%    $\controls$ is a finite set of 
%    states, $\EndLeft$ (resp.~$\EndRight$) a left (resp.~right) input tape end 
%    marker, $q_0\in \controls$ is
%the initial state, $\finals\subseteq \controls$ is a set of final states, 
%
and 
    $\transrel$ is the
transition relation  $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \ialphabet$ with
    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
    there are no transitions that take the head of the tape pass left/right
    end marker. 

    A (nondeterministic one-way finite) transducer (NFT) over
    is a 2NFT whose transition relation contains only tuples of the form
    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
\end{definition}

%\anthony{Define the semantics of 2NFT as function $f: \ialphabet^* \to
%\ialphabet^*$}.\zhilin{Semantics defined below. Please check.}


The notion of runs of 2NFT on an input string can be seen as a generalisation of 2NFA with outputs. More precisely, given a string $w = a_1 \dots a_n$, a \emph{run} of $\Transducer$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a
sequence of tuples $(q_0, i_0, b_0),\ldots, (q_m, i_m, b_m) \in \controls \times [n+1] \times \Sigma$ 
such that, let $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$, %. The following conditions, then, have to be satisfied:
\begin{itemize}
    \item $i_0 = 0$, and
    \item for every $j \in [m-1]$, $(q_j, a_{i_j}, dir, q_{j+1}, b_j) \in
        \transrel$, and $i_{j+1} = i_j + dir$ for some $dir \in \{\Left, \Stay, \Right\}$.
\end{itemize}
The run is said to be \defn{accepting} if $i_m = n+1$ and $q_m \in \finals$. When a run is accepting, $b_0 \cdots b_m$ is said to be the \emph{output} of the run.
A word $w'$ is said to be an output of $\Transducer$ on $w$ if there is an accepting run of
$\Transducer$ on $w$ with output $w'$. We use $\Tran(\Transducer)$ to denote the \emph{transduction} defined by $\Transducer$, that is, the relation comprising the pairs $(w,w')$ such that $w'$ is an output of $\Transducer$ on $w$.

\tl{I propose we unify the term: e.g., using string instead of word}

%============ removed, as agreed that rb will not be included. =========================
%\paragraph{Reversal-bounded transducers.}    
%Let $(q_0, i_0, b_0),\ldots, (q_m, i_m, b_m) $ be a run of $\Transducer$ on some string $w$. A \emph{reversal} of the run is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ where the direction of the reading head is reversed. More precisely, it is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ satisfying one of the following constraints:
%\begin{itemize}
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}+1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}-1$,
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}-1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}+1$. 
%\end{itemize}
%Let $k \in \Nat$. A run of $\Transducer$ is said to be \emph{$k$-reversal-bounded} if the run contains at most $k$ distinct reversals.
%A 2NFT $\Transducer$ is \emph{$k$-reversal-bounded} if all runs of  $\Transducer$ are $k$-reversal-bounded.
%====================================================================================================

Given a 2NFT $T$, We use $\Transducer(x, y)$ to denote the relation such that there is an accepting run of $\Transducer$ on $x$ with the output $y$.
\tl{I feel this is slightly confusing, let's whether we can avoid that}
Moreover, we also write $\Transducer(x, y)$ as $y = \Transducer(x)$.
%, in order to facilitate the definition of straight-line fragments. 
Nevertheless, the reader should remember that $y= \Transducer(x)$ does \emph{not} mean that $\Transducer$ defines a function.

% The set of words accepted by $\Aut$ is denoted by $\Lang(\Aut)$,
%a.k.a., the language \defn{recognised} by $\Aut$.
%Since we deal with computational complexity in the sequel, we define
%The \defn{size} $|\Aut|$ of $\Aut$ is defined to be $|\controls|$; this will
%be needed when we talk about computational complexity.



Recently, Chen \emph{et al.} \cite{CCHLW18}  noted that some XSS vulnerability
analysis involving web templating systems (e.g. \texttt{Mustache.js}
\cite{Mustache}) requires the use of the replace-all function that cannot be
captured by finite-state transducers in \cite{LB16}. Essentially, since the ``holes'' to be 
filled in by data from a separate JSON file might be an arbitrary string, the
replacement string in the replace-all function could in fact be a string
variable. \anthony{Define the replace-all function later}. The authors
showed that the path feasibility problem where the assignments $f$ use the
replace-all function and the conditionals $g$ use the regular constraints 
is still decidable (in fact, with the same complexity as in \cite{LB16} 
EXPSPACE), so long as the pattern variable in the replace-all function is a
regular expression (i.e. \emph{not} a variable). Interestingly, such a usage of
the replace-all function can even capture the concatenation operator, thereby
providing another decidable subclass of the path feasibility problem involving
the replace-all function, the concatenation operator, and regular constraints.

%involves: (i) instantiating 
 
\OMIT{
The basic ``straight-line'' framework from Lin \& Barcelo \cite{LB16} involves: (i) instantiating 
the string functions in program assignments by either concatenation of string
variables/constants or an application of a one-way finite-state transducer
to a string variable/constant, and (ii) instantiating conditionals by regular
constraints.

One-way and two-way transducers. Mention what kind of closure/algorithmic
results.
}

\OMIT{
\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \cdots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \cdots\times L^{(i)}_k$ where $L^{(i)}_j$ a regular for each $j\in [k]$ .
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}
}


\subsection{Parametric transducers}

We now introduce \emph{parametric transducers}, a new transducer model that can 
capture all the
aforementioned string operations (i.e. finite-state transducer from
\cite{LB16} and the replace-all function \cite{CCHLW18}), as well as other 
string functions including the string reverse function.

\begin{definition}[Parametric Transducers]
    Let $\ialphabet$ an alphabet, and $X$ be a set of \emph{parameters}. 
    Assume that $\ialphabet \cap X = \emptyset$ and let $\oalphabet = 
    \ialphabet \cup X$.
    A nondeterministic two-way \emph{parametric transducers} (2NFPT) over 
    $(\ialphabet,X)$ is a tuple $\Transducer =
(\ialphabet, X, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where 
    $\controls$ is a finite set of 
    states, $\EndLeft$ (resp.~$\EndRight$) a left (resp.~right) input tape end 
    marker, $q_0\in \controls$ is
the initial state, $\finals\subseteq \controls$ is a set of final states, and 
    $\transrel$ is the
transition relation  $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \oalphabet$ with
    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
    there are no transitions that take the head of the tape pass left/right
    end marker. 

    A (nondeterministic one-way) parametric transducer (NFPT) over
    is a 2NFPT whose transition relation contains only tuples of the form
    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
is a 2NFA such that $\transrel\subseteq \controls \times \ialphabet\times
    \{\Right,\Stay\} \times \controls $, therefore we
will often write $\transrel\subseteq \controls \times \ialphabet \times 
    \controls$. 
\end{definition}

Notice that parameters are only allowed in the output track.
Intuitively, each instantiation of the parameters $x_1,\ldots,x_m$ with strings 
$w_1,\ldots, w_m$ gives rise to a standard finite-state transducer which outputs
the string $w_j$, whenever a transition of the form $(p, a, dir, x_j, q)$ is
taken by the transducer. This instantiation of the parameters is only done 
\emph{once} before the parametric transducer is run. [It is \emph{precisely}
for this reason that parameteric transducers cannot in general be captured by 
the standard finite-state transducer model that nondeterministically ``guesses''
the parameters separately for each transition.]  We use $\Tran(\Transducer)$ to denote the set of string tuples $(w, w_1, \ldots, w_m, w')$ such that when $x_1,\cdots, x_m$ are instantiated with strings $w_1,\ldots, w_m$, $\Transducer$ produces the output $w'$ from the input $w$. 
\tl{maybe emphasise that this is a  ``off-line" rather than on-line  instantiation?}

We use $z = \Transducer(x, \vec{y})$ to denote the fact that there is an accepting run of $\Transducer$ on $x$, equipped with the parameters $\vec{y}$, producing an output $z$.
\tl{again, this is a relation, not a function.}


Give examples: htmlescape, replace-all, and reverse.

Give example of computing reverse of DNA string.

\subsection{The constraint language}
For a class $\transet$ of parametric transducers, we consider the constraint language $\straightline[\transet]$ which comprises the formulae of the form $\varphi \wedge \psi$ such that $\varphi,\psi$ are defined by the rules,
\[
\begin{array}{l l l r}
\varphi &::=& z = \Transducer(x, \vec{y}) \mid \varphi \wedge \varphi, &  \hfill  \mbox{(relational constraint) } \\ 
\psi &::= & x \in \Aut \mid \psi \wedge \psi, & \hfill \mbox{(regular constraint)} 
\end{array}
\]
where $\Transducer$ is a transducer from $\transet$ over the alphabet $\Sigma$ and $\Aut$ is an NFA over $\Sigma$. Moreover, we require that the dependency graph of $\varphi$ defined below is acyclic. We use $\vars(\varphi \wedge \psi)$ to denote the set of string variables occurring in $\varphi \wedge \psi$.

%Let $\varphi$ be a relational constraint. Then 
The \emph{dependency graph} of a relational constraint $\varphi$, denoted by $\cG(\varphi)$, is the (directed acyclic) graph comprising the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ for $i\in [k]$ and  each atomic formula $z = \Transducer(x, \vec{y})$ in $\varphi$ with $\vec{y}=(y_1, \cdots, y_k)$. Note that $(\Transducer, 0)$ and $(\Transducer, i)$ are the labels of the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ respectively.

Let $\varphi$ be a relational constraint. We use $\rcdim(\varphi)$ to denote the \emph{dimension} of $\varphi$, which is defined as the maximum number of parameters of the transducers occurring in $\varphi$. Moreover, we use $\rcdep(\varphi)$ to denote the \emph{depth} of $\varphi$, which is defined as the maximum length (i.e., number of edges) of the paths in $\cG(\varphi)$.
 
We mainly consider that $\transet$ is 2PT or 1PT in this paper. 
%\tl{I am not sure about the plan, but here maybe it is worth mentioning that concatenation can be treated as 1PT. Moreover, do we consider 2T as well? in this case, concatenation cannot be encoded.} 
%Similarly, we can define $\straightline[\owpt]$.
