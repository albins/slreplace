\section{The Framework: Transducers, Straight-Line Programs}
\label{sec:framework}

In this section we first review the framework of straight-line programs from
\cite{LB16} for analysing symbolic execution of programs with strings, which
involves capturing ``built-in'' functions using finite-state transductions.
We will then introduce the notion of parametric transducers, and show that
they can capture many other interesting string functions that cannot be captured
within the framework of \cite{LB16}. In particular, this allows us to capture
string functions $f: (\Sigma^*)^k \to \Sigma^*$ with multiple input strings
(e.g. the replaceall function), and the string reverse function. 
The framework of straight-line programs from \cite{LB16} can be adapted
to this new notion of transducers, whose path feasibility problem will be shown
to be decidable in Section \ref{sec:algo}.


\anthony{Some abbreviations: 
\begin{itemize}
    \item 2PT, two-way parametric transducers
    \item 1PT, one-way parametric transducers
    \item 2RPT, two-way reversal-bounded parametric transducers
    \item 2T, two-way non-parametric transducers
    \item 1T, one-way non-parametric transducers
\end{itemize}
}

\subsection{The ``straight-line'' framework}

As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be viewed as the problem of \emph{path 
feasibility} over loopless string-manipulating programs $S$ with variable 
assignments and assertions, i.e., generated by the grammar
\begin{equation*}
    S ::= y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$g(x_1,\ldots,x_n)$}}\ |\ 
            S_1; S_2\ 
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation*}
where $f: (\Sigma^*)^n \to \Sigma^*$ and $g: (\Sigma^*)^n \to \{0,1\}$ are
some string functions. 
That is, each symbolic execution $S$ is simply a 
straight-line
program with additional assertions on the way. The problem of path feasibility 
asks whether, for a given program $S$, there exist input strings that take
$S$ to the end of the program while satisfying all the assertions.
%Straight-line programs with assertions 
Notice that such straight-line programs can be viewed as constraints over the 
domain of strings by turning such programs 
into a Static Single Assignment (SSA) form (i.e. introduce a new variable 
on the left hand side of each assignment). The authors initiated the exploration
of what kind of string functions $f$ and $g$ for which the above path 
feasibility problem can be algorithmically solved. 

The question of incorporating some form of transducers into the definitions of 
the string functions $f$ and $g$ were briefly explored in \cite{BTV09}. In
summary, whenever all $f$ and $g$ in the program can be captured by synchronised
$k$-track finite automata (a.k.a.~\defn{automatic structures} \cite{BG04}), then
the path feasibility problem becomes decidable. The authors noted, however, that
this is too narrow for applications since string concatenation cannot be
captured in this framework. In a recent paper \cite{LB16}, Lin \& Barcelo 
proposed to allow concatenation, regular constraints (i.e. regular expression 
matching), and finite-state 
transductions (not
synchronised as in \cite{BTV09}, but only permits one input string and one 
output string) in straight-line programs. We will define finite-state
transducers in the following subsection, but roughly speaking
they are finite-state automata with an extra output (write-only) track, i.e.,
upon reading an input symbol, it may decide to output (or not output) a symbol 
on the output track. [In general, the input/output tracks of finite-state
transducers may be asynchronous, which means that they cannot be captured by
automatic structures of \cite{BG04}.] 
    Finite-state transducers are powerful for modelling many
different string functions including sanitisation functions (e.g. htmlescape and
backslash-escape) and implicit browser transductions in HTML5 applications (e.g.
innerHTML). Although they noted that this is
undecidable by the result of \cite{BFL13}, decidability can be obtained 
by disallowing \emph{string equality checks in the assertions $g$}, i.e., after
a simplification, we may assume that $g$ contains only regular constraints.
%In
%particular, an application of finite-state transducer and string equality checks
%are prohibited in $g$. 
The dubbed the
resulting class of string constraints \emph{the straight-line fragment}.
They showed that the straight-line fragment is sufficiently powerful in
interesting applications including analysis of cross-site scripting (XSS)
vulnerabilities. Decidable extensions of the straight-line fragment (including
length constraints and disequality checks) were given by the authors, which 
we will discuss in Section \ref{sec:extensions}.

Chen \emph{et al.} \cite{CCHLW18} recently noted that some XSS vulnerability
analysis involving web templating systems (e.g. \texttt{Mustache.js}
\cite{Mustache}) requires the use of the replace-all function that cannot be
captured by finite-state transducers. Essentially, since the ``holes'' to be 
filled in by data from a separate JSON file might be an arbitrary string, the
replacement string in the replace-all function could in fact be a string
variable. \anthony{Define the replace-all function later}. The authors
showed that the path feasibility problem where the assignments $f$ use the
replace-all function and the conditionals $g$ use the regular constraints 
is still decidable (in fact, with the same complexity as in \cite{LB16} 
EXPSPACE), so long as the pattern variable in the replace-all function is a
regular expression (i.e. \emph{not} a variable). Interestingly, such a usage of
the replace-all function can even capture the concatenation operator, thereby
providing another decidable subclass of the path feasibility problem involving
the replace-all function, the concatenation operator, and regular constraints.

%involves: (i) instantiating 
 
\OMIT{
The basic ``straight-line'' framework from Lin \& Barcelo \cite{LB16} involves: (i) instantiating 
the string functions in program assignments by either concatenation of string
variables/constants or an application of a one-way finite-state transducer
to a string variable/constant, and (ii) instantiating conditionals by regular
constraints.

One-way and two-way transducers. Mention what kind of closure/algorithmic
results.
}

\OMIT{
\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \cdots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \cdots\times L^{(i)}_k$ where $L^{(i)}_j$ a regular for each $j\in [k]$ .
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}
}

\OMIT{
\begin{definition}[Two-way Finite transducers]
  Nondeterministic two-way finite state \emph{transducers} (2NFTs) over $\Sigma$ and $\Gamma$ extend NFAs with a one-way left-to-right output tape. They are defined as 2NFAs except that the transition relation $\Delta$ is extended with outputs: $\Delta\subseteq Q \times \Sigma \times \Gamma \times \{-1, +1\} \times  Q $. If a transition $(q, a, b, qâ€², m)$ is enabled on a letter $a\in \Sigma$, the letter $b\in \Gamma$ is appended to the right of
	the output tape and the transducer goes to state $q'$.
\end{definition}
}

\subsection{Parametric transducers}

Introduce one-way and two-way parametric transducers. 

Give examples: htmlescape, replace-all, and reverse.

\subsection{The ``straight-line'' framework}

Give example of computing reverse of DNA string.
