%!TEX root = main.tex

\section{The Framework: Transducers, Straight-Line Programs}
\label{sec:framework}

In this section we first review the framework of straight-line programs from
\cite{LB16} for analysing symbolic execution of programs with strings, which
involves capturing ``built-in'' functions using finite-state transductions.
We will then introduce the notion of parametric transducers, and show that
they can capture many other interesting string functions that cannot be captured
within the framework of \cite{LB16}. In particular, this allows us to capture
string functions $f: (\Sigma^*)^k \to \Sigma^*$ with multiple input strings
(e.g. the replaceall function), and the string reverse function. 
The framework of straight-line programs from \cite{LB16} can be adapted
to this new notion of transducers, whose path feasibility problem, defined below, will be shown
to be decidable in Section \ref{sec:algo}.


%\anthony{Some abbreviations: 
%\begin{itemize}
%    \item 2PT, two-way parametric transducers
%    \item 1PT, one-way parametric transducers
%    \item 2RPT, two-way reversal-bounded parametric transducers
%    \item 2T, two-way non-parametric transducers
%    \item 1T, one-way non-parametric transducers
%\end{itemize}
%}

\subsection{A symbolic execution analysis framework} \label{subsec:symexe} 
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be understood in terms of the
problem of \emph{path 
feasibility} over \emph{loopless} string-manipulating programs $S$ with variable
assignments and assertions. 
In other words, each symbolic execution $S$ is simply a program 
without loop or branching, i.e., generated by the grammar
\begin{equation*}
    S ::= \qquad y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$g(x_1,\ldots,x_n)$}}\ |\ 
            S_1; S_2\ 
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation*}
where $f: (\Sigma^*)^n \to \Sigma^*$ and $g: (\Sigma^*)^n \to \{0,1\}$ are
some string functions. 
The syntaxes for the functions $f$ and $g$ are now
left undefined, but will be instantiated as one explores algorithmic issues.
%with additional assertions on the way. 
%\mat{Should the ``straight-line'' restriction be explicitly defined?}
The problem of \defn{path feasibility}
asks whether, for a given program $S$, there exist \emph{input} strings (i.e. 
instantiations of variables that do not appear on left-hand side of an 
assignment) that take
$S$ to the end of the program while satisfying all the assertions. 
In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
%generally, 
binary relations viewed as functions (as in programming, not mathematics) that 
nondeterministically choose an output string corresponding to an input string. 
For example, the 
notation $x := ?$ is common in the program verification to 
denote a nondeterministic assignment to $x$. More generally, nondeterministic
behaviour could be needed due to unknown inputs from a human user or other 
sources (e.g. databases). In this case, path feasibility of a
symbolic execution $S$
is defined in an \emph{angelic} way: each function in $S$
should be to produce \emph{some} output strings that take $S$ to the end of the
program.
%while satisfying all the assertions.
%Straight-line programs with assertions 

Symbolic executions can be viewed as constraints over the 
string domain by turning them
into a \emph{Static Single Assignment} (SSA) form (i.e. introduce a new 
variable 
on the left hand side of each assignment). See Figure \ref{fig:SSA} for an
example.
\begin{figure}
    \qquad
    \begin{minipage}{.49\linewidth}
        $x := x + \text{\texttt{aba}} + y$;\\
        $y := \text{replaceAll}(x,\texttt{a},\texttt{c})$;\\
        \ASSERT{$y \in \texttt{b}^*$}
    \end{minipage}
    \quad
    \begin{minipage}{.49\linewidth}
        $x_1 = x + \texttt{aba} + y\ \wedge$ \\
        $y_1 = \text{replaceAll}(x_1,\texttt{a},\texttt{c})\ \wedge$ \\
        $y_1 \in \texttt{b}^*$
    \end{minipage}
    \caption{String constraint (right) corresponding to a symbolic execution
    (left)
    \label{fig:SSA}}
\end{figure}

\emph{To avoid notational clutter, in the sequel we will follow \cite{BTV09}
and treat string 
constraints simply as symbolic executions in SSA form}, i.e., instead of 
conjunctions of atomic formulas from some logical theories. 
This simplifies 
the presentation of our decidable string logics and others in the literature 
(e.g. \cite{LB16,CCHLW18}) without obfuscating the connection to logic.


\subsection{The ``straight-line'' framework}
Bj\"{o}rner \emph{et al.} \cite{BTV09} initiated the exploration
of what kind of string functions $f$ and $g$ for which the above path 
feasibility problem can be algorithmically solved. 
One clean and powerful way to achieve decidability is to 
%functions $f$ and $g$
%in the assignments/conditionals is to 
allow some form of finite-state transducers in the definitions of $f$
and $g$.
%question of incorporating some form of transducers into the definitions of 
%
%the string functions $f$ and $g$ were briefly explored in \cite{BTV09}. 
This proposal was already explored in \cite{BTV09}, wherein the authors mention
that
%
%In
%summary, whenever all 
if the string functions $f$ and $g$ in the program can be captured by 
synchronised $k$-track finite automata (a.k.a.~\defn{automatic structures} 
\cite{BG04}), then
the path feasibility problem becomes decidable. They noted, however, that
this is too narrow for applications since string concatenation cannot be
captured in this framework. 

In a recent paper \cite{LB16}, Lin and Barcelo 
proposed allowing concatenation, regular constraints (i.e. regular expression 
matching), and \emph{one-way} finite-state transducers (not synchronised as in \cite{BTV09}, but only permits one input string and one output string) in 
straight-line programs. Finite transducers are a classic concept from
the theory of formal languages (e.g. see \cite{Berstel}).
%We will define finite-state
%transducers in the following subsection, but 
Roughly speaking, a finite transducer is an NFA with an extra output (write-only) 
track, i.e., upon reading an input symbol, it may decide to output (or not output) a symbol 
on the output track. We will define this in more detail below.
In general, the input/output tracks of finite-state transducers may be 
\emph{asynchronous}, which means that they cannot be captured by automatic structures of \cite{BG04}. 
Finite-state transducers are powerful for modelling many
different string functions including sanitisation functions (e.g. htmlescape and
backslash-escape) and implicit browser transductions in HTML5 applications (e.g.
innerHTML). Although they noted that this is
undecidable by the result of \cite{BFL13}, decidability can be obtained 
by disallowing \emph{string equality checks in the assertions $g$}, i.e., after
a simplification, we may assume that $g$ contains only regular constraints.
%In
%particular, an application of finite-state transducer and string equality checks
%are prohibited in $g$. 
The 
resulting class of string constraints is dubbed \emph{the straight-line 
fragment}.
They showed that the straight-line fragment is sufficiently powerful in
interesting applications including analysis of cross-site scripting (XSS)
vulnerabilities. 
%as we do not have these extensions, comment the following sentences out. 
%Decidable extensions of the straight-line fragment (including
%length constraints and disequality checks) were given by the authors, which 
%we will discuss in Section \ref{sec:extensions}.

The following is the precise definition
of two-way and one-way finite-state transducers.
\begin{definition}[Finite-State Transducers]
    Let $\ialphabet$ an alphabet and $\ialphabet_\epsilon = \ialphabet
    \cup \{\epsilon\}$.
    A \emph{nondeterministic two-way (finite) \emph{transducer}} (2NFT) over 
    $\ialphabet$ is a tuple $\Transducer = (\ialphabet, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where  $\controls$, $\EndLeft$, $\EndRight$, $q_0$ are precisely the same as those of Definition~\ref{def:2nfa}
%    $\controls$ is a finite set of 
%    states, $\EndLeft$ (resp.~$\EndRight$) a left (resp.~right) input tape end 
%    marker, $q_0\in \controls$ is
%the initial state, $\finals\subseteq \controls$ is a set of final states, 
%
and 
    $\transrel$ is the
transition relation  $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \ialphabet_\epsilon$ with
    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
    there are no transitions that take the head of the tape past the left/right
    end marker. 
    A (nondeterministic one-way finite) transducer (NFT) over
    $\ialphabet$
    is a 2NFT whose transition relation contains only tuples of the form
    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
\end{definition}

%\anthony{Define the semantics of 2NFT as function $f: \ialphabet^* \to
%\ialphabet^*$}.\zhilin{Semantics defined below. Please check.}


The notion of runs of 2NFTs on an input string can be seen as a generalisation 
of 2NFA by adding outputs. More precisely, given a string $w = a_1 \dots a_n$, a \emph{run} of $\Transducer$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a
sequence of tuples $(q_0, i_0, b_0),\ldots, (q_m, i_m, b_m) \in \controls \times
[n+1] \times \Sigma$ 
such that, letting $a_0 =\ \EndLeft$ and $a_{n+1} =\ \EndRight$, 
we have %. The following conditions, then, have to be satisfied:
\begin{itemize}
    \item $i_0 = 0$, and
    \item for every $j \in [m-1]$, $(q_j, a_{i_j}, dir, q_{j+1}, b_j) \in
        \transrel$, and $i_{j+1} = i_j + dir$ for some $dir \in \{\Left, \Stay, \Right\}$.
\end{itemize}
The run is said to be \defn{accepting} if $i_m = n+1$ and $q_m \in \finals$.
When a run is accepting, $b_0 \cdots b_m$ is said to be the \emph{output} of the
run. Note that some of these $b_i$'s could be empty strings by definition, i.e.,
$b_i \in \ialphabet_\epsilon$.
A word $w'$ is said to be an output of $\Transducer$ on $w$ if there is an accepting run of
$\Transducer$ on $w$ with output $w'$. We use $\Tran(\Transducer)$ to denote the
\emph{transduction} defined by $\Transducer$, that is, the relation comprising
the pairs $(w,w')$ such that $w'$ is an output of $\Transducer$ on $w$. 

\begin{example}
    We give three examples of finite transducers: (1) erasing \texttt{a} from
    a string, (2) the function escapeString, and (3) the reverse function.
%Figure
%\ref{fig:escapeString} contains an example of the function escapeString,

    The first transducer is easy, but justifies that we need to allow $\epsilon$
    in the output. This can be one by a \FT{} with states $q_0$, $q_1$,
    $q_2$, and transitions $(q_0,\EndLeft,1,q_1,\epsilon)$,
    $(q_1,\ell,1,q_1,\ell)$ (for $\ell \neq \texttt{a}$), 
    $(q_1,\texttt{a},1,q_1,\epsilon)$, and
    $(q_1,\EndRight,1,q_2,\epsilon)$. The final state is $q_2$.

    The second transducer backslash-escapes every occurrence of \texttt{'} and 
    \texttt{"}. This can also be done by a \FT{} in a similar way. Instead of
    providing the formal definition, we depict this informally as a 
    state-diagram in Figure
    \ref{fig:escapeString} bearing in mind that the transitions for the
    left/right end markers are omitted, and that the transition label
    $a/b$ means \emph{read $a$, and at the same time output $b$}.
%$a/w$ denotes 

\input{escapeString}

    The final transducer requires us to use a \FFT{}. We will only describe
    this informally. The transducer will firstly go to the end of the input tape
    without outputting any symbol. The transducer then scans the input from
    right to left, while simultaneously outputting the symbol that is read.
    When the transducer hits $\EndLeft$, it moves its input head back to the 
    right end (without outputting any further symbol), and accept.
\end{example}

%\tl{I propose we unify the term: e.g., using string instead of word}
%\anthony{I think it doesn't matter too much if we use both word/string. My
%suggestion is to try to use one \emph{more often}}

%============ removed, as agreed that rb will not be included. =========================
%\paragraph{Reversal-bounded transducers.}    
%Let $(q_0, i_0, b_0),\ldots, (q_m, i_m, b_m) $ be a run of $\Transducer$ on some string $w$. A \emph{reversal} of the run is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ where the direction of the reading head is reversed. More precisely, it is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ satisfying one of the following constraints:
%\begin{itemize}
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}+1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}-1$,
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}-1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}+1$. 
%\end{itemize}
%Let $k \in \Nat$. A run of $\Transducer$ is said to be \emph{$k$-reversal-bounded} if the run contains at most $k$ distinct reversals.
%A 2NFT $\Transducer$ is \emph{$k$-reversal-bounded} if all runs of  $\Transducer$ are $k$-reversal-bounded.
%====================================================================================================

%Given a 2NFT $T$, We use $\Transducer(x, y)$ to denote the relation such that there is an accepting run of $\Transducer$ on $x$ with the output $y$.
%\tl{I feel this is slightly confusing, let's whether we can avoid that}
%\mat{
%    I don't understand it (the sentence above).
%    Do you mean we write
%    $\Transducer(x, y)$
%    whenever 
%    $(x, y) \in \Tran(\Transducer)$?
%}
%Moreover, we also write $\Transducer(x, y)$ as $y = \Transducer(x)$.
%%, in order to facilitate the definition of straight-line fragments. 
%Nevertheless, the reader should remember that $y= \Transducer(x)$ does \emph{not} mean that $\Transducer$ defines a function.

% The set of words accepted by $\Aut$ is denoted by $\Lang(\Aut)$,
%a.k.a., the language \defn{recognised} by $\Aut$.
%Since we deal with computational complexity in the sequel, we define
%The \defn{size} $|\Aut|$ of $\Aut$ is defined to be $|\controls|$; this will
%be needed when we talk about computational complexity.


\OMIT{
Recently, Chen \emph{et al.} \cite{CCHLW18}  noted that some XSS vulnerability
analysis involving web templating systems (e.g. \texttt{Mustache.js}
\cite{Mustache}) requires the use of the replace-all 
\mat{replaceall or replace-all? -- i think both are used}
function that cannot be
captured by finite-state transducers in \cite{LB16}. Essentially, since the ``holes'' to be 
filled in by data from a separate JSON file might be an arbitrary string, the
replacement string in the replace-all function could in fact be a string
variable. \anthony{Define the replace-all function later}. The authors
showed that the path feasibility problem where the assignments $f$ use the
replace-all function and the conditionals $g$ use the regular constraints 
is still decidable (in fact, with the same complexity as in \cite{LB16} 
EXPSPACE), so long as the pattern variable in the replace-all function is a
regular expression (i.e. \emph{not} a variable). Interestingly, such a usage of
the replace-all function can even capture the concatenation operator, thereby
providing another decidable subclass of the path feasibility problem involving
the replace-all function, the concatenation operator, and regular constraints.
}


%involves: (i) instantiating 
 
\OMIT{
The basic ``straight-line'' framework from Lin \& Barcelo \cite{LB16} involves: (i) instantiating 
the string functions in program assignments by either concatenation of string
variables/constants or an application of a one-way finite-state transducer
to a string variable/constant, and (ii) instantiating conditionals by regular
constraints.

One-way and two-way transducers. Mention what kind of closure/algorithmic
results.
}

\OMIT{
\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \cdots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \cdots\times L^{(i)}_k$ where $L^{(i)}_j$ a regular for each $j\in [k]$ .
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}
}


\subsection{Parametric transducers}

We now introduce \emph{parametric transducers}, a new transducer model that can 
capture all the
aforementioned string operations (i.e. finite-state transducer from
\cite{LB16} and the replace-all function \cite{CCHLW18}), as well as other 
string functions including the string reverse function.

\begin{definition}[Parametric Transducers]
    Let $\ialphabet$ an alphabet, and $X$ be a set of \emph{parameters}. 
    Assume that $\ialphabet \cap X = \emptyset$ and let $\oalphabet = 
    \ialphabet \cup X$. Define $\oalphabet_\epsilon = \oalphabet \cup
    \{\epsilon\}$.
    A (nondeterministic) two-way \emph{parametric transducer} (\PPT) over 
    $(\ialphabet,X)$ is a tuple $\Transducer =
(\ialphabet, X, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where 
    $\controls$ is a finite set of 
    states, $\EndLeft$ (resp.~$\EndRight$) a left (resp.~right) input tape end 
    marker, $q_0\in \controls$ is
the initial state, $\finals\subseteq \controls$ is a set of final states, and 
    $\transrel$ is the
transition relation  $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \oalphabet_\epsilon$ with
    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
    there are no transitions that take the head of the tape past the left/right
    end marker. 
    A (nondeterministic one-way) parametric transducer (\PT) over
    $\ialphabet$
    is a \PPT{} whose transition relation contains only tuples of the form
    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
\end{definition}
\OMIT{
    The usual notion of finite transducers can now be defined as parametric 
    transducers that do not output parameters.
\begin{definition}
    A (nondeterministic) two-way \defn{finite transducer} (\FFT) is a \PPT{} 
    over
    $(\ialphabet,X)$, where $X = \emptyset$. Similarly, a (nondeterministic
    one-way finite) transducer (\FT) is defined in the similar way but with
    a \PT{} instead of \PPT{}.
\end{definition}
}

Notice that parameters are only allowed in the output track.
Intuitively, each instantiation of the parameters $x_1,\ldots,x_m$ with strings 
$w_1,\ldots, w_m \in \ialphabet^*$ gives rise to a standard finite-state transducer which outputs
the string $w_j$, whenever a transition of the form $(p, a, dir, x_j, q)$ is
taken by the transducer. More formally, let 
$\Transducer[w_1/x_1,\ldots,w_m/x_m]$ denote the (non-parametric) finite
transducer obtained from $\Transducer$ by replacing every occurrence of each
parameter $x_i$ in $\Transducer$ by the string $w_i$.
[Note that this instantiation of the parameters is only done 
\emph{once} before the parametric transducer is run. It is \emph{precisely}
for this reason that parameteric transducers cannot in general be captured by 
the standard finite-state transducer model that nondeterministically ``guesses''
the parameters separately for each transition.]  
We use $\Tran(\Transducer)$ to denote the set of string tuples 
$(w, w_1, \ldots, w_m, w')$ such that 
$(w,w') \in \Tran(\Transducer[w_1/x_1,\ldots,w_m/x_m])$, i.e., when
$x_1,\cdots, x_m$ are instantiated with strings $w_1,\ldots, w_m$, 
$\Transducer$ produces the output $w'$ from the input $w$. 

%\tl{maybe emphasise that this is a  ``off-line" rather than on-line  instantiation?}

%We use $z = \Transducer(x, \vec{y})$ to denote the fact that there is an accepting run of $\Transducer$ on $x$, equipped with the parameters $\vec{y}$, producing an output $z$.
%\tl{again, this is a relation, not a function.}


Give examples: htmlescape, replace-all, and reverse.

Give example of computing reverse of DNA string.

\OMIT{
\subsection{The constraint language}

\mat{
    Can i propose we replace the constraint language with straight-line programs?
    Then we can get rid of the dependency graph and edges.
    Instead we just say that variables are assigned at most once (input variables are not assigned), and any variable appearing in the $i$th statement is an input or was assigned in the $j$th statement for some $j < i$.
    The generic algorithm then always picks the last assignment to eliminate, instead of some variable with no predecessors in the dependency graph.
    The former is easy to picture and recall, the latter requires absorbing the definition of dependency graph, remembering which direction the edges go, and realising that a variable with no predecessors is a statement with no functions/transductions that use it.
    We can note the connection to the constraint language defined below if we want to.
}

For a class $\transet$ of parametric transducers, we consider the constraint language $\straightline[\transet]$ which comprises a formulae of the form $\varphi \wedge \psi$ such that $\varphi,\psi$ are defined by the rules,
\[
\begin{array}{l l l r}
\varphi &::=& z = \Transducer(x, \vec{y}) \mid \varphi \wedge \varphi, &  \hfill  \mbox{(relational constraint) } \\ 
\psi &::= & x \in \Aut \mid \psi \wedge \psi, & \hfill \mbox{(regular constraint)} 
\end{array}
\]
where $\Transducer$ is a transducer from $\transet$ over the alphabet $\Sigma$ and $\Aut$ is an NFA over $\Sigma$. Moreover, we require that the dependency graph of $\varphi$ defined below is acyclic. We use $\vars(\varphi \wedge \psi)$ to denote the set of string variables occurring in $\varphi \wedge \psi$.

%Let $\varphi$ be a relational constraint. Then 
The \emph{dependency graph} of a relational constraint $\varphi$, denoted by $\cG(\varphi)$, is the (directed acyclic) graph comprising the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ for $i\in [k]$ and  each atomic formula $z = \Transducer(x, \vec{y})$ in $\varphi$ with $\vec{y}=(y_1, \cdots, y_k)$. Note that $(\Transducer, 0)$ and $(\Transducer, i)$ are the labels of the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ respectively.

Let $\varphi$ be a relational constraint. We use $\rcdim(\varphi)$ to denote the \emph{dimension} of $\varphi$, which is defined as the maximum number of parameters of the transducers occurring in $\varphi$. Moreover, we use $\rcdep(\varphi)$ to denote the \emph{depth} of $\varphi$, which is defined as the maximum length (i.e., number of edges) of the paths in $\cG(\varphi)$.
 
We mainly consider that $\transet$ is 2PT or 1PT in this paper. 
%\tl{I am not sure about the plan, but here maybe it is worth mentioning that concatenation can be treated as 1PT. Moreover, do we consider 2T as well? in this case, concatenation cannot be encoded.} 
%Similarly, we can define $\straightline[\owpt]$.
}
