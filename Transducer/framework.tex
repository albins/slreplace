%!TEX root = main.tex

\section{Parametric Transducers and the Constraint Language}
\label{sec:framework}

We have defined the framework of Bj\"{o}rner \emph{et al.} \cite{BTV09} of
constraints from symbolic executions in the Introduction.
For ease of reading, we provide the more specific grammar for symbolic executions $S$ satisfying
the \emph{straight-line restriction} from Lin and Barcelo \cite{LB16} that we already discussed in the Introduction (i.e. only regular constraints are allowed in an assertion): 
\begin{equation}
    S ::= \qquad y := f(x_1,\ldots,x_\arity) \ |\ \text{\ASSERT{$x \in L$}}\ |\ 
            S_1; S_2\ 
            \label{eq:SL}
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation}
where $f: (\Sigma^*)^\arity \to \Sigma^*$ is a (partial) string function, and $L$ is a 
regular language. 
%In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
\OMIT{
=======
We have introduced the framework of Bj\"{o}rner \emph{et al.} \cite{BTV09} of
constraints from symbolic executions in the Introduction, in particular, Eq.~\eqref{eq:symbex}. We remark that this agrees to 
the commonly adopted \emph{straight-line restriction} \cite{LB16} on the constraint. 



%Following the \emph{straight-line restriction} from Lin and Barcelo \cite{LB16},
%our constraint
%language deals with symbolic executions $S$ generated by the following grammars:
%\begin{equation}
%    S ::= \qquad y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$x \in L$}}\ |\ 
%            S_1; S_2\ 
%            \label{eq:SL}
%    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
%\end{equation}
%where $f: (\Sigma^*)^n \to \Sigma^*$ is a partial function, and $L$ is a 
%regular language. 

In this paper, for \emph{assertions} of the constraint language ($g$ in (\ref{eq:symbex})) we focus on \emph{regular constraints} exclusively. Namely, $g$ is instantiated by  $\text{\ASSERT{$x \in L$}}$ for a regular language $L$.
For \emph{assignment} ($f$ in (\ref{eq:symbex})), %in general, it is useful to #
we allow $f$ to be %\emph{partial} functions or, more
>>>>>>> 7429533e25607629e2cd9d233fad7e75914bde4d
}
%generally, 
%binary relations viewed as functions (as in programming, not mathematics) that 
%\emph{nondeterministically} choose an output string corresponding to an input string. 
%%
%For example, the 
%notation $x := ?$ is common in the program verification to 
%denote a nondeterministic assignment to $x$. More generally, nondeterministic
%behaviour could be needed due to unknown inputs from a human user or other 
%sources (e.g. databases). 
%
%In this case, path feasibility of a
%symbolic execution $S$
%is defined in an \emph{angelic} way: each function in $S$
%should be able to produce \emph{some} output string that takes $S$ to the end of the
%program.
%
%Our constraint language is obtained by instantiating 
%Technically we shall instantiate $f$ with a \emph{parametric
%transducer}, a notion which we will define in this section. 

\OMIT{
In this section, we first review the framework of straight-line programs from
\cite{LB16} for analysing symbolic execution of programs with strings, which
involves capturing ``built-in'' functions using finite-state transductions.
We will then introduce the notion of parametric transducers, and show that
they can capture many other interesting string functions that cannot be captured
within the framework of \cite{LB16}. In particular, this allows us to capture
string functions $f: (\Sigma^*)^k \to \Sigma^*$ with multiple input strings
(e.g. the concatenation and replaceall function), and the string reverse function. 
The framework of straight-line programs from \cite{LB16} can be adapted
to this new notion of transducers, whose path feasibility problem, defined below, will be shown
to be decidable in Section \ref{sec:algo}.
}


%\anthony{Some abbreviations: 
%\begin{itemize}
%    \item 2PT, two-way parametric transducers
%    \item 1PT, one-way parametric transducers
%    \item 2RPT, two-way reversal-bounded parametric transducers
%    \item 2T, two-way non-parametric transducers
%    \item 1T, one-way non-parametric transducers
%\end{itemize}
%}

\OMIT{
\subsection{A symbolic execution analysis framework} \label{subsec:symexe} 
As elegantly described in Bj\"{o}rner \emph{et al.} \cite{BTV09}, constraints 
from symbolic 
execution on string-manipulating programs can be understood in terms of the
problem of \emph{path 
feasibility} over \emph{loopless} string-manipulating programs $S$ with variable
assignments and assertions. 
In other words, each symbolic execution $S$ is simply a program 
without loop or branching, i.e., generated by the grammar
\begin{equation*}
    S ::= \qquad y := f(x_1,\ldots,x_n) \ |\ \text{\ASSERT{$g(x_1,\ldots,x_n)$}}\ |\ 
            S_1; S_2\ 
    %a ::= f(x_1,\ldots,x_n), \qquad b ::= g(x_1,\ldots,x_n) 
\end{equation*}
where $f: (\Sigma^*)^n \to \Sigma^*$ and $g: (\Sigma^*)^n \to \{0,1\}$ are
some string functions. 
The syntaxes for the functions $f$ and $g$ are now
left undefined, but will be instantiated as one explores algorithmic issues.
%with additional assertions on the way. 
%\mat{Should the ``straight-line'' restriction be explicitly defined?}
The problem of \defn{path feasibility}
asks whether, for a given program $S$, there exist \emph{input} strings (i.e. 
instantiations of variables that do not appear in the left-hand side of an 
assignment) that take
$S$ to the end of the program while satisfying all the assertions. 
In general, it is useful to allow $f$ to be %\emph{partial} functions or, more
%generally, 
binary relations viewed as functions (as in programming, not mathematics) that 
nondeterministically choose an output string corresponding to an input string. 
For example, the 
notation $x := ?$ is common in the program verification to 
denote a nondeterministic assignment to $x$. More generally, nondeterministic
behaviour could be needed due to unknown inputs from a human user or other 
sources (e.g. databases). In this case, path feasibility of a
symbolic execution $S$
is defined in an \emph{angelic} way: each function in $S$
should be able to produce \emph{some} output string that takes $S$ to the end of the
program.
%while satisfying all the assertions.
%Straight-line programs with assertions 

Symbolic executions can be viewed as constraints over the 
string domain by turning them
into a \emph{Static Single Assignment} (SSA) form (i.e. introduce a new 
variable 
on the left hand side of each assignment). See \ref{fig:SSA} for an
example.
\begin{figure}
    \qquad
    \begin{minipage}{.49\linewidth}
        $x := x + \text{\texttt{aba}} + y$;\\
        $y := \text{replaceAll}(x,\texttt{a},\texttt{c})$;\\
        \ASSERT{$y \in \texttt{b}^*$}
    \end{minipage}
    \quad
    \begin{minipage}{.49\linewidth}
        $x_1 = x + \texttt{aba} + y\ \wedge$ \\
        $y_1 = \text{replaceAll}(x_1,\texttt{a},\texttt{c})\ \wedge$ \\
        $y_1 \in \texttt{b}^*$
    \end{minipage}
    \caption{String constraint (right) corresponding to a symbolic execution
    (left)
    \label{fig:SSA}}
\end{figure}

\emph{To avoid notational clutter, in the sequel we will follow \cite{BTV09}
and treat string 
constraints simply as symbolic executions in SSA form}, i.e., instead of 
conjunctions of atomic formulas from some logical theories. 
This simplifies 
the presentation of our decidable string logics and others in the literature 
(e.g. \cite{LB16,CCHLW18}) without obfuscating the connection to logic.


\subsection{The ``straight-line'' framework}
Bj\"{o}rner \emph{et al.} \cite{BTV09} initiated the exploration
of what kind of string functions $f$ and $g$ for which the above path 
feasibility problem can be algorithmically solved. 
One clean and powerful way to achieve decidability is to 
%functions $f$ and $g$
%in the assignments/conditionals is to 
allow some form of finite-state transducers in the definitions of $f$
and $g$.
%question of incorporating some form of transducers into the definitions of 
%
%the string functions $f$ and $g$ were briefly explored in \cite{BTV09}. 
This proposal was already explored in \cite{BTV09}, wherein the authors mention
that
%
%In
%summary, whenever all 
if the string functions $f$ and $g$ in the program can be captured by 
synchronised $k$-track finite automata (a.k.a.~\defn{automatic structures} 
\cite{BG04}), then
the path feasibility problem becomes decidable. They noted, however, that
this is too narrow for applications since string concatenation cannot be
captured in this framework. 

In a recent paper \cite{LB16}, Lin and Barcelo 
proposed allowing concatenation, regular constraints (i.e. regular expression 
matching), and \emph{one-way} finite-state transducers (not synchronised as in \cite{BTV09}, but only permits one input string and one output string) in 
straight-line programs. Finite transducers are a classic concept from
the theory of formal languages (e.g. see \cite{Berstel}).
%We will define finite-state
%transducers in the following subsection, but 
Roughly speaking, a finite transducer is an \FA{} with an extra output (write-only) 
track, i.e., upon reading an input symbol, it may decide to output a string 
on the output track. We will define this in more details below.
In general, the input/output tracks of finite-state transducers may be 
\emph{asynchronous}, which means that they cannot be captured by automatic structures of \cite{BG04}. 
Finite-state transducers are powerful for modelling many
different string functions including sanitisation functions (e.g. htmlescape and
backslash-escape) and implicit browser transductions in HTML5 applications (e.g.
innerHTML). Although they noted that this is
undecidable by the result of \cite{BFL13}, decidability can be obtained 
by {\bf disallowing string equality checks in the assertions $g$}, i.e., after
a simplification, we may assume that {\bf $g$ contains only regular constraints}.
%In
%particular, an application of finite-state transducer and string equality checks
%are prohibited in $g$. 
The 
resulting class of string constraints is dubbed \emph{the straight-line 
fragment}.
They showed that the straight-line fragment is sufficiently powerful in
interesting applications including analysis of cross-site scripting (XSS)
vulnerabilities. 
%as we do not have these extensions, comment the following sentences out. 
%Decidable extensions of the straight-line fragment (including
%length constraints and disequality checks) were given by the authors, which 
%we will discuss in Section \ref{sec:extensions}.
}
%====================================== deleted ======================================================

\subsection{Non-parametric transducers}
%We will start by giving the precise definition of two-way and one-way  finite transducers. 
%which %are respectively two-way and one-way finite-state automata extended with outputs.  
\begin{definition}[Finite-State Transducers]
    Let $\ialphabet$ be an alphabet. A \emph{nondeterministic two-way finite  transducer} (\FFT{}) $\Transducer$  over $\ialphabet$ is a tuple $(\ialphabet, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$, where $\transrel$ is  a finite subset of $\controls \times \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \ialphabet^*$, satisfying the syntactical constraints of \FFA{}s, and the additional constraint that the output must be $\epsilon$ when reading $\EndLeft$ or $\EndRight$. Formally, for each transition $(q, \EndLeft, dir, q', w)$ or $(q, \EndRight, dir, q', w)$ in $\delta$, we have $w=\epsilon$.
%
%    A \emph{nondeterministic two-way (finite) \emph{transducer}} (\FFT{}) over 
%    $\ialphabet$ is a tuple $\Transducer = (\ialphabet, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where  $\controls$, $\EndLeft$, $\EndRight$, $q_0$, and $\finals$ are precisely the same as those of Definition~\ref{def:2nfa}
%
%and 
%    $\transrel$ is the
%transition relation  $\transrel\subseteq \controls \times 
%    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
%    \controls \times \ialphabet_\epsilon$ with
%    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
%    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
%    there are no transitions that take the head of the tape past the left/right
%    end marker. 
%
A (nondeterministic one-way) finite transducer (\FT{}) over
    $\ialphabet$ is a \FFT{} such that $\transrel \subseteq \controls \times \overline{\ialphabet} \times
    \{\Right,\Stay\} \times \controls \times \ialphabet^*$.
%A sweeping \FFT{} (\SFFT{}) is defined similarly to \SFFA.
%    whose transition relation contains only tuples of the form
%    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
\end{definition}
%\zhilin{I simplified the above definition slightly, please check. I also extend the 2FTs to allow multiple output symbols in one transition. Moreover, I assume that for each transition $(q, \EndLeft, \Right/\Stay, q', b)$, we have $b=\epsilon$. Similarly for $\EndRight$.} \tl{polish slightly, hopefully ok.}
%
%\anthony{Define the semantics of \FFT{} as function $f: \ialphabet^* \to
%\ialphabet^*$}.\zhilin{Semantics defined below. Please check.}
%
The notion of runs of \FFT{}s on an input string can be seen as a generalisation 
of \FFA{}s by adding outputs. More precisely, given a string $w = a_1 \dots a_n$, a \emph{run} of $\Transducer$ on $w$
%(with $a_0 = \EndLeft$ and $a_{n+1} = \EndRight$)
is a sequence of tuples $(q_0, i_0, w'_0),\ldots, (q_m, i_m, w'_m) \in \controls \times
[0, n+1] \times \Sigma^*$ 
such that, if $a_0 =\ \EndLeft$ and $a_{n+1} =\ \EndRight$, 
we have $i_0 = 0$, and  for every $j \in [0, m-1]$, $(q_j, a_{i_j}, dir, q_{j+1}, w'_j) \in
        \transrel$, $i_{j+1} = i_j + dir$ for some $dir \in \{\Left, \Stay, \Right\}$, and $w'_0 = w'_m = \varepsilon$.
The run is said to be \defn{accepting} if $i_m = n+1$ and $q_m \in \finals$.
When a run is accepting, $w'_0 \cdots w'_m$ is said to be the \emph{output} of the
run. Note that some of these $w'_i$'s could be empty strings.
A word $w'$ is said to be an output of $\Transducer$ on $w$ if there is an accepting run of
$\Transducer$ on $w$ with output $w'$. We use $\Tran(\Transducer)$ to denote the
\emph{transduction} defined by $\Transducer$, that is, the relation comprising
the pairs $(w,w')$ such that $w'$ is an output of $\Transducer$ on $w$. 
%\tl{I add this, please feel free to edit}
In this paper, we are mainly interested in \emph{functional
transducers}, i.e., transducers that define functions instead of relations. (For instance, deterministic transducers are always functional.) 
%In this paper, transducers 
%define functions, but can be non-deterministic.

To take into consideration the outputs of transitions, we define the \emph{size} $|\Transducer|$ of $\Transducer$ as the sum of the sizes of transitions in $\Transducer$, where the size of a transition $(q, a, dir, q', w')$ is defined as $|w'|+1$. With the assumption that only $\epsilon$ can be outputted when reading $\EndLeft$ or $\EndRight$, for simplicity, we omit the two end markers $\EndLeft$ and $\EndRight$ in \FT{}s, that is, $\transrel \subseteq \controls \times \ialphabet \times \{\Right,\Stay\} \times \controls \times \ialphabet^*$. Note that each accepting run of an \FT{} has to read through the input string and stop in the right end.


\begin{example}\label{exmp-ft}
    We give two examples of \FT{}s: %(1) erasing \texttt{a} from  a string, (2) 
    (1) the function \textbf{escapeString}, and (2) the  function \textbf{reverse}.
%Figure
%\ref{fig:escapeString} contains an example of the function escapeString,
%
%\begin{wrapfigure}{R}{5cm}
%	\begin{center}
%		\begin{tikzpicture}[shorten >=1pt,node distance=2.3cm,on grid,auto, initial text={}] 
%		\node[state,initial,accepting] (q_0) {$q_0$}; 
%		%    \node[state] (q_1) [above right=of q_0] {$q_1$}; 
%		%    \node[state] (q_2) [below right=of q_0] {$q_2$}; 
%		\path[->]
%		(q_0) edge  [loop above] node {$\ell$/$\ell$} (q_0)
%		edge  [loop right] node {\texttt{'}/\texttt{\textbackslash'}} (q_0)
%		edge  [loop below] node {\texttt{"}/\texttt{\textbackslash"}} (q_0);
%		%          edge  [bend left] node [right] {\texttt{"}/\texttt{\textbackslash}} (q_2)
%		%    (q_1) edge  [bend left] node  {$\epsilon$/\texttt{'}} (q_0)
%		%    (q_2) edge  [bend left] node  {$\epsilon$/\texttt{"}} (q_0);
%		\end{tikzpicture}
%	\end{center}
%	\caption{
%		A transducer that replaces every occurrence of \texttt{'} and
%		\texttt{"} with, respectively, \texttt{\textbackslash '} and 
%		\texttt{\textbackslash "}. Here,
%		$\ell$ is every symbol in the alphabet that is neither 
%		\texttt{'} nor \texttt{"}. \label{fig:escapeString}}
%	%\input{escapeString}
%\end{wrapfigure}
%
%    The first transducer is easy, but justifies that we need to allow $\epsilon$
%    in the output. 
%    This can be one by a \FT{} with a single state $q_0$,
%    transitions 
%    %$(q_0, \EndLeft, 1, q_1,\epsilon)$,
%    $(q_0, \ell, 1, q_0, \ell)$ for each $\ell \neq \texttt{a}$, 
%    $(q_0,\texttt{a}, 1, q_0, \epsilon)$, 
%    %and
%    %$(q_1,\EndRight,0,q_2,\epsilon)$. 
%    and the final state $q_0$.
%%\zhilin{I removed the two end markers.}
%
The first function backslash-escapes every occurrence of \texttt{'} and 
\texttt{"}. This can be modelled by an \FT{} with a single state $q_0$,
transitions 
%$(q_0, \EndLeft, 1, q_1,\epsilon)$,
$(q_0, \ell, 1, q_0, \ell)$ for each $\ell \neq  \texttt{'}$  or $\texttt{"} $, 
$(q_0,\texttt{'}, 1, q_0, \textbackslash\texttt{'})$, 
$(q_0,\texttt{"}, 1, q_0, \textbackslash\texttt{"})$,  
%and
%$(q_1,\EndRight,0,q_2,\epsilon)$. 
and the final state $q_0$.
%\zhilin{I removed the two end markers.}
%
%    The second transducer backslash-escapes every occurrence of \texttt{'} and 
%    \texttt{"}. This can also be done by a \FT{} in a similar way. Instead of
%    providing the formal definition, we depict this informally as a 
%    state-diagram in Figure
%    \ref{fig:escapeString}, bearing in mind that 
%    %the transitions for the left/right end markers are omitted, and that
%     the transition label
%    $a/w$ means \emph{read $a$, and meanwhile output $w$}.
%%$a/w$ denotes 
%
The second function requires us to use a \FFT{}, which we will only describe
informally. The transducer $\Transducer_{\sf reverse}$ will firstly move to $\EndRight$ of the input tape
    without outputting any symbol. It then scans the input from
    right to left, while outputting the symbol that is read.
    When $\EndLeft$ is reached, it moves its input head right to $\EndRight$ (without outputting any further symbol), and accepts.     \qed
\end{example}

%\tl{I propose we unify the term: e.g., using string instead of word}
%\anthony{I think it doesn't matter too much if we use both word/string. My
%suggestion is to try to use one \emph{more often}}

%============ removed, as agreed that rb will not be included. =========================
%\paragraph{Reversal-bounded transducers.}    
%Let $(q_0, i_0, b_0),\ldots, (q_m, i_m, b_m) $ be a run of $\Transducer$ on some string $w$. A \emph{reversal} of the run is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ where the direction of the reading head is reversed. More precisely, it is a maximal subsequence $(q_j, i_j , b_j), \cdots, (q_{j'}, i_{j'}, b_{j'})$ satisfying one of the following constraints:
%\begin{itemize}
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}+1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}-1$,
%\item for each $j'': j  < j'' < j'$, $i_{j''} = i_{j''-1}$ or $i_{j''} = i_{j''-1}-1$, moreover, the latter situation occurs at least once, finally $i_{j'} = i_{j'-1}+1$. 
%\end{itemize}
%Let $k \in \Nat$. A run of $\Transducer$ is said to be \emph{$k$-reversal-bounded} if the run contains at most $k$ distinct reversals.
%A \FFT{} $\Transducer$ is \emph{$k$-reversal-bounded} if all runs of  $\Transducer$ are $k$-reversal-bounded.
%====================================================================================================

%Given a \FFT{} $T$, We use $\Transducer(x, y)$ to denote the relation such that there is an accepting run of $\Transducer$ on $x$ with the output $y$.
%\tl{I feel this is slightly confusing, let's whether we can avoid that}
%\mat{
%    I don't understand it (the sentence above).
%    Do you mean we write
%    $\Transducer(x, y)$
%    whenever 
%    $(x, y) \in \Tran(\Transducer)$?
%}
%Moreover, we also write $\Transducer(x, y)$ as $y = \Transducer(x)$.
%%, in order to facilitate the definition of straight-line fragments. 
%Nevertheless, the reader should remember that $y= \Transducer(x)$ does \emph{not} mean that $\Transducer$ defines a function.

% The set of words accepted by $\Aut$ is denoted by $\Lang(\Aut)$,
%a.k.a., the language \defn{recognised} by $\Aut$.
%Since we deal with computational complexity in the sequel, we define
%The \defn{size} $|\Aut|$ of $\Aut$ is defined to be $|\controls|$; this will
%be needed when we talk about computational complexity.


\OMIT{
Recently, Chen \emph{et al.} \cite{CCHLW18}  noted that some XSS vulnerability
analysis involving web templating systems (e.g. \texttt{Mustache.js}
\cite{Mustache}) requires the use of the replace-all 
\mat{replaceall or replace-all? -- i think both are used}
function that cannot be
captured by finite-state transducers in \cite{LB16}. Essentially, since the ``holes'' to be 
filled in by data from a separate JSON file might be an arbitrary string, the
replacement string in the replace-all function could in fact be a string
variable. \anthony{Define the replace-all function later}. The authors
showed that the path feasibility problem where the assignments $f$ use the
replace-all function and the conditionals $g$ use the regular constraints 
is still decidable (in fact, with the same complexity as in \cite{LB16} 
EXPSPACE), so long as the pattern variable in the replace-all function is a
regular expression (i.e. \emph{not} a variable). Interestingly, such a usage of
the replace-all function can even capture the concatenation operator, thereby
providing another decidable subclass of the path feasibility problem involving
the replace-all function, the concatenation operator, and regular constraints.
}


%involves: (i) instantiating 
 
\OMIT{
The basic ``straight-line'' framework from Lin \& Barcelo \cite{LB16} involves: (i) instantiating 
the string functions in program assignments by either concatenation of string
variables/constants or an application of a one-way finite-state transducer
to a string variable/constant, and (ii) instantiating conditionals by regular
constraints.

One-way and two-way transducers. Mention what kind of closure/algorithmic
results.
}

\OMIT{
\begin{definition}[Recognisable relation]
	Given a finite alphabet $\Sigma$, a $k$-ary relation $R\subseteq \Sigma^*\times \cdots\times \Sigma^*$ is \emph{recognisable}  if $R=\bigcup_{i=1}^n L^{(i)}_1\times \cdots\times L^{(i)}_k$ where $L^{(i)}_j$ a regular for each $j\in [k]$ .
%
%	[One can certainly generalise this to $n$-ary relations. ]
\end{definition}
}


\subsection{Parametric transducers}

We introduce parametric transducers, a transducer model that can 
capture a wide range of string functions (e.g., all of what have discussed so far). 

%all the aforementioned string operations, i.e. finite-state transducer \cite{LB16}, the concatenation function, the replace-all function \cite{CCHLW18}, and the string reverse function.

\begin{definition}[Parametric Transducers]
    Let $\ialphabet$ be an alphabet, and $X$ be a set of \emph{parameters}. 
    Assume that $\ialphabet \cap X = \emptyset$  and let $\oalphabet = \ialphabet \cup X$. 
    %Define $\oalphabet_\epsilon = \oalphabet \cup \{\epsilon\}$.
    A (nondeterministic) two-way \emph{parametric transducer} (\PPT)  $\Transducer$ over 
    $(\ialphabet,X)$ is a  \FFT{}  extended with  parameter outputs, more precisely, $\Transducer$ is a tuple 
    $(\ialphabet, X, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$, where
 $\transrel$ is a finite subset of $\controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \oalphabet^*$, satisfying the syntactical constraints of \FFT{}s.   
    A (nondeterministic one-way) parametric transducer (\PT) over
    $(\ialphabet,X)$ is a \PPT{} such that
 $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Stay, \Right\}\times 
    \controls \times \oalphabet^*$.   
%    A sweeping \PPT{} (\SPPT) is defined similarly to \SFFT. 
    %\zhilin{The output of 2PT is very general now, can be a string from $(\ialphabet \cup X)^*$}
\end{definition}

\OMIT{
\begin{definition}[Parametric Transducers]
    Let $\ialphabet$ an alphabet, and $X$ be a set of \emph{parameters}. 
    Assume that $\ialphabet \cap X = \emptyset$ and let $\oalphabet = 
    \ialphabet \cup X$. Define $\oalphabet_\epsilon = \oalphabet \cup
    \{\epsilon\}$.
    A (nondeterministic) two-way \emph{parametric transducer} (\PPT) over 
    $(\ialphabet,X)$ is a tuple $\Transducer =
(\ialphabet, X, \EndLeft, \EndRight, \controls, q_0, \finals, \transrel)$ where 
    $\controls$ is a finite set of 
    states, $\EndLeft$ (resp.~$\EndRight$) a left (resp.~right) input tape end 
    marker, $q_0\in \controls$ is
the initial state, $\finals\subseteq \controls$ is a set of final states, and 
    $\transrel$ is the
transition relation  $\transrel\subseteq \controls \times 
    \overline{\ialphabet}\times \{\Left, \Stay, \Right\}\times 
    \controls \times \oalphabet_\epsilon$ with
    $\overline{\ialphabet} := \ialphabet \cup \{\EndLeft,\EndRight\}$.
    Here, we assume $\EndLeft, \EndRight \notin \ialphabet$, and that
    there are no transitions that take the head of the tape past the left/right
    end marker. 
    A (nondeterministic one-way) parametric transducer (\PT) over
    $\ialphabet$
    is a \PPT{} whose transition relation contains only tuples of the form
    $(p,a,dir,q,b)$, where $dir \in \{\Stay,\Right\}$.
\end{definition}
}
\OMIT{
    The usual notion of finite transducers can now be defined as parametric 
    transducers that do not output parameters.
\begin{definition}
    A (nondeterministic) two-way \defn{finite transducer} (\FFT) is a \PPT{} 
    over
    $(\ialphabet,X)$, where $X = \emptyset$. Similarly, a (nondeterministic
    one-way finite) transducer (\FT) is defined in the similar way but with
    a \PT{} instead of \PPT{}.
\end{definition}
}

Notice that parameters are only allowed in the output tape.
Intuitively, each instantiation of the parameters $x_1,\ldots,x_\arity$ with strings 
$w_1,\ldots, w_\arity \in \ialphabet^*$ in a \PPT{} $\Transducer$ gives rise to a \FFT{} which is obtained from $\Transducer$ by replacing each occurrence of $x_j$ in transitions with $w_j$.
%
We will use $\Transducer[w_1/x_1,\ldots,w_\arity/x_\arity]$ to denote the \FFT{} resulting from the instantiation,
%=======
%We will use $\Transducer[w_1/x_1,\ldots,w_\arity/x_\arity]$ to denote the \FFT{} resulting from the instantiation.\footnote{The instantiation of the parameters is only done 
	%\emph{once} before the parametric transducer is run. Because of this, parameteric transducers cannot in general be captured by the non-parametric transducers that nondeterministically ``guess''
	%the parameters separately for each transition.}  
%>>>>>>> 7429533e25607629e2cd9d233fad7e75914bde4d
%More formally, let 
%$\Transducer[w_1/x_1,\ldots,w_m/x_m]$ denote the (non-parametric) \FFT{} obtained from $\Transducer$ by replacing every occurrence of each
%parameter $x_i$ in $\Transducer$ by the string $w_i$.
%
and $\Tran(\Transducer)$ to denote the set of string tuples 
$(w, w_1, \ldots, w_\arity, w')$ such that 
$(w,w') \in \Tran(\Transducer[w_1/x_1,\ldots,w_\arity/x_\arity])$.
%
%, i.e., when
%$x_1,\cdots, x_m$ are instantiated with strings $w_1,\ldots, w_\arity$, 
%$\Transducer$ produces the output $w'$ from the input $w$. 
Similarly to \FT{}s, we also omit $\EndLeft, \EndRight$ in \PT{}s, that is, $\transrel \subseteq \controls \times 
\ialphabet \times \{\Stay, \Right\} \times \controls \times \oalphabet^*$.


%\tl{maybe emphasise that this is a  ``off-line" rather than on-line  instantiation?}

%We use $z = \Transducer(x, \vec{y})$ to denote the fact that there is an accepting run of $\Transducer$ on $x$, equipped with the parameters $\vec{y}$, producing an output $z$.
%\tl{again, this is a relation, not a function.}

\begin{example} \label{example:2pt}
 The concatenation operation $x \cdot y$ can be simulated by a \PT{} that takes $x$ as the input, output each letter it reads, and output the parameter $y$ in the right end. Specifically, the \PT{} has two states $q_0, q_1$, transitions $(q_0, \ell, 1, q_0, \ell)$ and $(q_0, \ell, 1, q_1, \ell \cdot y)$ for each $\ell \in \ialphabet$,  initial state $q_0$, and final state $q_1$. (Notice that the head of the \PT{} must stop in the right end of the tape to accept.) 
 
  As promised in the Introduction, we now demonstrate how the  $\replaceall$ function from \cite{CCHLW18} can be simulated by \PT{}s.
  %\tl{the replaceall example is much shortened as they already are mentioned in the intro.} 
%  Intuitively,  
%    the function $\replaceall$ takes three inputs:
%    (1) a string $sub$, called the \emph{subject}, (2) a regular expression
%    $pat$, called the \emph{pattern}, and (3) a string $rep$, called
%    the \emph{replacement string}. The output of the function is
%    the string obtained from $sub$ by replacing every occurrence of $pat$ 
%    by $rep$. We refer to \cite{CCHLW18} for the details of the  $\replaceall$ function, especially the semantics of \emph{leftmost and longest matching} of the pattern. 
   % 
%    To resolve ambiguity, we use the semantics of \emph{leftmost
%    and longest matching} that is used by languages such as Python and sed (with the
%    \texttt{--posix} flag): if we parse $sub$ from left to right, as soon as 
%    $pat$ is detected as the leftmost and longest matching after the previous matching, it will be replaced by $rep$. For example, the
%    output of $\replaceall(\texttt{aabaa},\texttt{a}^+,\texttt{b})$ is
%    \texttt{bbb}.
%    %, not \texttt{aba}.
%
    %For a regular expression $p$, let 
 Recall $\replaceall_{p}(sub, rep)$ where $p$ is a fixed regular expression. %be the $\replaceall$ function with the fixed pattern $p$,
    %i.e., it only has two inputs: $sub$ and $rep$. 
    %
    In case that $p$ is  a single letter \texttt{a}, the transducer for $\replaceall_{p}$ has one state $q_0$ as both the initial and the final state,
    %$q_0$, $q_1$, $q_F$, 
    and transitions 
    %$(q_0,\EndLeft,1,q_1,\epsilon)$,
    $(q_0,\ell, 1, q_0, \ell)$ for each $\ell \in \ialphabet \backslash
    \{\texttt{a}\}$, 
    and $(q_0, \texttt{a}, 1, q_0, rep)$. For the more general case, to resolve ambiguity, \cite{CCHLW18} uses the semantics of \emph{leftmost and longest matching} that is used by languages such as Python and sed (with the  \texttt{--posix} flag).
%    	   : if we parse $sub$ from left to right, as soon as 
%    	    $pat$ is detected as the leftmost and longest matching after the previous matching, it will be replaced by $rep$. For example, the
%    	    output of $\replaceall(\texttt{aabaa},\texttt{a}^+,\texttt{b})$ is
%    	    \texttt{bbb}.
%    	    %, not \texttt{aba}.
     We refer to \cite{CCHLW18} for the details. When this semantics is adopted, we can construct the \PPT{} for $\replaceall_{p}$, which can be found in Appendix~\ref{appendix:replace2pt}.     \qed
%    
%    
%    We can express
%    $\replaceall_{p}$ by a \PT{} with $sub$ on the input
%    tape and $rep$ as a parameter. We will show this for the case when $w$ is 
%    a single letter \texttt{a}; this can be easily extended to the general case 
%    (see the proof of Proposition \ref{prop:replaceAll} in the 
%    \shortlong{full version}{appendix}). The transducer has one state $q_0$ as both the initial and the final state,
%    %$q_0$, $q_1$, $q_F$, 
%    and transitions 
%    %$(q_0,\EndLeft,1,q_1,\epsilon)$,
%    $(q_0,\ell, 1, q_0, \ell)$ for each $\ell \in \ialphabet \backslash
%    \{\texttt{a}\}$, 
%    and $(q_0, \texttt{a}, 1, q_0, rep)$.
%    %, and $(q_1, \EndRight,0,q_F,\epsilon)$. 
%

%    The transducer uses the parameter $rep$. Whenever the replacement
%    is a constant string, a (non-parametric) \FT{} is sufficient to
%    capture the function; cf. \cite{LB16}. 
    

\end{example}

%The general $\replaceall$ function (see \cite{CCHLW18}) actually admits 
%a regular expression pattern $p$. In this case, we can use the leftmost
%and \emph{longest} matching semantics, which is also used by languages such as
%Python and sed. Such a function can also be captured by parametric transducers,
%as the following proposition claims.
%
%\begin{proposition}\label{prop-replace-pt}
%    Given a regular expression pattern $p$, we can compute a 
%    \PT{} $\Transducer$ such that $\Tran(\Transducer)$ expresses the function $\replaceall_p$.
%    \label{prop:replaceAll}
%\end{proposition}

%Give examples: htmlescape, replace-all, and reverse.

%Give example of computing reverse of DNA string.

\OMIT{
\subsection{The constraint language}

\mat{
    Can i propose we replace the constraint language with straight-line programs?
    Then we can get rid of the dependency graph and edges.
    Instead we just say that variables are assigned at most once (input variables are not assigned), and any variable appearing in the $i$th statement is an input or was assigned in the $j$th statement for some $j < i$.
    The generic algorithm then always picks the last assignment to eliminate, instead of some variable with no predecessors in the dependency graph.
    The former is easy to picture and recall, the latter requires absorbing the definition of dependency graph, remembering which direction the edges go, and realising that a variable with no predecessors is a statement with no functions/transductions that use it.
    We can note the connection to the constraint language defined below if we want to.
}

For a class $\transet$ of parametric transducers, we consider the constraint language $\straightline[\transet]$ which comprises a formulae of the form $\varphi \wedge \psi$ such that $\varphi,\psi$ are defined by the rules,
\[
\begin{array}{l l l r}
\varphi &::=& z = \Transducer(x, \vec{y}) \mid \varphi \wedge \varphi, &  \hfill  \mbox{(relational constraint) } \\ 
\psi &::= & x \in \Aut \mid \psi \wedge \psi, & \hfill \mbox{(regular constraint)} 
\end{array}
\]
where $\Transducer$ is a transducer from $\transet$ over the alphabet $\Sigma$ and $\Aut$ is an \FA{} over $\Sigma$. Moreover, we require that the dependency graph of $\varphi$ defined below is acyclic. We use $\vars(\varphi \wedge \psi)$ to denote the set of string variables occurring in $\varphi \wedge \psi$.

%Let $\varphi$ be a relational constraint. Then 
The \emph{dependency graph} of a relational constraint $\varphi$, denoted by $\cG(\varphi)$, is the (directed acyclic) graph comprising the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ for $i\in [k]$ and  each atomic formula $z = \Transducer(x, \vec{y})$ in $\varphi$ with $\vec{y}=(y_1, \cdots, y_k)$. Note that $(\Transducer, 0)$ and $(\Transducer, i)$ are the labels of the edges $(z, (\Transducer, 0), x)$ and $(z, (\Transducer, i), y_i)$ respectively.

Let $\varphi$ be a relational constraint. We use $\rcdim(\varphi)$ to denote the \emph{dimension} of $\varphi$, which is defined as the maximum number of parameters of the transducers occurring in $\varphi$. Moreover, we use $\rcdep(\varphi)$ to denote the \emph{depth} of $\varphi$, which is defined as the maximum length (i.e., number of edges) of the paths in $\cG(\varphi)$.
 
We mainly consider that $\transet$ is 2PT or 1PT in this paper. 
%\tl{I am not sure about the plan, but here maybe it is worth mentioning that concatenation can be treated as 1PT. Moreover, do we consider 2T as well? in this case, concatenation cannot be encoded.} 
%Similarly, we can define $\straightline[\owpt]$.
}

\input{auto-sanitisation}
