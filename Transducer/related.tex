\section{Related Work}
\label{sec:related}

\subsubsection*{Decidability results.}
\emph{Length constraints} --- i.e. an assertion of the form 
$\varphi(\Len(x_1),\ldots,\Len(x_n))$, where $\varphi$ is a Presburger formula
and $\Len(x_i)$ is an integer variable interpreted as the length of the string
$x_i$ --- have also been studied in the context of string solving. It is
currently a major open problem whether the theory of concatenation with length
constraints is decidable \cite{Vijay-length}. Several extensions of this 
theory is known to be undecidable (e.g. with letter counting \cite{buchi} and
string-number conversion \cite{GB16}).
Several decidable restrictions, however,
have been proposed including solved form \cite{Vijay-length} and acyclicity 
\cite{Abdulla14}, both of which (like straight-line constraints) impose 
syntactic restrictions on the way in which string equality/disequality can be
used in the constraints. It was shown in \cite{LB16} the decidability of path 
feasibility for symbolic
executions allowing finite-state transduction and concatenation in the 
assignments, and regular constraints, length constraints, and string disequality
in the assertions. Unfortunately, if we allow the functions
$\replaceall_p(sub,rep)$ in the assignments (instead of
finite transducer/concatenation) and length constraints as assertions, path
feasibility becomes undecidable \cite{CCHLW18}. This also implies undecidability
of allowing length constraints in our constraint language with parametric
transducers. Fortunately, decidability can be easily recovered in at least two
cases. The first case is when the length constraints $\varphi$ has only
one string variable $x_1$, e.g., $\Len(x_1) > 7$. In this case,
$\varphi(\Len(x_1))$ can be turned into a regular constraint $x_1 \in L$ for
some $L$. [This is because the set of integer solutions is effectively
a finite union of arithmetic progressions $\bigcup_{i=1}^n (a_i + b_i\N)$
(where $a_i + b_i\N := \{ a_i + b_in : n \in \N\}$), and each 
$\Len(x_i) \in (a_i + b_i\N)$ is equivalent to the regular constraint 
$x_i \in \ialphabet^{a_i} (\ialphabet^{b_i})^*$.] The second case is when
the length constraints only relate input variables. In this case, running
our algorithm on the constraint (with length constraints ignored)
results in a conjunction of regular constraints on the input variables. Each
regular constraint $x \in L$ on an input variable $x$ yields a length
constraint $L_x$ on $x$ of the form a finite union of arithmetic progressions 
\cite{Kozen-automata}. We collect all the length constraints in a big
conjunction and run a solver for integer linear arithmetic.
%\cite{Vijay-length}, acyclicity \cite{Abdulla14,BFL13}, and straight-line
%\cite{LB16}) 
%on the shape of string constraints. 

The complexity of the theory of concatenation with regular constraints is
known to be PSPACE-complete \cite{Plandowski,J17}, although the exact
complexity for the theory of concatenation \emph{without} regular constraints is
a long-standing open problem (only known to be in between NP and PSPACE). 
The complexity of the straight-line logic with concatenation, finite
transducers, and regular constraints is EXPSPACE-complete \cite{LB16}. The same 
complexity holds when we swap finite transducers with replaceall 
\cite{CCHLW18}. Our logic with reversal-bounded parameterised transducers
as primitive operations strictly subsumes these two logics (e.g. since it can
also express string reverse) and has precisely the same complexity EXPSPACE.
The straight-line logic of \cite{LB16} extended with length constraints is still
EXPSPACE-complete.

In this paper, we have combined two powerful formalisms 
(two-way finite transducers and replaceall) into a single formalism. Since we 
are considering
only two-way transducers that define functions, they are equivalent to 
two-way deterministic finite transducers, streaming transducers, and
transductions that are definable in Monadic Second-Order Logic
\cite{EH01,AC10,AD11}. On the other hand, one-way transducers that define 
functions are strictly more expressive than deterministic one-way transducers
\cite{Berstel}. In either case, it makes sense to consider nondeterministic
transducers for a succinctness reason. %For future work, it 
It is also interesting to note that checking whether a \FFT{} defines a function
is decidable \cite{CK87} (in fact, in polynomial-time for \FT{} \cite{GI83}),
which implies decidability as well for \PPT{}.
%to consider 
%In this case, path feasibility of a
%symbolic execution $S$
%is defined in an \emph{angelic} way: each function in $S$
%should be able to produce \emph{some} output string that takes $S$ to the end of the
%program.
\OMIT{
Note that the generic decision procedure in the proof of
Theorem \ref{th:gen} still works when we admit relations, and the regularity
conditions for \PPT{} and \PT{} are still satisfied whether or not they define
functions. Therefore, our generic decision procedures would extend to ,
albeit with a worse complexity. 
}


Symbolic automata/transducers were introduced by Veanes \emph{et al.}
\cite{symbolic-transducer,symbolic-transducer-power}. \anthony{Say more}

%array theory? They can't concatenate and we can't do $a[i] = b[i]$.



\subsubsection*{Heuristics and implementation.}
There is a large amount of work on heuristics for developing fast practical
string solvers, e.g., 
\cite{BTV09,Berkeley-JavaScript,HAMPI,Stranger,YABI14,Abdulla14,fang-yu-circuits,Abdulla17,HJLRV18,S3,TCJ16,Z3-str,Z3-str2,cvc4,Saner,RVG12},
among many others. 
Recursively defined functions. 

\subsubsection*{Benchmarking examples.}
