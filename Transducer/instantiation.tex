%!TEX root = main.tex

\section{Instantiations of the generic decision procedure}
 
\subsection{Two-way transducers}\label{sec-2way}

%Let $\Transducer$ be a 2NPT with $k$ parameters $y_1,\cdots, y_k$ and $\Aut$ be an NFA. Then the \emph{preimage} of $\Aut$ w.r.t. $\Transducer$, denoted by $\Pre_\Transducer(\Aut)$, is the set of tuples $(w, w_1,\cdots, w_k)$ such that there is an accepting run of $\Transducer$ on $w$ producing an output $w' \in \Lang(\Aut)$, equipped with the parameters $w_1,\cdots, w_k$.


\begin{lemma}\label{lem-2pt}
Let $\Transducer$ be a 2NPT and $\Aut$ be a conjunctive NFA $\Aut$. Then $\Pre_\Transducer(\Aut)$ is a recognisable relation. Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $2^{O(|\Transducer||\Aut|\log (|\Transducer||\Aut|))}$, can be computed effectively.
\end{lemma}

\begin{proof}
Assume a 2NPT $\Transducer=(X, Q, q_0, F, \delta)$ with $X = \{x_1,\cdots, x_k\}$ and a conjunctive NFA $\Aut = ((Q', \delta'), S)$ with $S \subseteq Q' \times Q'$. %We first introduce some notations.

To compute $\Pre_\Transducer(\Aut)$, we introduce an NFA $\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$, %defined as follows. 
%and $\Aut[S]$ defined below.
%
where  $q \in F$, and  $S_{x_1}, \cdots, S_{x_k} \subseteq Q' \times Q'$.   
$\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$ is constructed from $\Transducer$  by checking that there is an accepting run of $T$ on $w$, ending at the state $q$, and simulating an accepting run of $\Aut$ on the output of $\Transducer$. In particular, when the a transition of $\Transducer$ outputs $x_i$ (instead of a single letter), a pair of states $(q_1', q_2')$ will be nondeterministically selected from $S_{x_i}$, and the component of the state of $\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$ corresponding to $\Aut_1$ will be updated from $q_1'$ to $q_2'$ to mimic a possible instantiation of $x_i$.  

%\tl{zhilin, I am not quite clear about the para, $y_1$ is a typo of $x_1$? I wrote a para above; please check}
%(instead of materialising the output), where $S_{x_1}$ is used to jump over $y_1$ when $x_1$ is the output of a transition of $\Transducer$, similarly for $S_{x_2}, \cdots, S_{x_k}$. 


More precisely, $\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$ is computed in two steps:
\begin{enumerate} 
\item Construct a conjunctive 2NFA $\Aut'' = ((Q'', \delta''), S'')$, where $Q'' = Q \times Q'$, $S'' = \{((q_0, p), (q, p')) \mid (p, p') \in S\}$, and $\delta''$ comprises the tuples $((q_1, q'_1), a, dir, (q_2, q'_2))$ such that either there is $b \in \Sigma$ satisfying that $(q_1, a, dir, q_2, b) \in \delta$ and $(q'_1, b, q'_2) \in \delta'$, or there is $x_i \in X$ satisfying that $(q_1, a, dir, q_2, x_i) \in \delta$  and $(q'_1, q'_2) \in S_{x_i}$.
%
\item Transform $\Aut''$ into an equivalent conjunctive NFA $((Q''',\delta'''), S''')$, where $Q'''$ are vectors of mutually distinct states of $\Aut''$ (cf. Proposition~\ref{prop-2nfa-nfa}),  and $S' = \{(\vec{\rho}_1, \vec{\rho}_2) \mid  (p, p') \in S, \vec{\rho}_1[1] =(q_0, p), \vec{\rho}_2[|\vec{\rho}_2|] = (q, p') \}$.
%
%\item Define $\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$ as $((Q''', \delta'''), S')$, where $S' = \{(\vec{\rho}_1, \vec{\rho}_2) \mid  (q'_1,q'_2) \in S, \vec{\rho}_1[1] =(q_0,q'_1), \vec{\rho}_2[|\vec{\rho}_2|] = (q, q'_2) \}$.
\end{enumerate} 
It is easy to see that  the size of $\cB_{\Transducer, \Aut, S_{x_1}, \cdots, S_{x_k}, q}$ is at most 
$2^{O(|T||\Aut| \log(|T||\Aut|))}$.   

%For $S \subseteq Q' \times Q'$, let $\Aut[S]$ denote the product of $\Aut(q'_1, \{q'_2\})$ for $(q'_1,q'_2) \in S$ (cf. Section~\ref{sec:prelim}, {Operations of NFAs.}). Since $S$ contains at most $|Q'|^2=|\Aut|^2$ many elements, the size of $\Aut[S]$ is bounded by $|\Aut|^{|\Aut|^2} \approx 2^{O(|\Aut|^2 \log |\Aut|)}$.


\paragraph{Claim.} %For each tuple of strings $(w, w_1,\cdots, w_k)$, 
$(w, w_1,\cdots, w_k) \in \Pre_\Transducer(\Aut)$ iff there are $S_{x_1}, \cdots, S_{x_k} \subseteq Q' \times Q'$ and $q \in F$ such that $w \in \Lang(\cB_{\Transducer, S_{x_1}, \cdots, S_{x_k}, q})$ and $w_i \in \Lang(\Aut[S_{x_i}])$ for each $i \in [k]$, where $\Aut[S_{x_i}]=((Q', \delta'), S_{x_i})$.

\medskip


Therefore, $\Pre_\Transducer(\Aut)$ is equal to 
\[
\bigcup_{S_{x_1}, \cdots, S_{x_k} \subseteq Q' \times Q', q\in F} \Lang(\cB_{\Transducer, S_{x_1}, \cdots, S_{x_k},q}) \times \Lang(\Aut[S_{x_1}]) \times \cdots  \times \Lang(\Aut[S_{x_k}])\]
 


We conclude that $\Pre_\Transducer(\Aut)$ is a recognisable relation and a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $2^{O(|\Transducer||\Aut|\log (|\Transducer||\Aut|))}$, can be constructed effectively.
\end{proof}

From Lemma~\ref{lem-2pt} and Theorem~\ref{thm-generic-dec}, by some simple calculation, we deduce that the satisfiability of an $\straightline[\twpt]$ formula $\varphi \wedge \psi$ can be decided in 
%nondeterministic 
%$$O((\rcdim(\varphi)+2)^{\rcdep(\varphi)} (f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))^2 \log f^{\langle \rcdep(\varphi) \rangle}(|\varphi|, |\psi|))$$ 
%space, where $f(j, k) = 2^{jk \log (j k)}$. 
nondeterministic $\tower(\rcdep(\varphi), O(|\varphi| |\psi| \log(|\varphi| |\psi|) ))$ space, thus in (deterministic) $\tower(\rcdep(\varphi), O(|\varphi| |\psi| \log(|\varphi| |\psi|) ))$ space, according to Savitch's theorem \cite{Savitch70}. Here the function $\tower(j, k)$ is %a tower of $2$s of height $j$ with $k$ on top, formally, 
defined as: $\tower(1, k)= 2^k$ and $\tower(j+1, k) = 2^{\tower(j, k)}$. We conclude that the satisfiability of $\straightline[\twpt]$ formula $\varphi \wedge \psi$ can be decided in $\rcdep(\varphi)$-exponential space.
Moreover, we have a matching lower bound for the satisfiability of $\straightline[\twpt]$.
%
\begin{theorem}
Given an $\straightline[\twpt]$ formula $\varphi \wedge \psi$, its satisfiability can be decided in $\rcdep(\varphi)$-exponential space. Moreover,  for any $\expheight$, one can construct an  $\straightline[\twpt]$ formula $\varphi \wedge \psi$ such that deciding the satisfiability of $\varphi \wedge \psi$  %$\straightline[\twpt]$ 
is $\expheight$-$\expspace$-hard.
\end{theorem}

The lower bound is proved as follows. \zhilin{@Matt, could you help put your lower bound proof here ?}

%The complexity bound is tight ...

\paragraph{Lower-bound.}

We give a matching lower bound for the satisfiability problem for $\strline[2NPT]$. 
In particular, we show the problem is non-elementary.
More specifically, we show that, for any $\expheight$, the problem is $\expheight$-EXPSPACE-hard with $(\expheight+1)$ transducers. 
More precisely, we provide a  reduction from a tiling problem that is hard for $\expheight$-EXPSPACE.
The reduction relies on the ability to manipulate large numbers that will be used to index the tiles in a solution to the tiling problem.
Similar encodings appear in the study of higher-order programs (e.g.~\cite{J01,CW07}) except the machinery needed to enforce the encoding is quite different.

The complete encoding is given in 
\shortlong{the full version of this article}
          {Appendix~\ref{sec:two-way-lower}}.
We give an overview of the intuition here.

A \emph{tiling problem} consists of a finite set of tiles \tiles as well as horizontal and vertical tiling relations 
$\hrel, \vrel \subseteq \tiles \times \tiles$.
Furthermore, given a tiling \emph{corridor} of a certain width, as well as initial and final tiles
$\inittile, \fintile \in \tiles$
the task is to find a tiling where 
\begin{itemize}
\item
    the first tile of the first row of the corridor is $\inittile$, 
\item
    if $\tile_1$ appears directly to the left of $\tile_2$ in a row, we must have
    $\tup{\tile_1, \tile_2} \in \hrel$,
\item
    if $\tile_1$ appears in the row above $\tile_2$ in the same column, we must have
    $\tup{\tile_1, \tile_2} \in \vrel$,
\item
    each row must have a tile in each column position (up to the column width),
\item
    the last position of the last row must contain $\fintile$.
\end{itemize}
Tiling problems are intimately connected to computations of Turing machines 
(each row can be considered to be the tape contents in one configuration of a run).
Thus, tiling problems where the corridor is of a given width are equivalent to Turing machines with space equal to the width.

The existence of a solution to a tiling problem of width $n$ can be reduced to emptiness of a 2NFA of size 
$\ap{\bigoh}{n}$.
A solution to a tiling problem will be encoded as a word 
$t_{1,1} t_{1,2} \cdots t_{1,n} \numsep \cdots \numsep t_{m,1} t_{m,2} \cdots t_{m,n}$
where each row
$t_{i,1} t_{i,2} \cdots t_{i,n}$
is separated from the next row by $\numsep$.
The 2NFA performs $n+1$ passes.
During the first pass it checks that the tiling begins with $\inittile$, ends with $\fintile$ and we have 
$\tup{t_{i,j}, t_{i,j+1}} \in \hrel$
for all
$1 \leq j < n$.
If the encoding passes this check, we need to verify that the vertical tiling relation $\vrel$ is met.
This is done in $n$ more passes, the $j$th of which verifies the $j$th column of the encoding.
The $j$th tile of a row is stored into the state of the 2NFA, it counts $n+1$ characters to reach the $j$th tile of the next row, then compares the two tiles with respect to $\vrel$.
The previous tile is then forgotten, the new stored in the state, and the check moves to the next row until the end of the word is reached.

We want to show that a tiling problem of $n$-fold exponential width can be reduced to a constraint problem with $n$ 2T and a single 2NFA.
We begin with a single 2T and a tiling problem of exponential width.
A single 2NFA will no longer suffice since, while checking the columns, it cannot count an exponential number of positions to find the next tile in the column without an exponential number of states.
We use a 2T in conjunction with a 2NFA and a more involved encoding to address this issue.

Intuitively, a row of the solution to a tiling problem could now be encoded as follows, with a sequence of $n$ binary bits preceding each tile.
These bits appear in order and count from $0\ldots00$ to $1\ldots11$ and give an exponential width.
That is
\[
    0\ldots00\ \tile_{1,1}\ %
    0\ldots01\ \tile_{1,2}\ %
    \cdots
    1\ldots11\ \tile_{1,2^n}\ %
    \numsep
    \cdots
    \numsep
    0\ldots00\ \tile_{m,1}\ %
    0\ldots01\ \tile_{m,2}\ %
    \cdots
    1\ldots11\ \tile_{m,2^n} \ .
\]
Note, we do not need to enforce the height of the corridor, since this is not a requirement of the tiling problem.
However, just as it is possible to define a Turing machine that counts in its tape from $0\ldots00$ to $1\ldots11$ for any arbitrary length bit sequence, it is possible to define tiling problems whose only solutions have height exponential in the width of the corridor.
In fact, in the formal encoding, we will not use binary numbers, but instead use tiling problems whose solutions must have exponential height.
This is more convenient than a binary number encoding because vertical and horizontal tiling relations are easier to encode than the logic required to increment binary numbers.
For the purposes of the intuitive exposition, we will use binary numbers as the intention is clearer.

Given such an encoding, the 2T checks the solution to the tiling problem in a manner similar to the 2NFA when a corridor of width $n$ was needed.
That is, on the first pass, the horizontal relation is checked (as well as the initial and final tiles), and on subsequence passes each column is checked against $\vrel$.

To cope with the large corridor width, the 2T will output ``queries'' to the 2NFA.
To be more precise the 2T will output a sequence of n-bit sequences separated by either
$\numeq$ or $\numplus$.
The 2NFA will accept
$b_1 \ldots b_n \numeq b'_1 \ldots b'_n$
if
$b_1 \ldots b_n = b'_1 \ldots b'_n$
(i.e.~the sequences are the same).
Similarly
$b_1 \ldots b_n \numplus b'_1 \ldots b'_n$
will be accepted if 
$b'_1 \ldots b'_n$
encodes the successor ($+1$) of
$b_1 \ldots b_n$.
A 2NFA can check these properties in $n$ passes: one for each bit position.

Thus, during the first pass of the 2T, it checks, in addition to $\hrel$, that the tile positions are always correctly numbered from $0\ldots00$ to $1\ldots11$.
It does this by outputting each sequence of bits it reads, separated by $\numplus$.
When it reaches the end of a row it outputs $\numsep$ to indicate the end of the sequence.
The 2NFA can then check that each series of numbers increment from $0\ldots00$ to $1\ldots11$.

Subsequent passes of the 2T check each column of the output.
Since it is not possible without an exponential number of states to check each column in turn in a controlled way, the 2T again relies on the 2NFA to perform some checks.
The 2T non-deterministically selects a tile in the current row, outputs the bit sequence marking its position and then non-deterministically selects a tile in the next row, again outputting the preceding bit sequence.
Between these bit sequences it outputs a $\numeq$ symbol.
It continues in this way until the end of the pass, simultaneously checking that the guessed tiles satisfy $\vrel$.
The 2NFA will check that each sequence of bits is the same, which will enforce that the 2T checked the same column in every row.
The 2NFA will then start another pass to check the next column in the encoding.
It will output $\numplus$ before outputting the bit sequences associated with the pass over the next column.
Using the 2NFA we ensure that the 2T (non-deterministically) passes over each column in turn, starting from the $0\ldots00$th column and finishing in the $1\ldots11$th.

If the 2T manages to produce a word that is accepted by the 2NFA, we know that there is a solution to the tiling problem over an exponentially wide corridor.

To increase the corridor width by another exponential, we need another 2T.
To reach doubly-exponentially large numbers, we need to precede each tile with a binary sequence of exponential length.
To ensure that the bit sequences are exponentially long, we need to precede each bit with another binary sequence, this time of length $n$.
Thus, we have two sets of binary digits $0,1$ and $0', 1'$, and, if $n = 2$ a row would take the following form
\[
    \begin{array}{c}
        (0'0') 0 (0'1') 0 (1'0') 0 (1'1') 0\ \tile_1 \\
        (0'0') 0 (0'1') 0 (1'0') 0 (1'1') 1\ \tile_2 \\
        \cdots \\
        (0'0') 1 (0'1') 1 (1'0') 1 (1'1') 1\ \tile_{16} \\
    \end{array}
\]
where parenthesis are shown for clarity only.
We can check that a solution to a tiling problem with doubly-exponential width corridor encoded in such a way is indeed a solution using two 2Ts and a 2NFA.
The first 2T checks the horizontal and vertical tilings as before, outputting the bit sequences preceding the tiles.
To perform the required equality ($\numeq$) and plus one ($\numplus$) checks on this output, the second 2T is essentially checking horizontal and vertical constraints of another tiling problem over a width $n$ corridor
(recall, in the formal reduction we use tiling problems in place of binary numbers).
For this, it checks the required constraints and outputs in the process another series of bit sequences (this time of width $n$) separated by $\numeq$ and $\numplus$ (and $\numsep$).
Finally, the 2NFA checks that these sequences are indeed correct.

This process can be iterated.
That is, using $m$ 2Ts and a 2NFA, we can search for a solution of a tiling problem over an $m$-fold exponentially wide corridor.



%======================================================================================================

\subsection{One-way transducers}


\begin{lemma}\label{lem-1pt}
Let $\Transducer$ be a 1PT and $\Aut$ be a conjunctive NFA. Then $\Pre_\Transducer(\Aut)$ is a recognisable relation. Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $|\Transducer||\Aut|$, can be computed effectively.
\end{lemma}

Lemma~\ref{lem-1pt} can be proved in the same way as Lemma~\ref{lem-2pt}. The only difference is that the construction of $\cB_{\Transducer, \Aut, S_{x_1}, \ldots, S_{x_k}, q}$ is simpler and its size is at most $|\Transducer| |\Aut|$, since the transformation from  2NFA to NFA is not needed.

From Lemma~\ref{lem-1pt} and Theorem~\ref{thm-generic-dec}, we deduce the following result.
%
\begin{theorem} \label{thm-1pt}
%Given an $\straightline[\owpt]$ formula $\varphi \wedge \psi$, 
The satisfiability problem of $\straightline[\owpt]$ is $\expspace$-complete. 
\end{theorem}

The lower bound in Theorem~\ref{thm-1pt} is deduced from the result in \cite{LB16} that the satisfiability of straight-line string constraints with concatenation and one-way transducers, which are both captured by 1PT, is $\expspace$-complete.

\subsection{Reversal-bounded two-way transducers}

Let $k \in \Nat$. A 2PT $\Transducer$ is said  to be $k$-reversal bounded if in every run of $\Transducer$ on input strings, the reading head is reversed for at most $k$ times. We use  RB2PT$_k$ to denote the class of $k$-reversal bounded 2PTs. The reverse function can be captured by a reversal $1$-bounded 2PT.
Note that the class of $0$-reversal bounded 2PTs is precisely the class of 1PTs.

\begin{lemma}\label{lem-rb-2pt}
Let $k \in \Nat$, $\Transducer$ be a RB2PT$_k$, and $\Aut$ be a conjunctive NFA. Then $\Pre_\Transducer(\Aut)$ is a recognisable relation. Moreover, a representation of $\Pre_\Transducer(\Aut)$, whose atom size is bounded by $(|\Transducer||\Aut|)^k$ \tl{k+1?}, can be computed effectively.
\end{lemma}

The proof of Lemma~\ref{lem-rb-2pt} is the same as Lemma~\ref{lem-2pt}. The only difference is that the size of $\cB_{\Transducer, \Aut, S_{x_1}, \ldots, S_{x_k}, q}$ is at most $(|\Transducer| |\Aut|)^k$, since $\Transducer$ is reversal $k$-bounded.

From Lemma~\ref{lem-rb-2pt} and Theorem~\ref{thm-generic-dec}, we deduce the following result.
%
\begin{theorem} \label{thm-rb-2pt}
%Given an $\straightline[\owpt]$ formula $\varphi \wedge \psi$, 
For each constant $k \in \Nat$, the satisfiability problem of $\straightline[\rbtwpt_k]$ is $\expspace$-complete. 
\end{theorem}
\tl{I add constant as this is a parameterised complexity result}

The $\expspace$-hardness in Theorem~\ref{thm-rb-2pt} follows from Theorem~\ref{thm-1pt}.

%\input{expspace-hardness.tex}

%To show the above result, we will give a constraint that represents a straight-line program which ``transforms'' an automaton into exponentially many different automata.
%These exponentially many automata will be used to check the vertical tiling relation for a tiling problem with an exponentially wide corridor.
%Since such tiling problems are EXPSPACE-hard, the result follows.

%\begin{theorem}\label{thm-1pt}
%	Satisfiability of $\strline[1PT]$, even in the single-letter case, is EXPSPACE-hard.
%\end{theorem}


%
%\subsection{reversal-bounded transducers ?}
%
%\tl{include two-way non-parametric as well?}
