%!TEX root = popl2018.tex

\section{Undecidable extensions}

In this section, we extend the language $\strline[\concat,\replaceall]$ with integer and character constraints. The language will use variables of, in additional to the type $\str$, the Integer data type $\intnum$. The type $\str$ consists of the string variables as in the previous sections. A variable of type $\intnum$, usually referred to as \emph{integer variables}, ranges over the set $\mathbb{N}$ of all natural numbers. Recall that, in previous sections, we have used $x, y, z, \cdots$ to denote the variables of $\str$ type.  Hereafter we typically use $\mathfrak{l}, \mathfrak{m}, \mathfrak{n}, \cdots$ to denote the variables of $\intnum$. s. The
choice of omitting negative integers is only for simplicity, but our
results easily extend to the case when $\intnum$ includes negative integers.

We start by defining integer constraints, which expresses length or number of occurrences of symbols in words. 


\begin{definition}[Integer constraints] \label{def:intconst} 
	An atomic integer constraints over $\Sigma$ is an expression of the form
	\[a_1t_1+\cdots+a_nt_n\leq d\]
where $a_1, \cdots, a_n,d\in \mathbb{Z}$ are constant integers (represented in binary), and each \emph{term} $t_i$ is either 
	\begin{enumerate}
		\item an integer variable $\mathfrak{n}$;
		\item $|x|$ where $x$ is a  string variable; or 
		\item $|x|_a$ where $x$ is string variable and $a\in \Sigma$ is a constant letter.
	\end{enumerate}
Here, $|x|$ and $|x|_a$ denotes the length of $x$ and the number of occurrences of $a$ in $x$, respectively. 

An \emph{integer constraint} over $\Sigma$ is a Boolean combination of atomic integer constraints over $\Sigma$
\end{definition}

Character constraints, on the other hand, allow to compare symbols from different strings. The formal definitions are given as follows. 

\begin{definition}[Character constraints]
	An \emph{atomic character constraint} over $\Sigma$ is an expression of the form $x[u]=y[v]$ where 
	\begin{itemize}
		\item $x$ and $y$ are either a string variable or a word in $\Sigma^*$, and 
		\item $u$ and $v$ are either integer variables or constants positive integers.
	\end{itemize} 
Here, the interpretation of $x[u]$ is $u$-th letter of $x$.	
	
A \emph{character constraint} over $\Sigma$ is a Boolean combination of atomic character constraints over $\Sigma$. 
\end{definition}

One reason of introducing character constraints is, apart from the use of the JavaScript string method chatAt (which is used rather frequently in JavaScript according to the benchmark \cite{}), they can also be used to define $\indexof(w,x)$ for $w\in \Sigma^*$, which is the most standard usage of IndexOf method in practice. There are in general two natural semantics, viz., the \emph{first-occurrence} semantics and the \emph{anywhere} semantics. We write $u=\indexof(w,x)$ where $u$ is an integer variable, which holds
\begin{itemize}
	\item under  the \emph{first-occurrence} semantics, if $u$ is the first position in $x$ where $w$ occurs;
	
	\item the \emph{anywhere} semantics, if $u$ is \emph{any} position in $x$ where $w$ occurs;
\end{itemize}  
 


\subsection{Undecidability of length constraints}

Recall the Hilbert 10th problem, which is, for any given Diophantine equation (a polynomial equation with integer coefficients and a finite number of unknowns), to decide whether the equation has a solution with all unknowns taking integer values. It is easy to observe that given two polynomials with positive integral coefficients over the same set of variables $x_1, \cdots, x_n$, it is \emph{undecidable} to check whether $f(x_1, \cdots, x_n)=g(x_1, \cdots, x_n)$ has a solution in natural numbers. 

\begin{theorem}
	The satisfiability problem for SL[$\replaceall$] with \emph{length constraints} is undecidable. 
\end{theorem}

\begin{proof}
	We shall reduce from the aforementioned version of the Hilbert tenth problem. For any polynomial with positive integral  $f(x_1, \cdots, x_n)$ where each coefficient is a positive, we can construct a (division-free) arithmetic circuit (AC) is a directed  acyclic graph with nodes labelled with constants from $\mathbb{Z}$, or with some indeterminates $X_1, \cdots, X_m$, or with the operators $+, -, *$. The nodes labelled with constants are called constant nodes, while those labelled with indeterminates are called input nodes. Both constant and input nodes do not have incoming edges. Internal nodes are those labelled with $+,-,*$. Output node is the one which does not have out-going edges. Without loss of generality we assume that each internal node has in-degree 2, and there is only one output node. Each node in the circuit represents a multivariate polynomial $\mathbb{Z}[X_1, \cdots, X_m]$. Vice verse, each polynomial $f\in \mathbb{Z}[X_1, \cdots, X_m]$ can be represented as an AC, and, if the polynomial has only positive (integral) coefficients, the corresponding AC does not contain nodes labelled by $-$ or negative constants.  
	
	We observe that, given an AC, one can construct an SL[$\concat, \replaceall$] formula over the alphabet $\Sigma=\{a\}$ as follows. Each node $n$ of the AC is associated with a string variable $x_n$. As a result, each input node of the AC labelled by $X_i$ (i.e., the indeterminate) corresponds to a  source variable.   
	\begin{itemize}
		\item For each internal node $n$ labelled by $+$, suppose that $n$ has two children nodes $n_l$ and $n_r$, we introduce a string constraint $x_n= x_{n_l}\concat x_{n_l}$.  
		
		\item For each internal node $n$ labelled by $*$, suppose that $n$ has two children nodes $n_l$ and $n_r$, we introduce a string constraint $x_n= \replaceall(x_{n_l}, a, x_{n_l})$.  		
	\end{itemize}
Furthermore, we introduce, for each node $n$ labelled by a constant $c$, a regular constraint $x_n=a^c$. 

It is straightforward to verify, according to the semantics of SL[$\concat, \replaceall$], that:
\begin{itemize}
	\item for relational constraint $x_n= x_{n_l}\concat x_{n_l}$, $|x_n|= |x_{n_l}|+|x_{n_l}|$; 
	\item for relational constraint $x_n= \replaceall(x_{n_l}, a, x_{n_l})$,  $|x_n|= |x_{n_l}|\cdot |x_{n_l}|$; and 
	\item for regular $x_n=a^c$, $|x_n|=c$. 
\end{itemize}

It follows that for each polynomial $f(x_1, \cdots, x_m)$ with positive integral coefficients, we can construct a straight-line string constraint $\varphi_{f}\wedge\psi_g$ over $\Sigma=\{a\}$ with $y_f$ as the output variant and $y_1, \cdots, y_n$ as source variables such that
$f(c_1, \cdots, c_m)=|y|$ and, for each $1\leq i\leq m$, $|y_i|= c_i$ (i.e., $y_i=a^{c_i}$).  

Consequently, when given two polynomials $f(x_1, \cdots, x_m)$ and $g(x_1, \cdots, x_m)$, we have straight-line string constraints $\varphi_{f}\wedge \varphi_{g}\wedge \psi_{f}\wedge \psi_g$ with two distinguished two variables  $y_f$ and $y_g$ such that  
\[\exists x_1, \cdots, x_m. f(x_1, \cdots, x_m)=g(x_1, \cdots, x_m)\mbox{ iff } |y_f|=|y_g|\wedge \varphi_{f}\wedge \varphi_{g}\wedge \psi_{f}\wedge \psi_g\mbox{ is satisfiable} \]

Finally, note that any  SL[$\concat, \replaceall$] constraints can be transformed into SL[$\replaceall$] constraints, we obtain a reduction from the Hilbert's 10th problem to the satisfiability problem of  SL[$\replaceall$] with length constraints, which entail that the latter problem is undecidable. The proof is completed. 
\end{proof}

The above proof essentially establishes a link between string constraints and Diophantine equations. With further result from Hilbert 10'th problem, we can strengthen the undecidability results shown that satisfiability of even very simple string constraints (e.g., the $\replaceall$ function is unnested) will be undecidable in conjunction with length constraints. 
 
A \emph{linear polynomial} is a polynomial of the form $a_0 + a_1x_1 + \cdots + a_n x_n$ where
each coefficient $a_i\in \mathbb{Z}$  for $0 \leq i \leq n$. 

\begin{theorem}[\cite{ID02}]
	There exists some (fixed) $k$ such that no algorithm can solve Diophantine systmes in the following form
	\[t_1F_1=G_1, t_1H_1=I_1, \cdots, t_kF_k = G_k, t_kH_k = I_k,\] 
	%
	where $F_i, G_i, H_i, I_i$ for $1\leq i\leq k$ are nonnegative linear polynomials over natural number variables  $s_1, \cdots, s_m$.
\end{theorem}

From this class of quadratic Diophantine equations, we can introduce string variables $x_1, \cdots, x_k$ and $y_1, \cdots, y_m$, together with relational string constraints 
\[z_{i,j}=\replaceall(x_i, a, y_j)\]
for $1\leq i\leq k$ and $1\leq j\leq m$. Note that, for each $i$,  $t_i F_i=G_i$ can be written as
\begin{equation} \label{eq:dio}
t_i\cdot \left(a_0+\sum_{j=1}^s a_j s_j\right) =  b_0+\sum_{j=1}^s b_j s_j
\end{equation}
where $a$'s and $b$'s are all natural numbers. Moreover, \eqref{eq:dio} holds iff 
\[a_0\cdot |y_i|+ \sum_{j=1}^s a_j |z_{i,j}| =  b_0+ \sum_{j=1}^s b_j |x_j| \] 
which is an integer constraint defined in Definition~\ref{def:intconst}. This entails that
\begin{proposition}
	The satisfiability problem for SL[$\replaceall$] with \emph{length constraints} is undecidable, even when the relational constraints are \emph{not} nested.
\end{proposition}

%\begin{example}
%We use the following example to illustrate the reduction. Suppose that we have two simultaneous Diophantine equation $t1(s1+s2)=s1+2s2$  and   $t1(2 s1+ 3 s2)=s1+s2$ 
%	
%	Then set x1=r(t1, a, s1), x2=r(t1, a, s2), and we require length (x1 x2 x2)= length (s1 s2 s2) and  length (x1 x1 x2 x2 x2 )= length (s1 s2)
%	
%\end{example}

\subsection{Undecidability of character constraints}


We have the following simple observation:

\begin{lemma}
	For any two strings $x,y\in a^*\$$, $|x|=|y|$ iff $\exists n. x[n]=y[n]=\$$. 
\end{lemma}

As SL[$\replaceall$] with length constraints is undecidable, we conclude that 

\begin{theorem}
	The satisfiability problem for SL[$\replaceall$] with \emph{character constraints} is undecidable. 
\end{theorem}


\tl{I am not satisfied with this as the quantifier is used}

\subsection{Undecidability of IndexOf}
 

We have the following observation: 
\begin{lemma}
	For any two strings $x,y$ over $\{a\}$, $x=y$ iff $1=\indexof(x,y)=\indexof(y,x)$.  
\end{lemma}

It follows that 
\begin{proposition}
	$\strline[\replaceall]$ extended with IndexOf is undecidable, regardless of the first-occurrence and the anywhere semantics. 
\end{proposition}

%\subsection*{Further undecidability results}


