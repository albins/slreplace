%!TEX root = popl2018.tex

\section{Decision procedure for $\strline[\replaceall]$: The regular-expression case} \label{sec:replaceallre}

Let us consider the case that the second parameter of the $\replaceall$ function may be a regular expression.  The decision procedure presented below can be  seen as a generalisation of those in Section~\ref{sec:replaceallsl} and Section~\ref{sec:replaceallcs}. \zhilin{we should say a few words on why we present the special cases in the previous sections, since they are subsumed by the decision procedure in this section.}

As in previous sections, let us still start with the simple situation that $C \equiv x = \replaceall(y, e_0, z) \wedge x \in e_1 \wedge y \in e_2 \wedge z \in e_3$. For $i=0,1,2,3$, let $\cA_i = (Q_i, \delta_i, q_{0,i}, F_i)$ be the NFA corresponding to $e_i$. 

Let us first assume $\varepsilon \in \Ll(e_0)$. Then according to the semantics, for each string $u = a_1 \cdots a_n$, $\replaceall(u, e_0, v) = v a_1 v \cdots v a_n v$. Under this assumption, we can solve the satisfiability of $C$ as follows: 
\begin{enumerate}
\item Guess a set $T_z \subseteq Q_1 \times Q_1$. 
%
\item Construct $\cB_{\cA_1, \varepsilon, T_z}$ from $\cA_1$ and $T_z$ as follows: For each $(q,q') \in T_z$, add to $\cA_1$ a transition $(q, \varepsilon, q')$. Then transform the resulting NFA into one without $\varepsilon$-transitions (which can be done in polynomial time).
%
\item  Decide the nonemptiness of $\Ll(\cA_2) \cap \Ll(\cB_{\cA_1, \varepsilon, T_z})$ and $\Ll(\cA_3) \cap \bigcap \limits_{(q,q') \in T_z} \Ll(\cA_1(q,q'))$.
\end{enumerate}

Next, let us assume $\varepsilon \not \in \Ll(e_0)$. Then we know that $q_{0,0} \not \in F_0$. In addition, without loss of generality, we assume that there are no incoming transitions for $q_{0,0}$ in $\cA_0$.

To solve the satisfiability of $C$, similar to the constant-string case, we construct a parsing automaton $\cA_{e_0}$ that parses a string $v \in \Sigma^\ast e_0 \Sigma^\ast$ into $v_1 u_1 v_2 u_2 \dots v_l u_l v_{l+1}$ such that 
\begin{itemize}
	\item for each $j \in [l]$, $u_j$ is the leftmost and longest matching of $e_0$ in $(v_1 u_1 \dots v_{j-1} u_{j-1})^{-1} v$,
	%
	%\item $v_j u_j[1] \dots u_j[|u_j|-1] \not \in \Sigma^\ast e \Sigma^\ast$ for each $1 \le j \le l$, in addition, $v_{l+1} \not \in \Sigma^\ast e \Sigma^\ast$,
	\item $v_{l+1} \not \in \Sigma^\ast e_0 \Sigma^\ast$.
\end{itemize}


%
Intuitively, in order to search for the leftmost and longest matching of $e_0$, 
\begin{itemize}
\item $\cA_{e_0}$ has two modes, ``$\searchleft$'' and ``$\searchlong$'', which intuitively means search for the first and last position of the leftmost and longest matching respectively,
 %
	\item when in the ``$\searchleft$'' mode, $\cA_{e_0}$ starts a new thread of $\cA_0$ in each position and records the states of the threads into a vector, in addition, it nondeterministically makes a ``leftmost'' guessing, that is, guesses that the current position is the first position of the leftmost and longest matching, if it makes such a guessing, then it enters the ``$\searchlong$'' mode, it runs the thread started in the current position and search for the last position of the leftmost and longest matching, moreover, it stores in a set $S$ the states of all the threads that were started before the current position  and continues running these threads to make sure that in these threads the final states will not be reached (thus, the current position is indeed the first position of the leftmost and longest matching),
	%
	\item when in the ``$\searchlong$'' mode, $\cA_{e_0}$ runs a thread to search for the last position of the leftmost and longest matching, if the thread enters a final state, then $\cA_{e_0}$ nondeterministically makes a ``longest'' guessing, that is, guesses that the current position is the last position of the leftmost and longest matching, if it makes such a guessing, then it resets the states and starts a new round of leftmost and longest matching,
	%
%	\item when a thread $i$ enters a final state, a matching of $e$ is found, $\cB_e$ nondeterministically guesses whether this matching is the leftmost matching or the longest matching, 
	%
%	\item if $\cB_e$ makes a ``leftmost and longest'' guessing, then $\cB_e$ forgets all the other threads that were started later than the thread $i$, and continues running the thread $i$ and all the threads that were started earlier than the thread $i$ to make sure that final states will not be reached and the ``leftmost and longest'' guessing is correct,
%
%	\item if $\cB_e$ makes a ``leftmost and non-longest'' guessing, then $\cB_e$ forgets all the other threads that were started later than the thread $i$, and continues running all the threads that were started earlier than the thread $i$ to make sure that final states will not be reached and the ``leftmost'' guessing is correct, in addition, it continues running the thread $i$ and searching for the longest matching,
%
%	\item if $\cB_e$ makes a ``non-leftmost'' guessing, then $\cB_e$ forgets the thread $i$ and all the other threads that were started later than the thread $i$, and continues running all the threads that were started earlier than the thread $i$ and searching for the leftmost matching,
	%
	\item moreover, since the length of the vectors of states of the threads may become unbounded, in order to obtain a finite state automaton, the following trick is applied: suppose that $q_1 q_2 \cdots q_n$ is the vector of the current states of the threads, if $q_i = q_j$ for $i, j: i < j$, then remove $q_j$.
\end{itemize}

%\zhilin{i stopped here}

Formally, $\cA_{e_0}=(Q_{e_0}, \delta_{e_0}, q_{0,e_0}, F_{e_0})$ is defined as follows.
\begin{itemize}
	\item $Q_{e_0}$ comprises 
	\begin{itemize}
		\item the tuples $((q_{0,0}), \searchleft, S)$ such that $S \subseteq Q_0$,
		%
		\item the tuples $(\rho, \searchleft, S)$ such that  $\rho$ is a nonempty vector of \emph{pairwise distinct} states of $\cA_0$, $\rho \neq (q_{0,0})$, and $S \subseteq Q_0 \setminus F_0$, 
		%
		% \item the tuples $(q_{0,e}, \longest, S)$ such that  $S \subseteq Q_e$,
		%
		\item the tuples $(q, \searchlong, S)$ such that $q \in Q_0$ and $S \subseteq Q_0 \setminus F_0$;
	\end{itemize}
	%
	\item $q_{0,e_0}= ((q_{0,0}), \searchleft, \emptyset)$,
	%
	\item $F_{e_0}$ comprises the states of the form $(-, \searchleft, -) \in Q_e$,
	%
	\item $\delta_{e_0}$ is defined as follows: 
	\begin{itemize}
		%\item $((q_{0,e}, \leftmost, S), a, ((\delta_e(q_{0,e},a), q_{0,e}), \leftmost, \delta_e(S,a)))$, where $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$,
		%
		\item suppose $(\rho, \searchleft, S) \in Q_{e_0}$, $a \in \Sigma$ and $\delta_0(S,a) \cap F_0 = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\red(\delta_0(\rho,a))q_{0,0}, \searchleft, \delta_0(S,a))) \in \delta_{e_0},$$ 
		note that no states occur more than once in $\red(\delta_0(\rho,a))q_{0,0}$, since $q_{0,0}$ does not occur in $\red(\delta_0(\rho,a))$, as a result of the assumption that there are no incoming transitions for $q_{0,0}$ in $\cA_0$,
		%
		\item suppose $(\rho, \searchleft, S) \in Q_{e_0}$, $\rho = \rho' q_m$,  $a \in \Sigma$, and $\delta_0(S,a) \cap F_0 = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\delta_0(q_m, a), \searchlong, \delta_0(S,a) \cup \{\delta_0(q_j, a) \mid j \in [m-1]\})) \in \delta_{e_0},$$ 
		%
		\zhilin{i stopped here}
		\item suppose $\rho = q_1 \dots q_m$ (where $q_m = q_{0,e}$),  $a \in \Sigma$, $\delta_e(q_m, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\})) \in \delta'_e,$$ 
		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hide{
		\item suppose $\rho = q_1 \dots q_m$,  $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains \emph{no} states from $F_e$, $\delta_e(S,a) = \{\delta_e(q,a) \mid q \in S \}$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, (\red(\delta_e(\rho,a))q_{0,e}, \searchleft, \delta_e(S,a))) \in \delta'_e,$$ 
		%
		\item {\bf ``leftmost and longest'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$, $\delta_e(\rho,a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid 1\le j \le i\})) \in  \delta'_e,$$ 
		%
%		intuitively, $\cB_e$ makes a ``leftmost and longest'' guessing and continues running all the threads of indices no greater than $i$,
		\item {\bf ``leftmost and non-longest'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$,   and $\delta_e(S,a) \cap F_e = \emptyset$, then 		
		$$((\rho, \searchleft, S), a, (\delta_e(q_i, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid 1 \le j \le i-1\})) \in  \delta'_e,$$ 
		%
		\item {\bf ``non-leftmost'' guessing}: \\
		suppose $\rho = q_1 \dots q_m$, $a \in \Sigma$, $\delta_e(\rho, a) = \delta_e(q_1,a) \dots \delta_e(q_m, a)$ contains at least one state from $F_e$, $i \in [m]$ is the smallest index such that $\delta_e(q_i, a) \in F_e$, $i > 1$,  and $\delta_e(S,a) \cap F_e = \emptyset$, then 		
		$$((\rho, \searchleft, S), a, (\red(\delta_e(q_1,a) \dots \delta_e(q_{i-1},a)), \searchleft, \delta_e(S,a)) \in  \delta'_e,$$ 
%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\item suppose $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \searchlong, S), a, (\delta_e(q,a), \searchlong, \delta_e(S,a)) \in \delta'_e,$$
		%
		\item suppose $\delta_e(q,a) \in F_e$ and $\delta_e(S,a) \cap F_e = \emptyset$, then 
		$$((q, \searchlong, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q,a)\}) \in \delta'_e.$$
	\end{itemize}
\end{itemize}

\begin{example}
$\cA_{e_0}$
\end{example}


Similarly to the constant-string case, the main technical difficulty is to construct $\cB_{\cA_i, e,  T_{i, z}}$. The NFA $\cB_{\cA_i, u,  T_{i, z}}$ is constructed by the following two-step procedure.
\begin{enumerate}
\item Construct the product of $\cA_i$ and $\cB_e$. Then remove all the states $(q, (-, \searchlong, -))$ as well as the transitions associated with them, in addition, remove all the transitions entering the states $(q, ((q_{0,e}), \searchleft,-))$.

\item For each pair $(q,q') \in T_{i,z}$, do the following,
\begin{itemize}
\item for each transition
$$((\rho, \searchleft, S), a, (\delta_e(q_m, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m-1]\})) \in \delta'_e,$$
add a transition
$$((q, (\rho, \searchleft, S)), a, (q, (\delta_e(q_m, a), \searchlong, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m-1]\}))),$$
%
\item for each transition 
$$((q'', \searchlong, S), a, (\delta_e(q'', a), \searchlong, \delta_e(S,a))) \in \delta'_e,$$  
add a transition 
$$((q, (q'', \searchlong, S)), a, (q, (\delta_e(q'', a), \searchlong, \delta_e(S,a)))),$$
%
\item for each transition
$$((q'', \searchlong, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q'',a)\}) \in \delta'_e,$$
add a transition
$$((q, (q'', \searchlong, S)), a, (q', ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q,a)\}))),$$
%
\item for each transition
$$((\rho, \searchleft, S), a, ((q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\})) \in \delta'_e,$$
add a transition
$$((q, (\rho, \searchleft, S)), a, ((q', (q_{0,e}), \searchleft, \delta_e(S,a) \cup \{\delta_e(q_j, a) \mid j \in [m]\}))).$$
\end{itemize}
\end{enumerate}

\begin{example}
$\cB_{\cA_1, e_0,  T_{z}}$
\end{example}

The more general case that there are multiple $\replaceall(\cdots)$ terms.

%\subsection{A decision procedure for $\strline[\replaceall]$}


