%!TEX root = popl2018.tex

\begin{abstract}

The theory of strings with concatenation has been widely argued as the basis of
constraint solving for verifying string-manipulating programs. However, this
theory is far from adequate for expressing many string constraints that are
also needed in practice; for example, the use of regular constraints (pattern matching
against a regular expression), and the string-replace function (replacing
either the first occurrence or all occurrences of a ``pattern'' string
constant/variable/regular expression by a ``replacement'' string
constant/variable), among many others. Both regular constraints and the
string-replace function are crucial for such applications as analysis of
JavaScript (or more generally HTML5 applications) against cross-site scripting
(XSS) vulnerabilities, which motivates us to consider a richer class of string
constraints. The importance of the string-replace function (especially the
replace-all facility) is increasingly recognised, which can be witnessed by the
incorporation of the function in the input languages of several string
constraint solvers. 

Recently, it was shown that any theory of strings containing the string-replace
function (even the most restricted version where pattern/replacement strings
are both constant strings) becomes undecidable if we do not impose some kind of
straight-line (aka acyclicity) restriction on the formulas. Despite this,
the straight-line restriction is still practically sensible since this condition is  
typically met by string constraints that are generated by symbolic   execution.
In this paper, we provide the first systematic study of straight-line string 
constraints with the string-replace function and the regular constraints as the 
basic operations. We show that a large class of such constraints (i.e. when
only a constant string or a regular expression is permitted in the
pattern) is decidable. We note that the string-replace function, even under
this restriction, is sufficiently powerful for expressing the concatenation
    operator and much more (e.g. extensions of regular expressions with string variables).
This gives us the most expressive decidable logic containing concatenation,
replace, and regular constraints under the same umbrella.
Our decision procedure for the straight-line fragment follows an 
    automata-theoretic approach, and is modular in the sense that the string-replace terms are removed one by one to generate more and more regular constraints, which can then be discharged by the state-of-the-art string constraint solvers. 
We also show that this fragment is, in a way, a maximal decidable subclass of
the straight-line fragment with the string-replace and regular constraints.
To this end, we show that undecidability results in the following two
extensions: (1) variables are permitted in the pattern parameter of
    the replace function, (2) length constraints are permitted.
    %, or character constraints, or constraints involving the IndexOf function are permitted in the logic.
    
    
    
    \OMIT{
    We also delineate the boundary of decidability by
    showing undecidability in the case of 
}
%In this paper, we revisit 
    %offer a different
%viewpoint of string constraints for 
\OMIT{
    the theoretical foundation of string constraints for verifying 
    string-manipulating programs and 
    offer a different viewpoint:  
    the string-replace function and regular constraints (i.e. 
    not concatenation) should be the basic operations. 

We first note that 
the most general version of the string-replace function (where the replacements are string
variables) 
is sufficiently powerful to express the concatenation operator, 
solving such constraints is undecidable in general. 
}
\OMIT{
We then impose a straight-line restriction on the formulas (a shape of
formulas typically generated by symbolic execution), and show that decidability
can be recovered for a large subclass of the resulting constraints, namely as
    long as the pattern string is not a variable (which is again undecidable). 


As a special subcase, we obtain the decidability of 

In addition, we show that adding either integer constraints, character constraints, or constraints involving the IndexOf function to the straight-line fragment leads to undecidability again.
}

%delineate
%the decidability boundary of the resulting fragments. Our main result is 
%an algorithm for deciding satisfiability for the straight-line fragment
%of formulas, wherein each pattern parameter is either a constant or a 
 %   a ``source'' variable (i.e. not defined in terms of other variables using
 %   the replace function). On one hand, our decidability result strictly 
 %   subsumes a recently proposed
%A large 
%decidable subclass of the theory of strings with concatenation, replace 
%(where both pattern/replacement strings must be constant strings), and 
%regular constraints, which could express the program logic of scripts with 
%subtle DOM-based XSS vulnerabilities. On the other hand, our decidability
%allows a natural usage of the replace function to be modelled (e.g., 
%replacing each occurrence of the string \texttt{'username'} by a username
%variable).
%particular,
    %by imposing the straight-line
%restriction on the formulas. This class of formulas 
%with equality of variables permitted solving such constraints is undecidable 
%in general. 
    %Concatenation can easily be
    %simulated by the most general version of string 
    %We observe that concatenation can
%be easily simulated by 
%The string-replace function in its most generality.  

    \OMIT{
Our goal in this paper is to investigate extensively the decidability and complexity of the satisfiability problem of string constraints with the function $\replaceall$. We show that while it is undecidable in general, the satisfiability problem for the straight-line fragment is in EXPSPACE, by following an automata-theoretical approach.
}
\end{abstract}
