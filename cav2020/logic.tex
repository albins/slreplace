%\section{The logic \slint}

The string logic {\slint} defined by the following rules% satisfies the two semantic conditions,
\[
\begin{array}{l c l}
t  &::=& i \mid c \mid \length(x) \mid \indexof_u(x, i) \mid  ct  \mid t + t,   \\
S &::= &  x:= y \concat z \mid x:= \replaceall_{e,u}(y) \mid   x:=\reverse(y) \mid x:=T(y) \mid \\
& & x := \substring(y, t_1, t_2)  \mid S;S, \\
A & ::= &   A_r \wedge A_i,\\
A_r & ::= & x \in \Aut \mid A_r \wedge A_r,\\
A_i & ::= & t\ o\ t \mid A_i \wedge A_i  \mid A_i \vee A_i,
\end{array}
\]
where  $u \in \Sigma^+$, $e$ is a regular expression, $T$ is a finite-state transducer, and $o \in \{=, \neq, \ge, \le, >, <\}$.

We consider two types of functions, string functions that return strings and integer functions that return integers. Specifically, we consider 
\begin{itemize}
\item string functions $f(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, where $f$ is of the arity $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^{\Sigma^*}$, and
\item  integer functions $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, where $g$ is of the arity $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^\intnum$.
\end{itemize} 
Note that $f$ and $g$ can be nondeterministic.
%\subsection{The abstract version}

We consider string constraints where the formulae are of the form $S \wedge A$ defined by the following rules,
\[
\begin{array}{l c l}
t  &::=& i \mid c \mid  g(x_1, \vec{t_1}, \cdots, x_k, \vec{t_k}) \mid ct \mid t + t,   \\
S &::= &  x:=f(x_1, \vec{t_1}, \cdots, x_k, \vec{t_k}) \mid S;S, \\
A_r & ::= & x \in \Aut  \mid A_r \wedge A_r, \\
A_i & ::= & t\ o\ t \mid A_i \wedge A_i \mid A_i \vee A_i,\\
A & ::= &   A_r \wedge A_i, 
\end{array}
\]
where $f$ is a string function and $g$ is an integer function, $\vec{t_j} = t_{j,1}, \cdots, t_{j, n_j}$ for each $j \in [k]$, $\Aut$ is a finite-state automaton, and $o \in \{=, \neq, \ge, \le, >, <\}$.

The logic {\slint} is defined as straight-line fragment of the aforementioned string constraints, specifically, {\slint} is defined as the collection of the formulae $S \wedge A$ satisfying that {\bf $S$ is in single static assignment (SSA) form}.  Note that in {\slint}, the straight-line restriction is applied only on $S$, which contains only the assignments to string variables (but not integer variables). No restrictions are put on the integer constraints in $A_i$.
\[
\begin{array}{l c l}
A & ::= &   A_r \wedge A_i, \\
A_r & ::= & x \in \Aut \mid A_r \wedge A_r,\\
A_i & ::= & t\ o\ t \mid A_i \wedge A_i  \mid A_i \vee A_i
\end{array}
\]
where  $u \in \Sigma^+$, $e$ is a regular expression, $T$ is a finite-state transducer, and $o \in \{=, \neq, \ge, \le, >, <\}$.
\tl{decide later whether $\replaceall_{e,u}(y)$ is needed here.}

%%%%%%%%%%%%%%%  Temporally commented out %%%%%%%%%%%%%%%%%%%%%%%
%\subsection{The abstract version}

%We consider two types of functions, string functions that return strings and integer functions that return integers. Specifically, we consider 
%\begin{itemize}
%	\item string functions $f(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, where $f$ is of the signature $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^{\Sigma^*}$, and
%	\item  integer functions $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, where $g$ is of the signature $\Sigma^* \times \intnum^{n_1} \times \cdots \times \Sigma^* \times \intnum^{n_k} \rightarrow 2^\intnum$.
%\end{itemize} 
%Note that $f$ and $g$ can be nondeterministic.
%
%We consider string constraints where the formulae are of the form $S \wedge A$ defined by the following rules,
%\[
%\begin{array}{l c l}
%t  &::=& i \mid c \mid  g(x_1, \vec{t_1}, \cdots, x_k, \vec{t_k}) \mid ct \mid t + t,   \\
%S &::= &  x:=f(x_1, \vec{t_1}, \cdots, x_k, \vec{t_k}) \mid S;S, \\
%A_r & ::= & x \in \Aut  \mid A_r \wedge A_r, \\
%A_i & ::= & t\ o\ t \mid A_i \wedge A_i \mid A_i \vee A_i,\\
%A & ::= &   A_r \wedge A_i, 
%\end{array}
%\]
%where $f$ is a string function and $g$ is an integer function, $\vec{t_j} = t_{j,1}, \cdots, t_{j, n_j}$ for each $j \in [k]$, $\Aut$ is a finite-state automaton, and $o \in \{=, \neq, \ge, \le, >, <\}$.
%%%%%%%%%%%%%%%  Temporally commented out %%%%%%%%%%%%%%%%%%%%%%%

%The logic {\slint} is defined as straight-line fragment of the aforementioned string constraints, specifically, 
We assume that {\bf  string constraints %{\slint} is defined as the collection of the formulae $S \wedge A$ satisfying that 
$S$ are in single static assignment (SSA) form}.  %Note that in {\slint}, the straight-line restriction 
Note that it is applied  to $S$ only while it is remitted from the integer constraints in $A_i$. 
%which contains only the assignments to string variables (but not integer variables). No restrictions are put on the integer constraints in $A_i$.
%Intuitively speaking, the integer constraints in $S \wedge A$ are split into the integer assignments in $S$ where the right-hand side is of the form $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$ and the constraints $t\ o\ t$ in $A$ where the integer functions $g$ do not occur.
%\begin{itemize}
%\item $S$ is in single static assignment (SSA) form,
%\item all the assignments $i: = t$ in $S$ satisfy that either $t$ is of the form $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, or $t$ contains no occurrences of the functions of the form $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$, namely, $t$ is an integer term built from integer variables and constants ,
%
%\item $A$ contains no occurrences of the functions $g(x_1, \vec{i_1}, \cdots, x_k, \vec{i_k})$,
%
%\item all the string variables in $A$ also occur in $S$.
%\end{itemize} 

\begin{example}
The formula $x:= y \concat z \wedge y := \substring(y', \indexof(x, c), j)  \wedge y' \in (ab)^* \wedge z \in a^* c b^* \wedge   j = 2 \indexof(x, c)$ belongs to \slint.
\end{example}


\subsection{Semantics}

The semantics of  {\slint}  is largely self-explanatory. In particular, $\length(x)$ returns the length of string $x$, $\indexof_u(x, i)$ returns the first index of $u$ in $x$ after $i$. 

$\substring(y, t_1, t_2)$ returns the string of $y$ between $t_1$ and $t_2$. 


%The replaceAll function encompasses two parameters: the first parameter is the subject string, and the second parameter is the replacement
%string whereas $u$ the
%second parameter is a pattern that is a regular expression, . For the semantics of replaceAll function, in particular when the pattern is a regular expression,
%we adopt the leftmost and longest matching. For instance, replaceAll(aababaab, (ab)+, c) = ac ·
%replaceAll(aab, (ab)+, c) = acac, since the leftmost and longest matching of (ab)+ in aababaab is
%abab. Herewe require that the language defined by the pattern parameter does not contain the empty
%string, in order to avoid the troublesome definition of the semantics of the matching of the empty
%string. We refer the reader to [Chen et al. 2018] for the formal semantics of the replaceAll function.
%To be consistent with the notations in this paper, for each regular expression e, we define the string
%function replaceAlle : Σ∗ × Σ∗ → Σ∗ such that for u,v ∈ Σ∗, replaceAlle (u,v) = replaceAll(u, e,v),
%and we write replaceAll(x, e,y) as replaceAlle (x,y).

In the next section, we specify the semantic conditions for {\slint} in order to achieve decision procedures. For this purpose, we need the concepts of cost-enriched regular languages and recognisable relations. 

%\section{The semantic conditions}