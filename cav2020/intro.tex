%!TEX root = main.tex

Strings are a fundamental data type in virtually all programming languages.
Their generic nature can, however, lead to many subtle programming
bugs, some with security consequences, e.g., cross-site scripting
(XSS), which is among the OWASP Top 10 Application Security Risks
\cite{owasp17}. One effective
automatic testing method for identifying subtle programming errors
is based on \emph{symbolic execution}
\cite{king76} and combinations with dynamic analysis
called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
See \cite{symbex-survey} for an excellent survey. Unlike purely random testing,
which runs only \emph{concrete} program executions on different
inputs, the techniques of symbolic execution analyse \emph{static} paths
(also called symbolic executions) through the software system under test.
Such a path can be viewed as a constraint $\varphi$ (over
appropriate data domains) and the hope is that a fast
solver is available for checking the satisfiability of $\varphi$ (i.e. to check
the \emph{feasibility} of the static path), which can be used for generating
inputs that lead to certain parts of the program or an erroneous behaviour.

Integer data type naturally comes to play in string-manipulating programs, typically in the form of lengths or positions of strings. String functions involving the integer data type, for instance,  $\length$, $\indexof$, and $\substring$, are widely used in string-manipulating programs. For instance, it was reported in \cite{Berkeley-JavaScript} that $\length$, $\indexof$, $\substring$, and their variants, occupy more than 80 percent of string function occurrences in their subject Javascript applications. This motivates \emph{string constraint solvers that reason about strings and integers simultaneously}.

%$\length: \Sigma^* \rightarrow \Int$ (where $\Sigma$ is the alphabet and $\Sigma^*$ is the set of strings over $\Sigma$), $\substring: \Sigma^* \times \Int \times \Int \rightarrow \Sigma^*$, and $\indexof: \Sigma^* \times \Int \rightarrow \Int$.

We use the following Javascript code as a running example to illustrate the approach of this paper, where a function {\urlxsssanitise} is defined, with the parameter url specifying an input URL. A typical URL consists of a hierarchical sequence of components referred to as the protocol, host, path, query, and fragment. For instance, in the URL ``http://www.example.com/some/abc.js?name=john$\#$print'', protocol = ``http'', host = ``www.example.com'', path = ``/some/abc.js'', query = ``name=john'' (preceded by $?$), fragment = ``print'' (preceded by $\#$). Note that either query or fragment could be missing in an URL. The aim of {\urlxsssanitise} is to mitigate a type of cross-site-scripting (XSS) attacks, called \emph{URL reflection attacks}, by filtering out the dangerous substrings ``$<$script$>$'' or ``javascript:'' from the input URL. URL reflection attacks  do not rely on saving malicious code in a database, but rather hiding it in the query or fragment components of URLs, e.g. ``http://www.example.com/some/abc.js?name=$<$script$>$alert('xss!');$<$/script$>$''.
%\begin{example}
{\small
\begin{minted}[linenos]{javascript}
function urlXssSanitise(url)
{
    var prothostpath='', querfrag = '';
    url = url.trim();
    var qmarkpos = url.indexof('?'), sharppos = url.indexof('#');
    if(qmarkpos >= 0) 
    {   prothostpath = url.substr(0,qmarkpos);
        querfrag = url.substr(qmarkpos); }
    else if(sharppos >= 0)
    {   prothostpath = url.substr(0,sharppos);
        querfrag = url.substr(sharppos); }
    querfrag = querfrag.replace(/<script>|javascript:/gi, '');
    url = prothostpath.concat(querfrag);
    return url;
}
\end{minted}
}
%\end{example}

% \in [\backslash w | \backslash x2E]^*$
%We expect that the returned value of the ``host'' variable contains only the alphanumeric symbols as well as the dot symbol, but actually this is not the case. This question can be reduced to solving the path feasibility problem of the following program of the SSA (single static assignment) form.

One may want to know whether {\urlxsssanitise} indeed works, namely, whether after applying {\urlxsssanitise} on the input URL, ``$<$script$>$'' and ``javascript:'' disappears.  This is reduced to checking whether there is some execution path of {\urlxsssanitise} that produces an output such that its query or fragment component contains an occurrence of ``$<$script$>$'' or ``javascript:''. For instance, if the first execution path of {\urlxsssanitise} is chosen, then the problem is reduced to solving the path feasibility of the following javascript program of the single static assignment (SSA) form,

{\small
\begin{minted}{javascript}
    prothostpath =''; querfrag = '';
    url1 = url.trim(); qmarkpos = url1.indexof('?');
    sharppos = url1.indexof('#'); assert(qmarkpos >= 0); 
    prothostpath1 = url1.substr(0, qmarkpos);
    querfrag1 = url1.substr(qmarkpos);
    querfrag2 = querfrag1.replace(/<script>|javascript:/gi, '');
    url2 = prothostpath1.concat(querfrag2);
    assert(! /<script>|javascript:/.test(querfrag2));
\end{minted}
}
where the $\ASSERT{cond}$ statements check that the condition $cond$ is satisfied.


state-of-the-art: heuristics

The contribution of this paper: decision procedure for string constraints involving integer data type

automata-theoretic, cost-enriched regular languages and recognisable relations, backward computation

implementation OSTRICH+, experimental results promising

first decision procedure for such an expressive class of string constraints involving so many different operations, natural extension of the decision procedure of OSTRICH, efficient implementation, extensive experiments, 

\input{related}

