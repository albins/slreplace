%!TEX root = main.tex

%\zhilin{this paragraph is copied from POPL'19 paper should be adapted.} 
This paper is concerned with strings and integers, two fundamental data type in virtually all programming languages.
String-manipulating programs are notoriously subtle and their potential bugs %Many subtle programming bugs are caused by , some with 
may bring severe security consequences, a typical example of which is cross-site scripting
(XSS), which is among the OWASP Top 10 Application Security Risks
\cite{owasp17}. Integer comes naturally with string-manipulating programs. %For instance, access to lengths or positions of strings is frequently needed. 
Typically, mainstream programming languages provide, apart from standard string functions such as concatenation and $\replaceall$, %string functions involving the integer data type, e.g. 
functions like $\length$, $\indexof$, and $\substring$, which can convert strings to integers and vice verse. %, are also widely used in string-manipulating programs. 
These functions are indeed heavily utilized in practice, for instance, it was reported \cite{Berkeley-JavaScript} that $\length$, $\indexof$, $\substring$ (or variants thereof) comprise over 80\% of string functions in some JavaScript applications (notably more frequent than concatenation). Undoubtedly, the introduction of integers exacerbates the intricacy of string-manipulating programs, which call for a unified 
framework to reason about them. 


%This motivates \emph{string constraint solvers that reason about strings and integers simultaneously}. 




%in programs it , typically in the form of lengths or positions of strings. Besides the classical string functions e.g. concatenation $\concat$ and $\replaceall$, string functions involving the integer data type, e.g. $\length$, $\indexof$, and $\substring$, are also widely used in string-manipulating programs. For instance, it was reported in \cite{Berkeley-JavaScript} that $\length$, $\indexof$, $\substring$, and their variants, occupy more than 80 percent of string function occurrences in their subject Javascript applications (even much more frequently used than concatenation). This motivates \emph{string constraint solvers that reason about strings and integers simultaneously}. 

One effective automatic analysis and testing method for identifying subtle programming errors is based on \emph{symbolic execution}.
%\cite{king76} and combinations with dynamic analysis
%called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
(See \cite{symbex-survey} for an excellent survey. )
%Unlike purely random testing,
%which runs only \emph{concrete} program executions on different
%inputs, the techniques of symbolic execution 
In a nutshell, this technique analyzes static paths
(aka. symbolic executions) through the program being considered. %software system under test.
Such a path can be viewed as a constraint $\varphi$ (over
appropriate data domains) and the hope is that a fast (constraint)
solver is available for checking the satisfiability of $\varphi$ (i.e., to check
the \emph{feasibility} of the static path), which can be used for generating
inputs that lead to certain parts of the program or an erroneous behavior.



%$\length: \Sigma^* \rightarrow \Int$ (where $\Sigma$ is the alphabet and $\Sigma^*$ is the set of strings over $\Sigma$), $\substring: \Sigma^* \times \Int \times \Int \rightarrow \Sigma^*$, and $\indexof: \Sigma^* \times \Int \rightarrow \Int$.

%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
\input{runexmp.tex}
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%


Reasoning about strings and integers is challenging and not well-understood. For instance, it is still a major open problem whether the string theory with concatenation (arguably the simplest string operation) and length functions (arguably the most common string-number function) is decidable \cite{Vijay-length}. It is easy to end up with undecidability: even the slightest extension of the theory (e.g. with letter counting % and
%string-number conversion) 
would render the theory undecidable \cite{buchi,GB16}. A further evidence is that, although a great deal of research has shown that one can support reasoning about rather complex string operations without breaking decidability by imposing syntactic restrictions on the constraints (e.g., \cite{CCH+18,CHL+19}; cf. related work for a brief survey), adding length constraints would immediately lead to undecidability \cite{CCH+18}. At the same time, the classes of constraints that are required in practice sometimes demand solving techniques which are not necessarily complete. %string operations that are not covered by decidable string constraint languages.
%
Indeed, a vast majority of  state-of-the-art string constraint solvers, e.g., {\cvc} \cite{cvc4}, {\zthree} \cite{Z3-str3}, Trau \cite{Abdulla17} (as well as its variants {\trauplus} \cite{AbdullaA+19} and {\zthreetrau} \cite{Z3-trau}),  ABC \cite{ABC}, and SLENT \cite{WC+18} do support  reasoning about both strings and integers.
%Nevertheless, solving string constraints involving the integer data type is far from trivial and actually undecidable in general \cite{buchi,CCH+18}. Therefore, all the aforementioned string constraint solvers
They however inevitably  resort to heuristics without completeness guarantees. 


As argued in \cite{CHL+19}, decision procedures with stronger theoretical guarantees, e.g., in the form of decidability (perhaps accompanied by a complexity analysis), are highly desirable. In a nutshell, there are at least two reasons: (1) they are intriguing in theory; and  %appealing %from a scientific point of view, and on the other hand, 
(2) they provide a kind of robustness guarantee upon which a practical solver could further improve and optimise.

%\zhilin{this paragraph is copied from the popl paper} Despite the excellent performance of some of these solvers on several existing benchmarks, there are good reasons for designing decision procedures with stronger theoretical guarantees, e.g., in the form of decidability (perhaps accompanied by a complexity analysis). One such reason is that string constraint solving is a research area in its infancy with an insufficient range of benchmarking examples to convince us that if a string solver works well on existing benchmarks, it will also work well on future benchmarks. A theoretical result provides a kind of robustness guarantee upon which a practical solver could further improve and optimise.

Recently, researchers started investigating the decision procedures for string constraints involving the integer data type, for instance \cite{Vijay-length,L16,LinM18,LB16}. Nevertheless, those decision procedures are largely only of the theoretical value, since they either support limited string functions (concatenation, length and regular constraints) or are too complicated for efficient implementation. We tackle this issue in this paper and aim at designing decision procedures for string constraints involving the integer data type, which, on the one hand, \emph{provide completeness guarantee}, and on the other hand, \emph{admit efficient implementation}.

The main contribution of this paper is a decision procedure for an expressive class of string constraints involving the integer data type, which includes not only the string functions concatenation, $\replaceall$, and finite transducers, but also $\length$, $\indexof$ and $\substring$. The decision procedure is automata-theoretic and utilises a variant of cost-register automata introduced by Alur et al. \cite{RLJ+13}, called \emph{cost-enriched finite automata} (abbreviated as CEFA). The decision procedure is in the same flavour as that of {\ostrich} \cite{CHL+19}, namely computing the backward image of CEFAs under string functions, thus inherits its elegance by treating the aforementioned seemly diverse string functions in a \emph{simple and generic} way. To the best of our knowledge, our decision procedure is \emph{the first decision procedure for string constraints that supports the string functions} $\substring$, $\length$, and $\indexof$, as well as concatenation, $\replaceall$, and finite transducers. \zhilin{improve latter}

Most importantly, our decision procedure admits efficient implementation, as an extension of the {\ostrich} solver \cite{CHL+19}, resulting int a new solver {\ostrich}+.  We do experiments on a wide range of benchmark suites to evaluate the performance of {\ostrich}+. The experiment results show that compared to the other competitive string constraint solvers, {\ostrich}+ performances well on the well-known {\kaluzabench} and {\pyexbench} benchmark suites and is \emph{the only one capable of solving the string constraints that contain both finite transducers and integer constraints}. For instance, {\ostrich}+ solves in several seconds \zhilin{check it later} the path feasibility of the SSA program in Example~\ref{exmp:running}, which is challenging to deal with since it contains $\length$, $\indexof$, and $\substring$, as well as complex string functions like the finite transducer {\tt trim()} and {\tt replaceAll}. 

\input{related}

