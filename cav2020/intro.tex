%!TEX root = main.tex

%\zhilin{this paragraph is copied from POPL'19 paper should be adapted.} 
This paper is concerned with strings and integers, two fundamental data types in virtually all programming languages.
String-manipulating programs are notoriously subtle and their potential bugs %Many subtle programming bugs are caused by , some with 
may bring severe security consequences, a typical example of which is cross-site scripting
(XSS), which is among the OWASP Top 10 Application Security Risks
\cite{owasp17}. Integer occurs naturally and richly in string-manipulating programs. %For instance, access to lengths or positions of strings is frequently needed. 
Typically, mainstream programming languages provide, apart from standard string functions such as concatenation, $\replace$ and $\replaceall$, %string functions involving the integer data type, e.g. 
functions like $\length$, $\indexof$, and $\substring$, which can convert strings to integers and vice versa. %, are also widely used in string-manipulating programs. 
These functions are indeed heavily utilised in practice, for instance, it was reported \cite{Berkeley-JavaScript} that $\length$, $\indexof$, $\substring$ (or variants thereof) comprise over 80\% of occurrences of string functions in 18 popular JavaScript applications (notably more frequent than concatenation). Undoubtedly, the introduction of integers exacerbates the intricacy of string-manipulating programs, which calls for a unified framework to reason about them. 


%This motivates \emph{string constraint solvers that reason about strings and integers simultaneously}. 




%in programs it , typically in the form of lengths or positions of strings. Besides the classical string functions e.g. concatenation $\concat$ and $\replaceall$, string functions involving the integer data type, e.g. $\length$, $\indexof$, and $\substring$, are also widely used in string-manipulating programs. For instance, it was reported in \cite{Berkeley-JavaScript} that $\length$, $\indexof$, $\substring$, and their variants, occupy more than 80 percent of string function occurrences in their subject Javascript applications (even much more frequently used than concatenation). This motivates \emph{string constraint solvers that reason about strings and integers simultaneously}. 

One effective automatic analysis and testing method for identifying subtle programming errors is based on \emph{symbolic execution}.
%\cite{king76} and combinations with dynamic analysis
%called \emph{dynamic symbolic execution} \cite{jalangi,DART,EXE,CUTE,KLEE}.
(See \cite{symbex-survey} for an excellent survey. )
%Unlike purely random testing,
%which runs only \emph{concrete} program executions on different
%inputs, the techniques of symbolic execution 
In a nutshell, this technique analyzes static paths
(a.k.a. symbolic executions) through the program being considered. %software system under test.
Such a path can be viewed as a constraint $\varphi$ (over
appropriate data domains) and the hope is that a fast (constraint)
solver is available for checking the satisfiability of $\varphi$ (i.e., to check
the \emph{feasibility} of the static path), which can be used for generating
inputs that lead to certain parts of the program or an erroneous behavior.



%$\length: \Sigma^* \rightarrow \Int$ (where $\Sigma$ is the alphabet and $\Sigma^*$ is the set of strings over $\Sigma$), $\substring: \Sigma^* \times \Int \times \Int \rightarrow \Sigma^*$, and $\indexof: \Sigma^* \times \Int \rightarrow \Int$.

%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
\input{runexmp.tex}
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% The running example %%%%%%%%%%%%%%%%%%%%%%%


Reasoning about strings and integers is challenging and not well-understood. 
%It is easy to end up with undecidability: even the slightest extension of this theory (e.g. the theory with concatenation and letter counting)  would render the theory undecidable \cite{buchi,GB16}. 
The problem is undecidable in general,  for instance, the string theory with concatenation and letter counting functions is undecidable \cite{buchi}. 
A further evidence is that, although a great deal of research has shown that one can support reasoning about rather complex string operations without breaking decidability by imposing proper restrictions on the form of the constraints (e.g., \cite{CCH+18,CHL+19}; cf. related work for a brief survey), adding length constraints would immediately lead to undecidability \cite{CCH+18}. Moreover, it is still a major open problem whether the string theory with concatenation (arguably the simplest string operation) and length function (arguably the most common string-number conversion) is decidable \cite{Vijay-length}. 
%
%At the same time, the classes of constraints that are required in practice sometimes demand solving techniques which are not necessarily complete. 
As a result, a vast majority of  state-of-the-art string constraint solvers, e.g., {\cvc} \cite{cvc4}, {\zthree} \cite{Z3-str3}, Trau \cite{Abdulla17} (as well as its variants {\trauplus} \cite{AbdullaA+19} and {\zthreetrau} \cite{Z3-trau}),  
%ABC \cite{ABC}, and SLENT \cite{WC+18}, 
resort to heuristics without completeness guarantees to support reasoning about both strings and integers.
%Nevertheless, solving string constraints involving the integer data type is far from trivial and actually undecidable in general \cite{buchi,CCH+18}. Therefore, all the aforementioned string constraint solvers
%They however inevitably  resort to heuristics without completeness guarantees. 

Nevertheless, as already argued in \cite{CHL+19}, despite the excellent performance of some of these solvers on some existing benchmark suites, decision procedures for string constraints with stronger theoretical guarantees, e.g., in the form of decidability (perhaps accompanied by a complexity analysis), are still highly desirable. In a nutshell, there are at least two reasons: (1) they are \emph{theoretically intriguing} as they can deepen our understanding and increase our knowledge of the problem; and  %appealing %from a scientific point of view, and on the other hand, 
(2) they are \emph{practically appealing} since they could potentially achieve a good balance between precision and scalability, if they are amenable to implementation. 
%they can provide a kind of robustness guarantees upon which a string constraint solver could further improve and optimise.if they are amenable to implementation, 

%\zhilin{this paragraph is copied from the popl paper} Despite the excellent performance of some of these solvers on several existing benchmarks, there are good reasons for designing decision procedures with stronger theoretical guarantees, e.g., in the form of decidability (perhaps accompanied by a complexity analysis). One such reason is that string constraint solving is a research area in its infancy with an insufficient range of benchmarking examples to convince us that if a string solver works well on existing benchmarks, it will also work well on future benchmarks. A theoretical result provides a kind of robustness guarantee upon which a practical solver could further improve and optimise.

Recently, researchers started investigating the decision procedures for string constraints involving the integer data type, for instance \cite{Vijay-length,L16,LinM18,LB16}. Nevertheless, those decision procedures are largely only of the theoretical value, since they either support limited string functions or are too complicated for  implementation. 
%(concatenation, length and regular constraints) 
We tackle this issue in this paper and aim at designing decision procedures for string constraints involving the integer data type, which, on the one hand, \emph{provide completeness guarantee}, and on the other hand, \emph{admit efficient implementation}.

The main contribution of this paper is a decision procedure for an expressive class of string constraints involving the integer data type, which includes not only concatenation, $\replaceall$, $\reverse$, finite transducers, and regular constraints, but also $\length$, $\indexof$ and $\substring$. The decision procedure is automata-theoretic and utilises a variant of cost-register automata introduced by Alur et al. \cite{RLJ+13}, called \emph{cost-enriched finite automata} (abbreviated as CEFA). The crux of the decision procedure is to compute the backward images of CEFAs under string functions, thus in the same flavour as that in \cite{CHL+19} for string constraints \emph{without} the integer data type and inherits its elegance by treating the aforementioned seemly diverse string functions in a \emph{simple and generic} way. To the best of our knowledge, the class of string constraints considered in this paper is currently \emph{the most expressive string theory involving the integer data type for which a decision procedure has been achieved}. 
%\emph{the first decision procedure for string constraints that supports the string functions} $\substring$, $\length$, and $\indexof$, as well as concatenation, $\replaceall$, and finite transducers. \zhilin{improve latter}

Most importantly, our decision procedure admits efficient implementation, as an extension of the {\ostrich} solver \cite{CHL+19}, resulting in a new solver {\ostrich}+.  We have done experiments on a wide range of benchmark suites, including the well-known {\kaluzabench} and {\pyexbench}, to evaluate the performance of {\ostrich}+. The experiment results show that 1) {\ostrich}+ is the \emph{only} string constraint solver capable of dealing with finite transducers and integer constraints, and 2) its performance is \emph{comparable} with the best state-of-the-art string constraint solvers (e.g. {\cvc} and {\zthreetrau}). Therefore, {\ostrich}+ achieves a nice balance between expressiveness and efficiency. In particular, {\ostrich}+ solves in \emph{several seconds} the path feasibility of the SSA program in Example~\ref{exmp:running}, which is impressive since the program contains not only complex string functions such as {\tt trim()} (modelled as finite transducers) and {\tt replaceAll}, but also those involving the integer data type, namely $\length$, $\indexof$, and $\substring$. 

\input{related}

