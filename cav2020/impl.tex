%!TEX root = main.tex



the pseudo-code

\begin{algorithm}[htbp]
  \small
  \KwIn{Sets~$\mathit{active}, \mathit{passive}$ of regex constraints, 
    $x \in L$,
    acyclic set~$\mathit{funApps}$ of assignments $x := f(\bar y)$, constraints $LC$ of Linear Integer Constraints.}
  \KwResult{$\mathit{sat}$ if input constraints are satisfiable;\newline
  $\mathit{unsat}$ if input constraints are not satisfiable;\newline
   }

  \Begin{
    \eIf{$\mathit{active} = \emptyset$}{
      \tcc{use symbolic tool to check whether regex constraints are consistent with Linear Integer Constraints}
      \Return{$\mathit{symbolicCheckSat(passive, LC)} $} 
    }{
      \tcc{Compute the pre-image of one function}
      \eIf{there is an assignment~$x := f(y_1, \ldots, y_r)$ defining $x$
        in $\mathit{funApps}$}{
        $\mathit{funApps} \leftarrow \mathit{funApps} \backslash \{x := f(y_1, \ldots, y_r)\}  $\;
        \eIf{ $x$ is string varible}
        {choose all constraint $x\in L$ in $\mathit{active}$\;
        compute the pre-image $f^{-1}(L) = \bigcup_{i=1}^n (L_1^{(i)} \times \cdots \times L_r^{(i)} , preLC^{(i)} ) $\;
        $\mathit{act} \leftarrow \mathit{active} \setminus \{x \in L\}$
         }{
         \tcc{$x$ is integer varible}
          compute the pre-image $f^{-1}(x) = \bigcup_{i=1}^n (L_1^{(i)} \times \cdots \times L_r^{(i)}, preLC^{(i)} ) $\;
          }
    
        \For{$i \leftarrow 1$ \KwTo $n$}{
          $\mathit{newRegexes} \leftarrow
          \{y_1 \in L_1^{(i)}, \ldots, y_r \in L_r^{(i)}\} $\;
          $ \mathit{newLC} \leftarrow \mathit{LC} \cup \mathit{preLC^{(i)} } $\;
          \eIf{$\mathit{act} \cup \mathit{pas} \cup \mathit{newRegexes}$ is inconsistent}{
            \Return{unsat}
          }{
          \Switch{$\mathit{checkSat}(\mathit{act}
            \cup \mathit{newRegexes},\;
          \mathit{pas},\;
          \mathit{funApps},\;
           \mathit{newLC} )$}{
          \uCase{$sat$}{
            \Return{$sat$}\;
          }
          \Case{$unsat$}{
            $CONTINUE $ \tcc*{backtrack}
          }
          }
        }}
        \Return{unsat} 
      }{
        \tcc{funApps is null }
        \Return{$\mathit{checkSat}(\mathit{active \backslash \{x\in L\} },\;
          \mathit{passive \cup \{x\in L\}},\;
          \mathit{funApps},\;
           \mathit{LC} )$}
      }
%      , and
%      the function application~$x = f(\bar y)$ in $\mathit{funApps}$\;
%      $\mathit{active} \leftarrow \mathit{active} \setminus \{x \in L\}$\;
%      $\mathit{passive} \leftarrow \mathit{passive} \cup \{x \in L\}$\;
    }
  }

  \caption{Recursive function~$\mathit{checkSat}$
    defining depth-first satisfiable check for
    $SL_{int}$ \label{alg:dfs}}
\end{algorithm}


Written in Scala.

Extension of NFA to CEFA. Extend the Class $State$, transition set $\delta(q) \subseteq  \Sigma \times Q$ changed into  $\delta(q) \subseteq \Sigma \times Q \times \Int^k$. 

reduce the number of registers
\begin{itemize}
\item $\substring(x, 0, i)$, $\indexof_v(x, 0)$, remove the input register,
%
\item CEFAs without registers: product + minimization 

CEFAs with one register updated with $+1$: product + minimization

Other CEFAs: no optimization
\end{itemize}

$prefixOf(x, u), suffixOf(x,u), contains(x, u)$: transformed into regular constraints

using nuxmv to avoid state explosion of the product operation.

introduction to nuxmv

introduction to the encoding into nuxmv instances

\begin{example}
An example for the nuxmv encoding.
\end{example}

start two threads, one guessing sat, another one guessing unsat, run concurrently

three strategies: 

product + parikh image

product + nuxmv

nuxmv


