%!TEX root = main.tex



the pseudo-code

\begin{algorithm}[htbp]
  \small
  \KwIn{$active, passive$: sets of CEFA constraints, 
%    $x \in L$,
    acyclic set $\mathit{funApps}$ of assignment statements $x := f(\bar y)$, $LA$: set of LIA constraints. }
  \KwResult{$\mathit{sat}$ if input constraints are satisfiable;\newline
  $\mathit{unsat}$ if input constraints are not satisfiable;\newline
   }

  \Begin{
    \eIf{$\mathit{active} = \emptyset$}{
      \tcc{use symbolic model checker {NuXmv} to check whether regex constraints are consistent with Linear Integer Constraints}
      \Return{$symbolicCheckSat(passive, LA)$} 
    }{
      choose a constraint $x \in L$ in $active$\;
      \tcc{Compute the pre-image of one function}
      \eIf{there is an assignment~$x := f(y_1, \ldots, y_r)$ defining $x$
        in $\mathit{funApps}$}{
%        $\mathit{funApps} \leftarrow \mathit{funApps} \backslash \{x := f(y_1, \ldots, y_r)\}  $\;
%        \eIf{ $x$ is string varible}
%        {
%	choose all constraint $x\in L$ in $\mathit{active}$\;
        compute the pre-image $f^{-1}(L) = \bigcup_{i=1}^n (L_1^{(i)} \times \cdots \times L_r^{(i)} , preLA^{(i)} ) $\;
        $\mathit{active} \leftarrow \mathit{active} \setminus \{x \in L\}$; $\mathit{passive} \leftarrow \mathit{passive} \cup \{x \in L\}$\;
%         }{
%         \tcc{$x$ is integer varible}
%          compute the pre-image $f^{-1}(x) = \bigcup_{i=1}^n (L_1^{(i)} \times \cdots \times L_r^{(i)}, preLA^{(i)} ) $\;
%          }
    
        \For{$i \leftarrow 1$ \KwTo $n$}{
          $\mathit{newCEFA} \leftarrow
          \{y_1 \in L_1^{(i)}, \ldots, y_r \in L_r^{(i)}\} $\;
          $ \mathit{newLA} \leftarrow LA \cup \mathit{preLA^{(i)} } $\;
          \eIf{$\mathit{active} \cup \mathit{passive} \cup \mathit{newCEFA}$ is inconsistent}{
            \Return{unsat}
          }{
          \Switch{$\mathit{checkSat}(\mathit{active}
            \cup \mathit{newCEFA},\;
          \mathit{passive},\;
          \mathit{funApps},\;
           \mathit{newLA} )$}{
          \uCase{$sat$}{
            \Return{$sat$}\;
          }
          \Case{$unsat$}{
            $CONTINUE $ \tcc*{backtrack}
          }
          }
        }}
        \Return{unsat} 
      }{
        \tcc{funApps is null }
        \Return{$\mathit{checkSat}(\mathit{active \backslash \{x\in L\} },\;
          \mathit{passive \cup \{x\in L\}},\;
          \mathit{funApps},\;
           \mathit{LA} )$}
      }
%      , and
%      the function application~$x = f(\bar y)$ in $\mathit{funApps}$\;
%      $\mathit{active} \leftarrow \mathit{active} \setminus \{x \in L\}$\;
%      $\mathit{passive} \leftarrow \mathit{passive} \cup \{x \in L\}$\;
    }
  }

  \caption{Recursive function~$\mathit{checkSat}$
    for Step IV-V of the decision procedure \label{alg:dfs}}
\end{algorithm}


Written in Scala.

Extension of NFA to CEFA. Extend the Class $State$, transition set $\delta(q) \subseteq  \Sigma \times Q$ changed into  $\delta(q) \subseteq \Sigma \times Q \times \Int^k$. 

reduce the number of registers
\begin{itemize}
\item $\substring(x, 0, i)$, $\indexof_v(x, 0)$, remove the input register,
%
\item CEFAs without registers: product + minimization 

CEFAs with one register updated with $+1$: product + minimization

Other CEFAs: no optimization
\end{itemize}

$prefixOf(x, u), suffixOf(x,u), contains(x, u)$: transformed into regular constraints

using nuxmv to avoid state explosion of the product operation.

introduction to nuxmv

introduction to the encoding into nuxmv instances

\begin{example}
An example for the nuxmv encoding.
\end{example}

start two threads, one guessing sat, another one guessing unsat, run concurrently

three strategies: 

product + parikh image

product + nuxmv

nuxmv


