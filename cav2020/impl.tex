%!TEX root = main.tex



the pseudo-code

\begin{algorithm}[htbp]
\SetKw{Continue}{continue}
  \small
  \KwIn{$active, passive$: sets of CEFA constraints, 
%    $x \in L$,
    $funApps$: acyclic set of assignment statements, $LA$: set of LIA constraints. }
  \KwResult{$sat$ if the input constraints are satisfiable, and $unsat$ otherwise;\newline
   }

  \Begin{
    \eIf{$\mathit{active} = \emptyset$}{
      \tcc{use symbolic model checker {NuXmv} to check whether regex constraints are consistent with Linear Integer Constraints}
      \Return{$symbolicCheckSat(passive, LA)$;} 
    }{
      choose a CEFA constraint $x \in \CEFA$ in $active$\;
      \tcc{Compute the $R(\CEFA)$-cost enriched pre-image of $\CEFA$ under $f$}
      \eIf{there is an assignment~$x := f(y_1, \vec{i_1}, \ldots, y_l,\vec{i_l})$ defining $x$
        in $funApps$}{
%        $\mathit{funApps} \leftarrow \mathit{funApps} \backslash \{x := f(y_1, \ldots, y_r)\}  $\;
%        \eIf{ $x$ is string varible}
%        {
%	choose all constraint $x\in L$ in $\mathit{active}$\;
        compute $f^{-1}_{R(\CEFA)}(\Lang(\CEFA)) = ((\CEFA_1^{(j)}, \cdots, \CEFA_l^{(j)})_{j \in [n]}, preLA)$\;
        $active \leftarrow active \setminus \{x \in \CEFA\}$; $passive \leftarrow passive \cup \{x \in \CEFA\}$\;
%         }{
%         \tcc{$x$ is integer varible}
%          compute the pre-image $f^{-1}(x) = \bigcup_{i=1}^n (L_1^{(i)} \times \cdots \times L_r^{(i)}, preLA^{(i)} ) $\;
%          }
    
        \For{$i \leftarrow 1$ \KwTo $n$}{
          $newCEFA \leftarrow
          \{y_1 \in \CEFA_1^{(j)}, \ldots, y_l \in \CEFA_l^{(j)}\} $\;
          $ newLA \leftarrow LA \wedge preLA$\;
          \eIf{$active \cup passive \cup newCEFA$ is inconsistent}{
            \Return{unsat};
          }{
          \Switch{$checkSat(active
            \cup newCEFA,\;
          passive,\;
          funApps,\;
           newLA )$}{
          \uCase{$sat$}{
            \Return{$sat$};
          }
          \Case{$unsat$}{
            \Continue\tcc*{backtrack}
          }
          }
        }}
        \Return{unsat}; 
      }{
%       \tcc{funApps is null }
        \Return{$checkSat(active \backslash \{x\in \CEFA\} ,\;
          passive \cup \{x\in \CEFA\},\;
          funApps,\;
           LA)$;}
      }
%      , and
%      the function application~$x = f(\bar y)$ in $\mathit{funApps}$\;
%      $\mathit{active} \leftarrow \mathit{active} \setminus \{x \in L\}$\;
%      $\mathit{passive} \leftarrow \mathit{passive} \cup \{x \in L\}$\;
    }
  }

  \caption{Recursive function~$\mathit{checkSat}$
    for Step IV and Step V of the decision procedure \label{alg:dfs}}
\end{algorithm}


Written in Scala.

Extension of NFA to CEFA. Extend the Class $State$, transition set $\delta(q) \subseteq  \Sigma \times Q$ changed into  $\delta(q) \subseteq \Sigma \times Q \times \Int^k$. 

reduce the number of registers
\begin{itemize}
\item $\substring(x, 0, i)$, $\indexof_v(x, 0)$, remove the input register,
%
\item CEFAs without registers: product + minimization 

CEFAs with one register updated with $+1$: product + minimization

Other CEFAs: no optimization
\end{itemize}

$prefixOf(x, u), suffixOf(x,u), contains(x, u)$: transformed into regular constraints

using nuxmv to avoid state explosion of the product operation.

introduction to nuxmv

introduction to the encoding into nuxmv instances

\begin{example}
An example for the nuxmv encoding.
\end{example}

start two threads, one guessing sat, another one guessing unsat, run concurrently

three strategies: 

product + parikh image

product + nuxmv

nuxmv


