%!TEX root = main.tex

Strings are widely used in programs, especially in Web programs, e.g. JavaScript, PHP, and Python programs. The integer data type occurs naturally and richly in string-manipulating programs, typically being used to refer to length of, or position in, strings. 
%For instance, the inputs or outputs of widely used string operations including length, substring, and indexof involve the integer data type.
Analysis and testing of string-manipulating programs can be formulated as the path feasibility problem (a.k.a. satisfiability) by symbolic execution, which is to decide whether 
%a given execution path is feasible, namely, 
for a given execution path, there exists an assignment to the inputs that yield a successful execution along the path. 
Symbolic execution of string-manipulating programs relies on string constraint solvers to resolve the path feasibility problem.
%, which plays a central role in the static analysis and verification, e.g. symbolic execution, of programs. 
%Path feasibility problem of string-manipulating programs is very challenging and undecidable in general, especially when involving the integer data type. 
%Aiming at solving the path feasibility of string-manipulating programs in practice, 
%on the one hand, most of the 
Although state-of-the-art string constraint solvers usually provide support for both the string and integer data type,   
 %strong support of complex string operations, in conjunction with limited support of integer data type. 
they are largely benchmark-oriented and mainly resort to heuristics without completeness guarantees, partially because it is a generally undecidable problem. \\
%
In this paper, we propose a decision procedure 
%of the path feasibility problem 
for a class of string-manipulating programs
which support  not only the pure string operations %involving only the string data type, e.g. 
such as concatenation, replaceAll, reverse, and finite transducers, but also those operations involving integer data type, e.g., length, indexof, and substring. To the best of our knowledge, this represents one of the most expressive string constraint languages which are currently known to be decidable. 
Our decision procedure is automata-theoretic and based on a variant of cost register automata (Alur et al. LICS 2013). 
%To the best of our knowledge, %this is %the first time that 
%the first (complete) decision procedure which covers the most expressive string constraint language %have been achieved for the path feasibility problem of such an expressive class of string-manipulating programs. Furthermore, 
%Different from most string constraint solving techniques which provide completeness guarantees, 
More importantly, our decision procedure is simple, generic, and amenable to implementation. 
%We implement the decision procedure on top of OSTRICH, resulting into a new solver called 
The implementation is built on top of a recent solver OSTRICH,
%, which focuses on string constraints without integer data type, 
giving rise to OSTRICH+.
%, which is based on a recent solver OSTRICH which could not tackle integer data types. 
We utilise a wide range of benchmarks to evaluate the performance of OSTRICH+. The experiment results show that OSTRICH+ is the first string constraint solver capable of verifying properties (e.g. idempotence) of HTML sanitizers (e.g. trim) and its performance is comparable with some of the best state-of-the-art string constraint solvers.
