%!TEX root = main.tex

We write $\nat$ for the set of natural numbers and $\Int$ for the set of integer numbers. For $n \in \nat$ with $n \ge 1$, we use $[n]$ to denote $\{1, \cdots, n\}$. Throughout the paper, we use $\Sigma$ to denote a  finite alphabet. We will use $a,b,\cdots$ to denote the elements of $\Sigma$.

\paragraph*{Strings, languages, and transductions.}
A string over $\Sigma$ is a (possibly empty) sequence of elements from $\Sigma$. An empty string is usually denoted by $\varepsilon$. We will use $u, v, w, \cdots$ to denote strings. 

Let $u$ be a string over $\Sigma$. We use $|u|$ to denote the length of $|u|$, namely, the number of occurrences of elements of $\Sigma$ in $u$. In particular, $|\varepsilon|=0$. Moreover, for $a \in \Sigma$, let $|u|_a$ denote the number of occurrences of $a$ in $u$. Suppose $u$ is nonempty. Then a \emph{position} of $u$ is a number $i \in [|u|]$ (Note that the first position is $1$, instead of  0). In addition, for $i \in [|u|]$, let $u[i]$ denote the $i$-th letter of $u$. 

Let $u, v$ be two strings. We use $u \cdot v$ to denote the \emph{concatenation} of $u$ and $v$, that is, the string $w$ such that $|w|= |u| + |v|$ and for each $i \in [|u|]$, $w[i]= u[i]$, and for each $i \in |v|$, $w[|u|+i]=v[i]$. The string $u$ is said to be a \emph{prefix} of $v$ if $v = u \cdot v'$ for some string $v'$.
In addition, if $u \neq v$, then $u$ is said to be a \emph{strict} prefix of $v$. If $u$ is a prefix of $v$, that is, $v = u \cdot v'$ for some string $v'$, then 
we use $u^{-1} v$ to denote $v'$. In particular, $\varepsilon^{-1} v = v$.
If $u=a_1 \cdots a_n$ is nonempty, then we use $u^R$ to denote the \emph{reverse} of $u$, that is, $u^R= a_n \cdots a_1$.

We write $\Sigma^*$ (resp. $\Sigma^+$) for the set of all (resp. nonempty) strings over $\Sigma$. 

A \emph{language} over $\Sigma$ is a subset of $\Sigma^*$.  
We will use $L_1, L_2, \dots$ to denote languages. For two languages $L_1$ and $L_2$, let $L_1 \cup L_2$ denote the union of $L_1$ and $L_2$, and $L_1 \cdot L_2$ denote the concatenation of $L_1$ and $L_2$, that is, the language $\{u_1 \cdot u_2 \mid u_1 \in L_1, u_2 \in L_2\}$. 
For a language $L$ and $n \in \Nat$, we define $L^n$, the \emph{iteration} of $L$ for $n$ times, inductively as follows: $L^0=\{\varepsilon\}$ and $L^{n} =L \cdot L^{n-1}$ for $n > 0$. We also use $L^*$ to denote an arbitrary number of iterations of $L$, that is, $L^* = \bigcup \limits_{n \in \Nat} L^n$. Moreover, let $L^+ = \bigcup \limits_{n \in \Nat \setminus \{0\}} L^n$. 

A \emph{transduction} over $\Sigma$ is a binary relation over $\Sigma^*$, namely, a subset of $\Sigma^* \times \Sigma^*$. We will use $T_1, T_2,\cdots$ to denote transductions. For two transductions $T_1$ and $T_2$, we will use $T_1 \cdot T_2$ to denote the \emph{composition} of $T_1$ and $T_2$, namely, $T_1 \cdot T_2 = \{(u, w) \in \Sigma^* \times \Sigma^* \mid \emph{there exists } v \in \Sigma^* \mbox{ s.t. } (u,v) \in T_1 \mbox{ and } (v,w) \in T_2\}$.


\paragraph*{Regular expressions.}
Regular expressions $\regexp$ are defined by the following rules,
%
	\[e \eqdef \emptyset \mid \varepsilon \mid a \mid e + e \mid e \concat e \mid e^*, \mbox{ where } a \in \Sigma. \]
%
Since $+$ is associative and commutative, we also write $(e_1 + e_2) + e_3$ as $e_1 + e_2 + e_3$ for brevity. We use the abbreviation $e^+ \equiv e \concat e^*$. Moreover, for $\Gamma = \{a_1, \ldots, a_n\}\subseteq \Sigma$, we use the abbreviations $\Gamma \equiv a_1 + \cdots + a_n$ and $\Gamma^\ast \equiv (a_1 + \cdots + a_n)^\ast$. 

We define $\Ll(e)$ to be the language defined by $e$, that is, the set of strings that match $e$, inductively as follows: $\Ll(\emptyset) =\emptyset$,
%\begin{itemize}
%\item 
$\Ll(\varepsilon) =\{\varepsilon\}$,
%
%\item 
$\Ll(a)= \{a\}$,
%
%\item 
$\Ll(e_1 + e_2) = \Ll(e_1) \cup \Ll(e_2)$,
%
%\item 
$\Ll(e_1 \concat e_2) = \Ll(e_1) \cdot \Ll(e_2)$,
%
%\item 
$\Ll(e_1^*)=(\Ll(e_1))^*$.
%\end{itemize}
In addition, we use $|e|$ to denote the number of symbols occurring in $e$.


\paragraph*{Automata models.} A \emph{nondeterministic finite automaton} (NFA) $\NFA$ is a tuple $(Q, \Sigma, \delta, I, F)$, where $Q$ is a finite set of states, $\Sigma$ is a finite alphabet, $\delta \subseteq Q \times \Sigma \times Q$ is the transition relation, $I,F \subseteq Q$ are the set of initial and final states respectively. For readability, we write a transition $(q, a, q') \in \delta$ as $q \xrightarrow[\delta]{a} q'$. Moreover, when $\delta$ is clear from the context, we omit $\delta$ in $q \xrightarrow[\delta]{a} q'$ and write $q \xrightarrow{a} q'$.
%
A \emph{run} of $\NFA$ on a string $w = a_1 \cdots a_n$ is a sequence of transitions $q_0 \xrightarrow{a_1} q_1 \cdots q_{n-1} \xrightarrow{a_n} q_n$ with $q_0 \in I$. The run is \emph{accepting} if $q_n \in F$.
A string $w$ is accepted by an NFA $\NFA$ if there is an accepting run of $\NFA$ on $w$. In particular, the empty string $\varepsilon$ is accepted by $\NFA$ if $I \cap F \neq \emptyset$. The language defined by $\NFA$, denoted by $\Lang(\NFA)$, is the set of strings accepted by $\NFA$. An NFA $\NFA$ is said to be \emph{deterministic} if $I$ is a singleton, moreover, for every $q \in Q$ and $a \in \Sigma$, there is at most one state $q' \in Q$ such that $(q, a, q') \in \delta$.

 
%Fix a finite \emph{alphabet} $\Sigma$. Elements in $\Sigma^*$ are called \emph{strings}. Let $\varepsilon$ denote the empty string and  $\Sigma^+ = \Sigma^* \setminus \{\varepsilon\}$. We will use $a,b,\ldots$ to denote letters from $\Sigma$ and $u, v, w, \ldots$ to denote strings from $\Sigma^*$. For a string $u \in \Sigma^*$, let $|u|$ denote the \emph{length} of $u$ (in particular, $|\varepsilon|=0$), moreover, 

%Let $w=a_1\cdots a_n$ be a string. The reverse of $w$, denoted by $w^{(r)}$, is $a_n \cdots a_1$. 



A \emph{nondeterministic finite transducer} (NFT) $\NFT$ is an extension of NFA with outputs, formally, an NFT $\NFT$ is a tuple $(Q, \Sigma, \delta, I, F)$, where $Q, \Sigma, I, F$ are as in NFA, and the transition relation $\delta$ is a finite subset of $Q \times \Sigma \times Q \times \Sigma^*$. Similarly to NFA, for readability, we write a transition $(q, a, q', u) \in \delta$ as $q \xrightarrow[\delta]{a, u} q'$ or even $q \xrightarrow{a, u} q'$. 
%
A run of $\NFT$ over a string $w=a_1 \cdots a_n$ is a sequence of transitions $q_0 \xrightarrow{a_1, u_1} q_1 \cdots q_{n-1} \xrightarrow{a_n, u_n} q_n$ with $q_0 \in I$. The run is accepting if $q_n \in F$. The string $u_1 \cdots u_n$ is called the output of the run. The transduction defined by $\NFT$, denote dby $\Tran(\NFT)$, is the set of string pairs $(w, u)$ such that there is an accepting run of $T$ on $w$, with the output $u$. An NFT $\NFT$ is said to be \emph{deterministic} if $I$ is a singleton, moreover, for every $q \in Q$ and $a \in \Sigma$, there is at most one pair $(q', u) \in Q \times \Sigma^*$ such that $(q, a, q', u) \in \delta$.

%We remark that an FT usually defines a relation.

\medskip

In this paper, we consider logics involving two data types, i.e., the string data type and the integer data type. We will use $u, v, \dots$ to denote string constants,  $c, d,\dots$ to denote integer constants, $x, y, \dots$ to denote string variables, and $i, j, \dots$ to denote  integer variables.


\paragraph*{Linear integer arithmetic.}  A linear integer arithmetic formula $\phi$ is defined by the following rules
\[
\begin{array}{l c l}
t & ::=  & i \mid c \mid ct \mid t + t, \mbox{ where } c \in \Nat, \\
\phi &::= & t \ o \ t \mid \neg \phi \mid \phi \vee \phi \mid \exists i.\ \phi, \mbox{ where } o \in \{=, \neq, \le, \ge, <, >\}.
\end{array}
\]
Let $\phi$ be a linear integer arithmetic formula and $i$ be a variable occurring in $\phi$. Then an occurrence of $i$ in $\phi$ is said to be \emph{free}  if the occurrence is not under the scope of $\exists i$. A formula $\phi$ is \emph{quantifier-free} if it does not contain quantifiers. The semantics of linear integer arithmetic formula is standard and its definition is omitted here.
For a quantifier-free formula $\phi$ that contains the free variables $i_1, \cdots, i_k$, we use $\cM(\phi)$ to denote the set of models of $\phi$, namely, $\cM(\phi) = \left\{(c_1, \cdots ,c_k) \in \Int^k \mid \phi[c_1/i_1, \cdots, c_k/i_k] \mbox{ is evaluated to } true\right\}$, where $\phi[c_1/i_1, \cdots, c_k/i_k]$ is the formula obtained from $\phi$ by simultaneously replacing $i_1,\cdots, i_k$ with $c_1,\cdots, c_k$. An \emph{existential} linear arithmetic formula is a linear integer arithmetic formula where all the existential quantifiers are under the scope of an even number of negation symbols.
